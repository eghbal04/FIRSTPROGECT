<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Network Tree - IAM</title>
    
    <!-- Error handling for extension connections -->
    <script>
        // Suppress extension connection errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Suppress unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            if (e.reason && e.reason.message && e.reason.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/mobile-responsive.css">
    <link rel="stylesheet" href="css/mobile-user-popup.css">
    <link rel="stylesheet" href="css/pyramid-tree.css">
    
    <!-- Load ethers.js -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
</head>
<body>
    <!-- Back Button -->
    <a href="index.html" class="back-btn">
        ‚Üê Back to Dashboard
    </a>
    
    <div id="main-network" class="page-section expandable-container" style="width:100vw;max-width:none;margin:0;left:0;right:0;padding:0.5rem 0;">
        <div class="expand-header">
            <h2 style="color: #00ff88; margin: 0;">üåê Network</h2>
        </div>
        <div class="expand-content">
            <div class="network-container" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
                <!-- Network Stats -->
                <div id="network-stats" class="network-user-info-container"></div>
                
                <!-- Wallet Connection Status -->
                <div id="wallet-status" style="margin-bottom: 1rem; text-align: center;">
                    <div id="wallet-info" style="color: #00ccff; font-size: 0.9em;">
                        üîÑ Connecting to wallet...
                    </div>
                </div>
                
                <!-- File Manager Style Tree Display -->
                <div id="file-manager-tree">
                    <div class="file-manager-container">
                        <!-- File Manager Header -->
                        <div class="file-manager-header">
                            <div class="file-manager-title">
                                <span class="file-icon">üìÅ</span>
                                <span>Network Tree Manager</span>
                            </div>
                            <div class="file-manager-actions">
                                <button id="expand-all-btn" class="action-btn">üìÇ Expand All</button>
                                <button id="collapse-all-btn" class="action-btn">üìÅ Collapse All</button>
                                <button id="refresh-tree-btn" class="action-btn">üîÑ Refresh</button>
                            </div>
                        </div>
                        
                        <!-- File Manager Content -->
                        <div class="file-manager-content">
                            <div class="file-manager-sidebar">
                                <div class="sidebar-section">
                                    <div class="sidebar-title">üåê Networks</div>
                                    <div class="network-list-sidebar" id="network-list-sidebar">
                                        <!-- Network list will be rendered here -->
                                    </div>
                                </div>
                            </div>
                            
                            <div class="file-manager-main">
                                <div class="file-manager-breadcrumb" id="breadcrumb">
                                    <span class="breadcrumb-item active">üè† Root</span>
                                </div>
                                
                                <div class="file-manager-tree-view" id="tree-view">
                                    <!-- Tree structure will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/config.js"></script>
    <script src="js/walletconnect-handler.js"></script>
            <script src="js/network.js?v=20250809-36"></script>
    <script src="js/navbar.js"></script>
    <script src="js/token-balances.js"></script>
    <script src="js/tree-events.js"></script>
    
    <script>
        // Pyramid Tree Data
        let pyramidData = {
            root: {
                id: 1,
                index: 'Connected Wallet',
                expanded: false,
                children: [
                    { id: 2, index: '2', expanded: false, children: [] },
                    { id: 3, index: '3', expanded: false, children: [] }
                ]
            }
        };

        // Connect to wallet and get real data
        async function connectWalletAndLoadData() {
            try {
                console.log('üîó Connecting to wallet...');
                
                // Check if wallet is already connected
                if (window.contractConfig && window.contractConfig.contract) {
                    console.log('‚úÖ Wallet already connected');
                    
                    // Ensure userAddress is set
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set from provider:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                }
                
                // Try to connect wallet
                if (window.connectWallet) {
                    await window.connectWallet();
                    console.log('‚úÖ Wallet connected successfully');
                    
                    // Ensure userAddress is set after connection
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set after connection:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå connectWallet function not available');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                return false;
            }
        }

        // Get real wallet data
        async function getRealWalletData() {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available');
                    return null;
                }

                const contract = window.contractConfig.contract;
                const userAddress = window.contractConfig.userAddress;
                
                if (!userAddress) {
                    console.log('‚ùå User address not available, trying to get from provider...');
                    // Try to get address from provider
                    if (window.ethereum && window.ethereum.selectedAddress) {
                        const providerAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ Got address from provider:', providerAddress);
                        window.contractConfig.userAddress = providerAddress;
                    } else {
                        console.log('‚ùå No address available from provider either');
                        return null;
                    }
                }

                console.log('üì° Fetching real wallet data...');
                
                // Use the updated userAddress
                const currentUserAddress = window.contractConfig.userAddress;
                console.log('üìç Using address:', currentUserAddress);
                
                // Get user's index (IAM ID)
                const userIndex = await window.getIndexByAddress(contract, currentUserAddress);
                console.log('‚úÖ User Index:', userIndex.toString());
                
                if (!userIndex || userIndex === 0n) {
                    console.log('‚ùå User not registered');
                    return null;
                }
                
                // Get user's children using getUserTree
                let children = [];
                try {
                    const userTree = await contract.getUserTree(currentUserAddress);
                    console.log('‚úÖ User tree data:', userTree);
                    
                    // userTree returns [leftAddress, rightAddress, activated, ...]
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                    } catch (error) {
                    console.log('‚ö†Ô∏è getUserTree failed, trying getLeftChild/getRightChild...');
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(userIndex);
                        const rightChildIndex = await contract.getRightChild(userIndex);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log('‚ö†Ô∏è getLeftChild/getRightChild also failed, using empty children');
                        children = [];
                    }
                }
                console.log('‚úÖ User children indices:', children);
                
                // Update pyramid data with real data
                pyramidData.root.index = userIndex.toString();
                
                if (children && children.length > 0) {
                    pyramidData.root.children = children.map((child, index) => ({
                        id: index + 2,
                        index: child.toString(),
                        expanded: false,
                        children: []
                    }));
                }
                
                console.log('‚úÖ Real wallet data loaded:', pyramidData);
                return pyramidData;

            } catch (error) {
                console.error('‚ùå Error fetching real wallet data:', error);
                return null;
            }
        }

                // Create pyramid node - Only render direct children (lazy loading)
        function createPyramidNode(node, level = 0) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'pyramid-node';
            nodeDiv.style.marginLeft = `${level * 20}px`;
            
            // Set data-index for color determination (odd/even)
            const nodeIndex = parseInt(node.index);
            nodeDiv.setAttribute('data-index', nodeIndex);
            nodeDiv.setAttribute('data-odd-even', nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            
            // Set data-index-length based on index length
            const indexLength = node.index.toString().length;
            buttonContainer.setAttribute('data-index-length', indexLength);
            
            // Expand button
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            
            // Always set normal state (loading is handled in toggleNode)
            expandBtn.setAttribute('data-loading', 'false');
            expandBtn.textContent = node.expanded ? '‚ñº' : '‚ñ∂';
            
            expandBtn.onclick = () => toggleNode(node.id);
            
            // Index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            nodeDiv.appendChild(buttonContainer);
            
            // Children container - Only render direct children (lazy loading)
            if (node.children && node.children.length > 0 && node.expanded) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                childrenContainer.style.display = 'block';
                
                // Only render direct children - grandchildren will be loaded when their parent is expanded
                node.children.forEach(child => {
                    const childNode = createPyramidNode(child, level + 1);
                    childrenContainer.appendChild(childNode);
                });
                
                nodeDiv.appendChild(childrenContainer);
            }
            
            return nodeDiv;
        }

        // Toggle node expansion
        async function toggleNode(nodeId) {
            const node = findNode(pyramidData.root, nodeId);
            if (node) {
                // Find the expand button for this node
                const expandBtn = document.querySelector(`[onclick="toggleNode(${nodeId})"]`);
                
                // If expanding and no children loaded yet, show loading
                if (!node.expanded && (!node.children || node.children.length === 0)) {
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'true');
                        expandBtn.innerHTML = '<div class="loading-spinner"></div>';
                    }
                    
                    // Load children (only direct children - lazy loading)
                    await loadNodeChildren(node);
                    
                    // Hide loading for parent
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                    }
                    
                    // Don't set loading state for children - only the clicked button shows loading
                } else if (!node.expanded && node.children && node.children.length > 0) {
                    // If children already exist but node is collapsed, just expand
                    // No need to load children again
                } else if (node.expanded) {
                    // If collapsing, reset loading state for all children
                    resetChildrenLoading(node);
                }
                
                node.expanded = !node.expanded;
                
                // Re-render the network lists to show/hide children
                renderNetworkLists();
            }
        }

        // Load children for a specific node - Only direct children (lazy loading)
        async function loadNodeChildren(node) {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available for loading children');
                    // Reset loading state on error
                    const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                        expandBtn.textContent = '‚ñ∂';
                    }
                    return;
                }

                const contract = window.contractConfig.contract;
                
                // Use node index directly (no IAM prefix)
                const iamId = node.index;
                console.log(`üì° Loading children for IAM ID: ${iamId}`);
                
                // Get children from contract using correct methods
                let children = [];
                try {
                    // Convert IAM ID to address first
                    const childAddress = await window.getAddressByIndex(contract, iamId);
                    if (!childAddress || childAddress === '0x0000000000000000000000000000000000000000') {
                        console.log(`‚ö†Ô∏è No address found for IAM ID ${iamId}`);
                        return;
                    }
                    
                    // Get user tree for this child
                    const userTree = await contract.getUserTree(childAddress);
                    console.log(`‚úÖ User tree for ${node.index}:`, userTree);
                    
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è getUserTree failed for ${iamId}, trying getLeftChild/getRightChild...`);
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(iamId);
                        const rightChildIndex = await contract.getRightChild(iamId);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log(`‚ö†Ô∏è getLeftChild/getRightChild also failed for ${iamId}`);
                        children = [];
                    }
                }
                console.log(`‚úÖ Children indices for ${node.index}:`, children);
                
                if (children && children.length > 0) {
                    node.children = children.map((child, index) => ({
                        id: node.id * 10 + index + 1,
                        index: child.toString(),
                        expanded: false,
                        children: [], // Will be loaded when this child is expanded
                        loading: false // Children don't have loading state
                    }));
                    
                    console.log(`‚úÖ Created ${node.children.length} children for node ${node.index}`);
                } else {
                    console.log(`‚ö†Ô∏è No children found for node ${node.index}`);
                }
                
            } catch (error) {
                console.error(`‚ùå Error loading children for ${node.index}:`, error);
                // Reset loading state on error
                const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                if (expandBtn) {
                    expandBtn.setAttribute('data-loading', 'false');
                    expandBtn.textContent = '‚ñ∂';
                }
                // No need to reset children loading state since they don't have it
            }
        }

        // Reset loading state for all children of a node (simplified)
        function resetChildrenLoading(node) {
            // No longer needed since children don't have loading state
            // Only the clicked button shows loading
        }

        // Show user popup for a specific node
        async function showUserPopup(node) {
            try {
                if (!window.mobileUserPopup) {
                    console.log('‚ùå Mobile user popup not available');
                    return;
                }

                console.log('üîÑ Showing user popup for node:', node.index);

                // Get user address by index
                let userAddress = null;
                if (window.contractConfig && window.contractConfig.contract) {
                    try {
                        userAddress = await window.getAddressByIndex(window.contractConfig.contract, node.index);
                        console.log('‚úÖ User address found:', userAddress);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get address for index:', node.index, error);
                    }
                }

                // Get user data
                let userData = null;
                if (userAddress && window.contractConfig && window.contractConfig.contract) {
                    try {
                        userData = await window.contractConfig.contract.getUserByAddress(userAddress);
                        console.log('‚úÖ User data found:', userData);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get user data for address:', userAddress, error);
                    }
                }

                // Create user object for popup
                const user = {
                    index: node.index,
                    binaryPoints: userData ? userData.binaryPoints : 0,
                    binaryPointCap: userData ? userData.binaryPointCap : 0,
                    totalMonthlyRewarded: userData ? userData.totalMonthlyRewarded : 0,
                    binaryPointsClaimed: userData ? userData.binaryPointsClaimed : 0,
                    refclimed: userData ? userData.refclimed : '0',
                    depositedAmount: userData ? userData.depositedAmount : '0',
                    leftPoints: userData ? userData.leftPoints : 0,
                    rightPoints: userData ? userData.rightPoints : 0
                };

                // Show popup
                window.mobileUserPopup.show(userAddress, user);

            } catch (error) {
                console.error('‚ùå Error showing user popup:', error);
                
                // Show popup with minimal data if there's an error
                const fallbackUser = {
                    index: node.index,
                    binaryPoints: 0,
                    binaryPointCap: 0,
                    totalMonthlyRewarded: 0,
                    binaryPointsClaimed: 0,
                    refclimed: '0',
                    depositedAmount: '0',
                    leftPoints: 0,
                    rightPoints: 0
                };
                
                if (window.mobileUserPopup) {
                    window.mobileUserPopup.show(null, fallbackUser);
                }
            }
        }

        // Find node by ID - Recursive search through all loaded nodes
        function findNode(node, id) {
            if (node.id === id) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNode(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render file manager tree
        function renderPyramidTree() {
            console.log('üîÑ Rendering file manager tree...');
            
            // Initialize file manager
            initializeFileManager();
            
            // Load tree data
            loadFileManagerTree();
        }

        // File Manager Data
        let fileManagerData = {
            currentPath: ['root'],
            expandedNodes: new Set(),
            treeData: {},
            networks: []
        };

        // Initialize file manager
        function initializeFileManager() {
            console.log('üîß Initializing file manager...');
            
            // Setup event listeners
            setupFileManagerEvents();
            
            // Initialize sidebar
            initializeSidebar();
            
            // Initialize breadcrumb
            updateBreadcrumb();
        }

        // Setup file manager event listeners
        function setupFileManagerEvents() {
            // Expand All button
            const expandAllBtn = document.getElementById('expand-all-btn');
            if (expandAllBtn) {
                expandAllBtn.addEventListener('click', expandAllNodes);
            }
            
            // Collapse All button
            const collapseAllBtn = document.getElementById('collapse-all-btn');
            if (collapseAllBtn) {
                collapseAllBtn.addEventListener('click', collapseAllNodes);
            }
            
            // Refresh button
            const refreshBtn = document.getElementById('refresh-tree-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', refreshTree);
            }
        }

        // Initialize sidebar
        function initializeSidebar() {
            const sidebar = document.getElementById('network-list-sidebar');
            if (!sidebar) return;
            
            sidebar.innerHTML = `
                <div class="network-item-sidebar active" data-network="all">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>üåê</span>
                        <span>All Networks</span>
                    </div>
                </div>
                <div class="network-item-sidebar" data-network="network1">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>üî∑</span>
                        <span>Network 1</span>
                    </div>
                </div>
                <div class="network-item-sidebar" data-network="network2">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>üî∂</span>
                        <span>Network 2</span>
                    </div>
                </div>
                <div class="network-item-sidebar" data-network="network3">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>üî∏</span>
                        <span>Network 3</span>
                    </div>
                </div>
                <div class="network-item-sidebar" data-network="network4">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>üîπ</span>
                        <span>Network 4</span>
                    </div>
                </div>
            `;
            
            // Add click listeners to sidebar items
            sidebar.querySelectorAll('.network-item-sidebar').forEach(item => {
                item.addEventListener('click', () => {
                    // Remove active class from all items
                    sidebar.querySelectorAll('.network-item-sidebar').forEach(i => i.classList.remove('active'));
                    // Add active class to clicked item
                    item.classList.add('active');
                    
                    // Load selected network
                    const network = item.dataset.network;
                    loadNetworkTree(network);
                });
            });
        }

        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            if (!breadcrumb) return;
            
            const path = fileManagerData.currentPath;
            breadcrumb.innerHTML = path.map((item, index) => {
                const isLast = index === path.length - 1;
                return `
                    <span class="breadcrumb-item ${isLast ? 'active' : ''}" data-path="${path.slice(0, index + 1).join('/')}">
                        ${index === 0 ? 'üè†' : 'üìÅ'} ${item}
                    </span>
                    ${!isLast ? '<span class="breadcrumb-separator">/</span>' : ''}
                `;
            }).join('');
            
            // Add click listeners to breadcrumb items
            breadcrumb.querySelectorAll('.breadcrumb-item').forEach(item => {
                item.addEventListener('click', () => {
                    const newPath = item.dataset.path.split('/');
                    navigateToPath(newPath);
                });
            });
        }

        // Navigate to specific path
        function navigateToPath(path) {
            fileManagerData.currentPath = path;
            updateBreadcrumb();
            renderTreeView();
        }

        // Load file manager tree data
        async function loadFileManagerTree() {
            console.log('üìÅ Loading file manager tree data...');
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è No contract connection, showing empty state');
                    showEmptyTree();
                    return;
                }
                
                // Load root node
                await loadRootNode();
                
                // Render tree view
                renderTreeView();
                
            } catch (error) {
                console.error('‚ùå Error loading file manager tree:', error);
                showErrorTree();
            }
        }

        // Load root node
        async function loadRootNode() {
            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('No user address available');
            }
            
            // Get user info
            const user = await contract.users(userAddress);
            const userIndex = user.index ? user.index.toString() : '1';
            
            // Create root node
            fileManagerData.treeData = {
                id: 'root',
                index: userIndex,
                address: userAddress,
                type: 'root',
                expanded: false,
                children: [],
                hasChildren: true
            };
            
            console.log('‚úÖ Root node loaded:', fileManagerData.treeData);
        }

        // Render tree view
        function renderTreeView() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            if (!fileManagerData.treeData || Object.keys(fileManagerData.treeData).length === 0) {
                showEmptyTree();
                return;
            }
            
            treeView.innerHTML = '';
            
            // Render root node
            renderTreeNode(fileManagerData.treeData, treeView, 0);
        }

        // Render individual tree node
        function renderTreeNode(node, container, depth = 0) {
            const nodeElement = document.createElement('div');
            nodeElement.className = 'tree-node';
            nodeElement.style.marginRight = `${depth * 1.5}rem`;
            
            const isExpanded = fileManagerData.expandedNodes.has(node.id);
            const hasChildren = node.hasChildren || (node.children && node.children.length > 0);
            
            nodeElement.innerHTML = `
                <div class="tree-node-content ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                    ${hasChildren ? `
                        <button class="tree-expand-btn ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                            ${isExpanded ? '‚àí' : '+'}
                        </button>
                    ` : '<div style="width: 20px;"></div>'}
                    
                    <span class="tree-node-icon">${getNodeIcon(node.type)}</span>
                    <span class="tree-node-label">${node.index}</span>
                    <span class="tree-node-info">${node.address ? node.address.substring(0, 6) + '...' + node.address.substring(node.address.length - 4) : ''}</span>
                </div>
            `;
            
            container.appendChild(nodeElement);
            
            // Add click listeners
            const expandBtn = nodeElement.querySelector('.tree-expand-btn');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNodeExpansion(node.id);
                });
            }
            
            const nodeContent = nodeElement.querySelector('.tree-node-content');
            nodeContent.addEventListener('click', () => {
                selectNode(node);
            });
            
            // Render children if expanded
            if (isExpanded && hasChildren) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children';
                nodeElement.appendChild(childrenContainer);
                
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        renderTreeNode(child, childrenContainer, depth + 1);
                    });
                } else {
                    // Load children if not loaded yet
                    loadNodeChildren(node, childrenContainer, depth + 1);
                }
            }
        }

        // Get node icon based on type
        function getNodeIcon(type) {
            switch (type) {
                case 'root': return 'üè†';
                case 'network': return 'üåê';
                case 'node': return 'üë§';
                default: return 'üìÅ';
            }
        }

        // Toggle node expansion
        async function toggleNodeExpansion(nodeId) {
            if (fileManagerData.expandedNodes.has(nodeId)) {
                fileManagerData.expandedNodes.delete(nodeId);
            } else {
                fileManagerData.expandedNodes.add(nodeId);
            }
            
            renderTreeView();
        }

        // Select node
        function selectNode(node) {
            console.log('üéØ Node selected:', node);
            
            // Update breadcrumb
            fileManagerData.currentPath = ['root', node.index];
            updateBreadcrumb();
            
            // Show node details (could be expanded later)
            showNodeDetails(node);
        }

        // Show node details
        function showNodeDetails(node) {
            // This could show a popup or sidebar with node details
            console.log('üìã Node details:', {
                index: node.index,
                address: node.address,
                type: node.type,
                hasChildren: node.hasChildren
            });
        }

        // Load node children
        async function loadNodeChildren(node, container, depth) {
            // Show loading state
            const loadingElement = document.createElement('div');
            loadingElement.className = 'tree-loading';
            loadingElement.innerHTML = `
                <div class="loading-spinner"></div>
                <span>Loading children...</span>
            `;
            container.appendChild(loadingElement);
            
            try {
                const contract = window.contractConfig.contract;
                const nodeIndex = parseInt(node.index);
                
                // Get left and right children
                const leftAddress = await contract.getLeftAddress(nodeIndex);
                const rightAddress = await contract.getRightAddress(nodeIndex);
                
                const children = [];
                
                // Add left child if exists
                if (leftAddress !== '0x0000000000000000000000000000000000000000') {
                    const leftIndex = (nodeIndex * 2).toString();
                    children.push({
                        id: `node_${leftIndex}`,
                        index: leftIndex,
                        address: leftAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    });
                }
                
                // Add right child if exists
                if (rightAddress !== '0x0000000000000000000000000000000000000000') {
                    const rightIndex = (nodeIndex * 2 + 1).toString();
                    children.push({
                        id: `node_${rightIndex}`,
                        index: rightIndex,
                        address: rightAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    });
                }
                
                // Remove loading element
                loadingElement.remove();
                
                // Update node with children
                node.children = children;
                node.hasChildren = children.length > 0;
                
                // Render children
                children.forEach(child => {
                    renderTreeNode(child, container, depth);
                });
                
            } catch (error) {
                console.error('‚ùå Error loading node children:', error);
                loadingElement.innerHTML = `
                    <span style="color: #ff6b6b;">‚ùå Error loading children</span>
                `;
            }
        }

        // Load specific network tree
        async function loadNetworkTree(network) {
            console.log(`üåê Loading network tree: ${network}`);
            
            if (network === 'all') {
                await loadFileManagerTree();
            } else {
                // Load specific network (could be expanded later)
                console.log(`üìÅ Loading ${network} tree...`);
                await loadFileManagerTree();
            }
        }

        // Expand all nodes
        function expandAllNodes() {
            console.log('üìÇ Expanding all nodes...');
            
            // Add all nodes to expanded set
            function addAllNodes(node) {
                if (node.hasChildren) {
                    fileManagerData.expandedNodes.add(node.id);
                }
                if (node.children) {
                    node.children.forEach(child => addAllNodes(child));
                }
            }
            
            if (fileManagerData.treeData) {
                addAllNodes(fileManagerData.treeData);
            }
            
            renderTreeView();
        }

        // Collapse all nodes
        function collapseAllNodes() {
            console.log('üìÅ Collapsing all nodes...');
            fileManagerData.expandedNodes.clear();
            renderTreeView();
        }

        // Refresh tree
        async function refreshTree() {
            console.log('üîÑ Refreshing tree...');
            fileManagerData.expandedNodes.clear();
            fileManagerData.treeData = {};
            await loadFileManagerTree();
        }

        // Show empty tree state
        function showEmptyTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">üìÅ</div>
                    <div>No tree data available</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #a786ff;">
                        Connect your wallet to load the network tree
                    </div>
                </div>
            `;
        }

        // Show error tree state
        function showErrorTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">‚ùå</div>
                    <div>Error loading tree data</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #ff6b6b;">
                        Please try refreshing the page
                    </div>
                </div>
            `;
        }

        // Render all networks in 4 columns with fast traversal
        async function renderNetworkLists() {
            console.log('üöÄ Starting fast network traversal...');
            
            // Get all network lists
            const network1List = document.getElementById('network-1-list');
            const network2List = document.getElementById('network-2-list');
            const network3List = document.getElementById('network-3-list');
            const network4List = document.getElementById('network-4-list');
            
            if (!network1List || !network2List || !network3List || !network4List) return;
            
            // Clear existing content
            network1List.innerHTML = '';
            network2List.innerHTML = '';
            network3List.innerHTML = '';
            network4List.innerHTML = '';
            
            // Show loading state
            const loadingHtml = '<div style="text-align: center; color: #00ff88; padding: 1rem;">üîÑ Loading network...</div>';
            network1List.innerHTML = loadingHtml;
            network2List.innerHTML = loadingHtml;
            network3List.innerHTML = loadingHtml;
            network4List.innerHTML = loadingHtml;
            
            try {
                // Get all networks using fast traversal
                const allNetworks = await getAllNetworksFast();
                console.log('‚úÖ All networks loaded:', allNetworks);
                
                // Render each network in its column
                renderNetworkInColumn(network1List, allNetworks.network1, 'Network 1', 1);
                renderNetworkInColumn(network2List, allNetworks.network2, 'Network 2', 2);
                renderNetworkInColumn(network3List, allNetworks.network3, 'Network 3', 3);
                renderNetworkInColumn(network4List, allNetworks.network4, 'Network 4', 4);
                
            } catch (error) {
                console.error('‚ùå Error loading networks:', error);
                const errorHtml = '<div style="text-align: center; color: #ff4757; padding: 1rem;">‚ùå Error loading network</div>';
                network1List.innerHTML = errorHtml;
                network2List.innerHTML = errorHtml;
                network3List.innerHTML = errorHtml;
                network4List.innerHTML = errorHtml;
            }
        }

        // Fast traversal to get all networks
        async function getAllNetworksFast() {
            if (!window.contractConfig || !window.contractConfig.contract) {
                throw new Error('Contract not available');
            }

            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('User address not available');
            }

            console.log('üì° Starting fast traversal for user:', userAddress);
            
            // Get user's index
            const userIndex = await window.getIndexByAddress(contract, userAddress);
            console.log('‚úÖ User index:', userIndex.toString());
            
            const allNetworks = {
                network1: [],
                network2: [],
                network3: [],
                network4: []
            };
            
            // Get root children first
            const rootChildren = await getNodeChildrenFast(contract, userIndex);
            console.log('‚úÖ Root children:', rootChildren);
            
            if (rootChildren.length === 0) {
                return allNetworks;
            }
            
            // Process each root child and its descendants
            const promises = [];
            
            if (rootChildren.length > 0) {
                promises.push(traverseNetworkFast(contract, rootChildren[0], allNetworks.network1, 'Network 1'));
            }
            if (rootChildren.length > 1) {
                promises.push(traverseNetworkFast(contract, rootChildren[1], allNetworks.network2, 'Network 2'));
            }
            if (rootChildren.length > 2) {
                promises.push(traverseNetworkFast(contract, rootChildren[2], allNetworks.network3, 'Network 3'));
            }
            if (rootChildren.length > 3) {
                promises.push(traverseNetworkFast(contract, rootChildren[3], allNetworks.network4, 'Network 4'));
            }
            
            // Wait for all networks to be traversed
            await Promise.all(promises);
            
            console.log('‚úÖ Fast traversal completed:', allNetworks);
            return allNetworks;
        }

        // Fast traversal for a single network
        async function traverseNetworkFast(contract, rootIndex, networkArray, networkName) {
            console.log(`üîÑ Traversing ${networkName} starting from index:`, rootIndex.toString());
            
            const queue = [rootIndex];
            const visited = new Set();
            let maxDepth = 0;
            const maxNodes = 100; // Limit to prevent hanging
            
            while (queue.length > 0 && networkArray.length < maxNodes) {
                const currentIndex = queue.shift();
                
                if (visited.has(currentIndex.toString())) continue;
                visited.add(currentIndex.toString());
                
                // Add current node to network
                networkArray.push({
                    index: currentIndex.toString(),
                    depth: maxDepth,
                    expanded: false,
                    children: []
                });
                
                // Get children for current node
                try {
                    const children = await getNodeChildrenFast(contract, currentIndex);
                    
                    if (children && children.length > 0) {
                        // Add children to queue for next level
                        queue.push(...children);
                        maxDepth++;
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Could not get children for index ${currentIndex}:`, error);
                    // Continue with next node
                }
                
                // Small delay to prevent overwhelming the contract
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            console.log(`‚úÖ ${networkName} traversal completed: ${networkArray.length} nodes`);
        }

        // Fast method to get node children
        async function getNodeChildrenFast(contract, nodeIndex) {
            try {
                // Convert index to address
                const nodeAddress = await window.getAddressByIndex(contract, nodeIndex);
                if (!nodeAddress || nodeAddress === '0x0000000000000000000000000000000000000000') {
                    return [];
                }
                
                // Get user tree
                const userTree = await contract.getUserTree(nodeAddress);
                const leftAddress = userTree[0];
                const rightAddress = userTree[1];
                const activated = userTree[2];
                
                const children = [];
                
                if (activated) {
                    if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                        const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                        if (leftIndex && leftIndex > 0n) {
                            children.push(leftIndex);
                        }
                    }
                    
                    if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                        const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                        if (rightIndex && rightIndex > 0n) {
                            children.push(rightIndex);
                        }
                    }
                }
                
                return children;
            } catch (error) {
                console.warn(`‚ö†Ô∏è Error getting children for index ${nodeIndex}:`, error);
                return [];
            }
        }

        // Render network in a specific column
        function renderNetworkInColumn(container, networkData, networkName, networkNumber) {
            console.log(`üîÑ Rendering ${networkName}:`, networkData.length, 'nodes');
            
            if (networkData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #a0aec0; padding: 2rem;">No data available</div>';
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Add network stats
            const statsDiv = document.createElement('div');
            statsDiv.style.cssText = `
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                padding: 0.5rem;
                margin-bottom: 1rem;
                text-align: center;
                font-size: 0.9em;
                color: #00ff88;
            `;
            statsDiv.innerHTML = `üìä ${networkData.length} nodes found`;
            container.appendChild(statsDiv);
            
            // Render all nodes in the network
            networkData.forEach((node, index) => {
                const networkItem = createNetworkItem(node, networkName, networkNumber);
                container.appendChild(networkItem);
            });
            
            // Add expand button for manual expansion if needed
            const expandButton = document.createElement('button');
            expandButton.style.cssText = `
                width: 100%;
                background: linear-gradient(45deg, #00ff88, #00cc6a);
                color: #1a202c;
                border: none;
                padding: 0.5rem;
                border-radius: 6px;
                font-weight: 600;
                cursor: pointer;
                margin-top: 1rem;
                transition: all 0.3s ease;
            `;
            expandButton.innerHTML = 'üîÑ Expand More';
            expandButton.onclick = () => expandNetworkManually(networkNumber, networkData);
            container.appendChild(expandButton);
        }

        // Manual expansion for a network
        async function expandNetworkManually(networkNumber, currentNetworkData) {
            console.log(`üîÑ Manual expansion for Network ${networkNumber}`);
            
            const container = document.getElementById(`network-${networkNumber}-list`);
            if (!container) return;
            
            // Show loading
            const expandButton = container.querySelector('button');
            if (expandButton) {
                expandButton.innerHTML = 'üîÑ Expanding...';
                expandButton.disabled = true;
            }
            
            try {
                // Get more nodes for this network
                const newNodes = await getMoreNodesForNetwork(networkNumber, currentNetworkData);
                
                if (newNodes.length > 0) {
                    // Add new nodes to the network
                    newNodes.forEach(node => {
                        const networkItem = createNetworkItem(node, `Network ${networkNumber}`, networkNumber);
                        container.insertBefore(networkItem, expandButton);
                    });
                    
                    // Update stats
                    const statsDiv = container.querySelector('div');
                    if (statsDiv) {
                        const totalNodes = currentNetworkData.length + newNodes.length;
                        statsDiv.innerHTML = `üìä ${totalNodes} nodes found`;
                    }
                }
                
            } catch (error) {
                console.error(`‚ùå Error expanding Network ${networkNumber}:`, error);
            } finally {
                // Reset button
                if (expandButton) {
                    expandButton.innerHTML = 'üîÑ Expand More';
                    expandButton.disabled = false;
                }
            }
        }

        // Get more nodes for a specific network
        async function getMoreNodesForNetwork(networkNumber, currentNetworkData) {
            // This is a simplified version - in reality, you'd implement more sophisticated expansion logic
            const newNodes = [];
            
            // For now, just return some dummy data or implement based on your specific needs
            console.log(`üì° Getting more nodes for Network ${networkNumber}`);
            
            return newNodes;
        }

        // Create a network item for the list
        function createNetworkItem(node, networkName, networkNumber) {
            const networkItem = document.createElement('div');
            networkItem.className = 'network-item';
            
            // Determine odd/even for styling
            const nodeIndex = parseInt(node.index);
            networkItem.classList.add(nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create expand button (for manual expansion)
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            expandBtn.textContent = '‚ñ∂';
            expandBtn.onclick = () => expandNodeManually(node, networkNumber);
            
            // Create index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            // Create depth indicator
            const depthIndicator = document.createElement('span');
            depthIndicator.style.cssText = `
                font-size: 0.7em;
                color: #a0aec0;
                margin-left: 0.5rem;
                background: rgba(0, 0, 0, 0.3);
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
            `;
            depthIndicator.textContent = `D${node.depth || 0}`;
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            buttonContainer.appendChild(depthIndicator);
            
            networkItem.appendChild(buttonContainer);
            
            return networkItem;
        }

        // Manual expansion for a specific node
        async function expandNodeManually(node, networkNumber) {
            console.log(`üîÑ Manual expansion for node ${node.index} in Network ${networkNumber}`);
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    throw new Error('Contract not available');
                }

                const contract = window.contractConfig.contract;
                
                // Get children for this node
                const children = await getNodeChildrenFast(contract, BigInt(node.index));
                
                if (children && children.length > 0) {
                    // Add children to the network
                    const container = document.getElementById(`network-${networkNumber}-list`);
                    if (container) {
                        children.forEach((childIndex, index) => {
                            const childNode = {
                                index: childIndex.toString(),
                                depth: (node.depth || 0) + 1,
                                expanded: false,
                                children: []
                            };
                            
                            const childItem = createNetworkItem(childNode, `Network ${networkNumber}`, networkNumber);
                            
                            // Insert after the current node
                            const currentItem = container.querySelector(`[data-node-index="${node.index}"]`);
                            if (currentItem) {
                                currentItem.insertAdjacentElement('afterend', childItem);
                            } else {
                                container.appendChild(childItem);
                            }
                        });
                    }
                }
                
            } catch (error) {
                console.error(`‚ùå Error expanding node ${node.index}:`, error);
            }
        }



        // Update wallet status
        function updateWalletStatus() {
            const walletInfo = document.getElementById('wallet-info');
            
            if (window.contractConfig && window.contractConfig.userAddress) {
                const userAddress = window.contractConfig.userAddress;
                if (userAddress) {
                    walletInfo.innerHTML = `‚úÖ Connected: ${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
                } else {
                    walletInfo.innerHTML = '‚úÖ Connected: Wallet Address Not Available';
                }
            } else {
                walletInfo.innerHTML = '‚ùå Wallet not connected';
            }
        }

        // Load real data and render tree
        async function loadRealDataAndRender() {
            try {
                console.log('üîÑ Loading real wallet data...');
                
                // Update wallet status
                updateWalletStatus();
                
                // Check if wallet is connected
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è Wallet not connected, using default data');
                    renderPyramidTree();
                    return;
                }
                
                // Get real wallet data
                const realData = await getRealWalletData();
                if (realData) {
                    console.log('‚úÖ Real data loaded, rendering tree...');
                    renderPyramidTree();
                } else {
                    console.log('‚ö†Ô∏è Could not load real data, using default data');
                    renderPyramidTree();
                }
                
            } catch (error) {
                console.error('‚ùå Error loading real data:', error);
                console.log('‚ö†Ô∏è Using default data');
                updateWalletStatus();
                renderPyramidTree();
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Pyramid Tree page loaded');
            
            // Wait a bit for other scripts to load
                setTimeout(async () => {
                    try {
                    // Try to connect wallet automatically
                    console.log('üîÑ Attempting to connect wallet automatically...');
                    const walletConnected = await connectWalletAndLoadData();
                    
                    if (walletConnected) {
                        console.log('‚úÖ Wallet connected automatically, loading real data...');
                        await loadRealDataAndRender();
                        } else {
                        console.log('‚ö†Ô∏è Could not connect wallet automatically, showing default data');
                        updateWalletStatus();
                        renderPyramidTree();
                    }
                    } catch (error) {
                    console.error('‚ùå Error in automatic wallet connection:', error);
                    updateWalletStatus();
                    renderPyramidTree();
                    }
                }, 1000);
        });
    </script>
    
    <!-- Floating Token Growth Card -->
    <script src="js/floating-token-card.js"></script>
    
    <!-- Mobile User Popup -->
    <script>
        // Check if mobile-user-popup is already loaded
        if (!window.mobileUserPopup) {
            // Load the script dynamically to avoid duplicate loading
            const script = document.createElement('script');
            script.src = 'js/mobile-user-popup.js';
            script.onload = function() {
                console.log('‚úÖ Mobile user popup loaded successfully');
            };
            script.onerror = function() {
                console.warn('‚ö†Ô∏è Failed to load mobile user popup');
            };
            document.head.appendChild(script);
        } else {
            console.log('‚úÖ Mobile user popup already loaded');
        }
    </script>
</body>
</html> 