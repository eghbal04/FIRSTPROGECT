<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Network Tree - IAM</title>
    
    <!-- Error handling for extension connections -->
    <script>
        // Suppress extension connection errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Suppress unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            if (e.reason && e.reason.message && e.reason.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css?v=1.1">
    <link rel="stylesheet" href="css/modern-theme.css">
    <link rel="stylesheet" href="css/mobile-responsive.css">
    <link rel="stylesheet" href="css/smooth-transitions.css">
    <link rel="stylesheet" href="css/mobile-user-popup.css">
    <link rel="stylesheet" href="css/pyramid-tree.css">
    
    <style>
        /* Professional Tree Theme Overrides */
        .modern-theme {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            font-family: 'Noto Sans Arabic', sans-serif;
        }
        
        .modern-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .modern-btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #1a202c;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        .modern-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }
        
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .connect-wallet-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            cursor: pointer;
            font-size: 14px;
            padding: 10px 20px;
        }
        
        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }
        
        .connect-wallet-btn:active {
            transform: translateY(0);
        }
        
        .connect-wallet-btn.connected {
            background: linear-gradient(135deg, #00cc6a, #00ff88);
            color: #1a202c;
        }
        
        .connect-wallet-btn.connecting {
            background: linear-gradient(135deg, #ffa500, #ff8c00);
            color: #1a202c;
            cursor: not-allowed;
        }
        
        .connect-wallet-btn.error {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #ffffff;
        }
        
        .file-manager-container {
            margin-top: 2rem;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        
        .file-manager-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .file-icon {
            margin-left: 0.5rem;
            font-size: 1.2em;
        }
        
        /* Mobile responsive for buttons */
        @media (max-width: 768px) {
            .back-btn {
                top: 10px;
                left: 10px;
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .connect-wallet-btn {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .back-btn {
                top: 5px;
                left: 5px;
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .connect-wallet-btn {
                top: 5px;
                right: 5px;
                padding: 6px 12px;
                font-size: 11px;
            }
        }
        
        /* Level-based color system for tree nodes */
        .flat-tree-node {
            transition: all 0.3s ease;
            border-radius: 6px;
            margin-bottom: 0.3rem;
        }
        
        /* Level 0 - Root (brightest) */
        .flat-tree-node[data-depth="0"] {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15), rgba(0, 255, 136, 0.08));
            border: 2px solid rgba(0, 255, 136, 0.4);
            box-shadow: 0 2px 8px rgba(0, 255, 136, 0.2);
        }
        
        /* Level 1 - Very bright */
        .flat-tree-node[data-depth="1"] {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.12), rgba(0, 255, 136, 0.06));
            border: 2px solid rgba(0, 255, 136, 0.35);
            box-shadow: 0 2px 6px rgba(0, 255, 136, 0.15);
        }
        
        /* Level 2 - Bright */
        .flat-tree-node[data-depth="2"] {
            background: linear-gradient(135deg, rgba(0, 230, 119, 0.1), rgba(0, 230, 119, 0.05));
            border: 2px solid rgba(0, 230, 119, 0.3);
            box-shadow: 0 2px 5px rgba(0, 230, 119, 0.12);
        }
        
        /* Level 3 - Medium bright */
        .flat-tree-node[data-depth="3"] {
            background: linear-gradient(135deg, rgba(0, 204, 106, 0.08), rgba(0, 204, 106, 0.04));
            border: 2px solid rgba(0, 204, 106, 0.25);
            box-shadow: 0 2px 4px rgba(0, 204, 106, 0.1);
        }
        
        /* Level 4 - Medium */
        .flat-tree-node[data-depth="4"] {
            background: linear-gradient(135deg, rgba(0, 179, 92, 0.06), rgba(0, 179, 92, 0.03));
            border: 2px solid rgba(0, 179, 92, 0.2);
            box-shadow: 0 1px 3px rgba(0, 179, 92, 0.08);
        }
        
        /* Level 5 - Medium dark */
        .flat-tree-node[data-depth="5"] {
            background: linear-gradient(135deg, rgba(0, 153, 77, 0.05), rgba(0, 153, 77, 0.025));
            border: 2px solid rgba(0, 153, 77, 0.18);
            box-shadow: 0 1px 3px rgba(0, 153, 77, 0.06);
        }
        
        /* Level 6 - Dark */
        .flat-tree-node[data-depth="6"] {
            background: linear-gradient(135deg, rgba(0, 136, 68, 0.04), rgba(0, 136, 68, 0.02));
            border: 2px solid rgba(0, 136, 68, 0.15);
            box-shadow: 0 1px 2px rgba(0, 136, 68, 0.05);
        }
        
        /* Level 7 - Darker */
        .flat-tree-node[data-depth="7"] {
            background: linear-gradient(135deg, rgba(0, 119, 58, 0.03), rgba(0, 119, 58, 0.015));
            border: 2px solid rgba(0, 119, 58, 0.12);
            box-shadow: 0 1px 2px rgba(0, 119, 58, 0.04);
        }
        
        /* Level 8 - Very dark */
        .flat-tree-node[data-depth="8"] {
            background: linear-gradient(135deg, rgba(0, 102, 51, 0.025), rgba(0, 102, 51, 0.012));
            border: 2px solid rgba(0, 102, 51, 0.1);
            box-shadow: 0 1px 2px rgba(0, 102, 51, 0.03);
        }
        
        /* Level 9 - Darkest */
        .flat-tree-node[data-depth="9"] {
            background: linear-gradient(135deg, rgba(0, 85, 34, 0.02), rgba(0, 85, 34, 0.01));
            border: 2px solid rgba(0, 85, 34, 0.08);
            box-shadow: 0 1px 1px rgba(0, 85, 34, 0.025);
        }
        
        /* Level 10+ - Very darkest */
        .flat-tree-node[data-depth="10"],
        .flat-tree-node[data-depth="11"],
        .flat-tree-node[data-depth="12"],
        .flat-tree-node[data-depth="13"],
        .flat-tree-node[data-depth="14"],
        .flat-tree-node[data-depth="15"] {
            background: linear-gradient(135deg, rgba(0, 68, 34, 0.015), rgba(0, 68, 34, 0.007));
            border: 2px solid rgba(0, 68, 34, 0.06);
            box-shadow: 0 1px 1px rgba(0, 68, 34, 0.02);
        }
        
        /* Level 16+ - Almost invisible */
        .flat-tree-node[data-depth="16"],
        .flat-tree-node[data-depth="17"],
        .flat-tree-node[data-depth="18"],
        .flat-tree-node[data-depth="19"],
        .flat-tree-node[data-depth="20"] {
            background: linear-gradient(135deg, rgba(0, 51, 17, 0.01), rgba(0, 51, 17, 0.005));
            border: 2px solid rgba(0, 51, 17, 0.04);
            box-shadow: 0 1px 1px rgba(0, 51, 17, 0.015);
        }
        
        /* Level 21+ - Minimal visibility */
        .flat-tree-node[data-depth="21"],
        .flat-tree-node[data-depth="22"],
        .flat-tree-node[data-depth="23"],
        .flat-tree-node[data-depth="24"],
        .flat-tree-node[data-depth="25"] {
            background: linear-gradient(135deg, rgba(0, 34, 0, 0.008), rgba(0, 34, 0, 0.004));
            border: 2px solid rgba(0, 34, 0, 0.03);
            box-shadow: 0 1px 1px rgba(0, 34, 0, 0.01);
        }
        
        /* Hover effects for all levels */
        .flat-tree-node:hover {
            transform: translateX(2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.2);
        }
        
        /* Active/expanded state */
        .flat-tree-node.expanded {
            border-left: 4px solid #00ff88;
        }
    </style>
    
    <!-- Load ethers.js -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
</head>
<body class="modern-theme">
    <!-- Back Button -->
    <a href="index.html" class="back-btn modern-btn">
        ‚Üê Back to Dashboard
    </a>
    
    <!-- Connect Wallet Button -->
    <button id="connect-wallet-btn" class="connect-wallet-btn modern-btn">
        üîó Connect Wallet
    </button>
    
    <div id="main-network" class="page-section expandable-container modern-card" style="width:100vw;max-width:none;margin:0;left:0;right:0;padding:0.5rem 0;">
        <div class="expand-header">
            <h2 style="color: #00ff88; margin: 0; font-family: 'Montserrat', sans-serif; font-weight: 700;">üåê Network</h2>
        </div>
        <div class="expand-content">
            <div class="network-container modern-card" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
                <!-- Network Stats -->
                <div id="network-stats" class="network-user-info-container"></div>
                

                <!-- File Manager Style Tree Display -->
                <div id="file-manager-tree">
                    <div class="file-manager-container">
                        <!-- File Manager Header -->
                        <div class="file-manager-header">
                            <div class="file-manager-title">
                                <span class="file-icon">üå≥</span>
                                <span style="font-family: 'Montserrat', sans-serif; font-weight: 700; color: #00ff88;">Tree Manager</span>
                            </div>

                        </div>
                        
                        <!-- File Manager Content -->
                        <div class="file-manager-content">
                            <div class="file-manager-main">
                                <div class="file-manager-breadcrumb" id="breadcrumb">
                                    <span class="breadcrumb-item active">üè† Root</span>
                                </div>
                                
                                <div class="file-manager-tree-view" id="tree-view">
                                    <!-- Tree structure will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/config.js"></script>
    <script src="js/walletconnect-handler.js"></script>
            <script src="js/network.js?v=20250809-36"></script>
    <script src="js/navbar.js"></script>
    <script src="js/token-balances.js"></script>
    <script src="js/tree-events.js"></script>
    
    <script>
        // Pyramid Tree Data
        let pyramidData = {
            root: {
                id: 1,
                index: 'Connected Wallet',
                expanded: false,
                children: [
                    { id: 2, index: '2', expanded: false, children: [] },
                    { id: 3, index: '3', expanded: false, children: [] }
                ]
            }
        };

        // Detect if running on mobile
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   window.innerWidth <= 768;
        }

        // Detect MetaMask on mobile
        function detectMetaMask() {
            console.log('üîç Detecting MetaMask...');
            console.log('üì± Is mobile:', isMobile());
            
            // Check for standard ethereum provider
            if (window.ethereum) {
                console.log('‚úÖ Standard ethereum provider found');
                return window.ethereum;
            }
            
            // Check for mobile MetaMask via web3
            if (window.web3 && window.web3.currentProvider) {
                console.log('üì± Mobile MetaMask detected via web3.currentProvider');
                return window.web3.currentProvider;
            }
            
            // Check for mobile MetaMask via web3
            if (window.web3) {
                console.log('üì± Mobile MetaMask detected via web3');
                return window.web3;
            }
            
            // Check for injected provider
            if (window.ethereum && window.ethereum.isMetaMask) {
                console.log('‚úÖ MetaMask injected provider found');
                return window.ethereum;
            }
            
            // Check for mobile-specific providers
            if (isMobile()) {
                console.log('üì± Checking mobile-specific providers...');
                
                // Check for Trust Wallet
                if (window.ethereum && window.ethereum.isTrust) {
                    console.log('‚úÖ Trust Wallet detected');
                    return window.ethereum;
                }
                
                // Check for Coinbase Wallet
                if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                    console.log('‚úÖ Coinbase Wallet detected');
                    return window.ethereum;
                }
                
                // Check for any ethereum provider
                if (window.ethereum) {
                    console.log('‚úÖ Generic ethereum provider found on mobile');
                    return window.ethereum;
                }
            }
            
            console.log('‚ùå No MetaMask detected');
            return null;
        }

        // Connect to wallet and get real data
        async function connectWalletAndLoadData() {
            try {
                console.log('üîó Connecting to wallet...');
                
                // Check if wallet is already connected
                if (window.contractConfig && window.contractConfig.contract) {
                    console.log('‚úÖ Wallet already connected');
                    
                    // Ensure userAddress is set
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set from provider:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                }
                
                // Detect MetaMask provider
                const ethereumProvider = detectMetaMask();
                if (!ethereumProvider) {
                    console.log('‚ùå No MetaMask provider detected');
                    return false;
                }
                
                // Set ethereum provider
                if (!window.ethereum) {
                    window.ethereum = ethereumProvider;
                    console.log('‚úÖ Ethereum provider set');
                }
                
                // Try to connect wallet
                if (window.connectWallet) {
                    console.log('üîÑ Calling connectWallet function...');
                    await window.connectWallet();
                    console.log('‚úÖ Wallet connected successfully');
                    
                    // Ensure userAddress is set after connection
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set after connection:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå connectWallet function not available, trying direct connection...');
                    
                    // Try direct connection
                    try {
                        console.log('üîÑ Attempting direct connection...');
                        
                        // Check if already connected
                        if (window.ethereum.selectedAddress) {
                            console.log('‚úÖ Wallet already connected:', window.ethereum.selectedAddress);
                            
                            // Set up contract config if not exists
                            if (!window.contractConfig) {
                                window.contractConfig = {};
                            }
                            window.contractConfig.userAddress = window.ethereum.selectedAddress;
                            
                            // Try to get contract from other sources
                            if (window.contractConfig.contract) {
                                console.log('‚úÖ Contract already available');
                                return true;
                            }
                            
                            // Try to create contract
                            if (window.ethereum && window.contractConfig.contractAddress && window.contractConfig.contractABI) {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                window.contractConfig.contract = new ethers.Contract(
                                    window.contractConfig.contractAddress,
                                    window.contractConfig.contractABI,
                                    signer
                                );
                                console.log('‚úÖ Contract created successfully');
                                return true;
                            }
                            
                            console.log('‚ö†Ô∏è Contract not available, but wallet connected');
                            return true;
                        }
                        
                        // Request connection
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (accounts && accounts.length > 0) {
                            console.log('‚úÖ Direct wallet connection successful');
                            
                            // Set up contract config if not exists
                            if (!window.contractConfig) {
                                window.contractConfig = {};
                            }
                            window.contractConfig.userAddress = accounts[0];
                            
                            // Try to get contract from other sources
                            if (window.contractConfig.contract) {
                                console.log('‚úÖ Contract already available');
                                return true;
                            }
                            
                            // Try to create contract
                            if (window.ethereum && window.contractConfig.contractAddress && window.contractConfig.contractABI) {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                window.contractConfig.contract = new ethers.Contract(
                                    window.contractConfig.contractAddress,
                                    window.contractConfig.contractABI,
                                    signer
                                );
                                console.log('‚úÖ Contract created successfully');
                                return true;
                            }
                            
                            console.log('‚ö†Ô∏è Contract not available, but wallet connected');
                            return true;
                        }
                    } catch (directError) {
                        console.log('‚ùå Direct connection failed:', directError.message);
                        
                        // Check if it's a user rejection
                        if (directError.code === 4001 || directError.message.includes('User rejected')) {
                            console.log('üë§ User rejected connection');
                            return false;
                        }
                        
                        // Check if it's a mobile-specific error
                        if (directError.message.includes('Please install MetaMask')) {
                            console.log('üì± MetaMask not installed on mobile');
                            return false;
                        }
                    }
                    
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                return false;
            }
        }

        // Get real wallet data
        async function getRealWalletData() {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available');
                    return null;
                }

                const contract = window.contractConfig.contract;
                const userAddress = window.contractConfig.userAddress;
                
                if (!userAddress) {
                    console.log('‚ùå User address not available, trying to get from provider...');
                    // Try to get address from provider
                    if (window.ethereum && window.ethereum.selectedAddress) {
                        const providerAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ Got address from provider:', providerAddress);
                        window.contractConfig.userAddress = providerAddress;
                    } else {
                        console.log('‚ùå No address available from provider either');
                        return null;
                    }
                }

                console.log('üì° Fetching real wallet data...');
                
                // Use the updated userAddress
                const currentUserAddress = window.contractConfig.userAddress;
                console.log('üìç Using address:', currentUserAddress);
                
                // Get user's index (IAM ID)
                const userIndex = await window.getIndexByAddress(contract, currentUserAddress);
                console.log('‚úÖ User Index:', userIndex.toString());
                
                if (!userIndex || userIndex === 0n) {
                    console.log('‚ùå User not registered');
                    return null;
                }
                
                // Get user's children using getUserTree
                let children = [];
                try {
                    const userTree = await contract.getUserTree(currentUserAddress);
                    console.log('‚úÖ User tree data:', userTree);
                    
                    // userTree returns [leftAddress, rightAddress, activated, ...]
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                    } catch (error) {
                    console.log('‚ö†Ô∏è getUserTree failed, trying getLeftChild/getRightChild...');
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(userIndex);
                        const rightChildIndex = await contract.getRightChild(userIndex);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log('‚ö†Ô∏è getLeftChild/getRightChild also failed, using empty children');
                        children = [];
                    }
                }
                console.log('‚úÖ User children indices:', children);
                
                // Update pyramid data with real data
                pyramidData.root.index = userIndex.toString();
                
                if (children && children.length > 0) {
                    pyramidData.root.children = children.map((child, index) => ({
                        id: index + 2,
                        index: child.toString(),
                        expanded: false,
                        children: []
                    }));
                }
                
                console.log('‚úÖ Real wallet data loaded:', pyramidData);
                return pyramidData;

            } catch (error) {
                console.error('‚ùå Error fetching real wallet data:', error);
                return null;
            }
        }

                // Create pyramid node - Only render direct children (lazy loading)
        function createPyramidNode(node, level = 0) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'pyramid-node';
            nodeDiv.style.marginLeft = `${level * 20}px`;
            
            // Set data-index for color determination (odd/even)
            const nodeIndex = parseInt(node.index);
            nodeDiv.setAttribute('data-index', nodeIndex);
            nodeDiv.setAttribute('data-odd-even', nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            
            // Set data-index-length based on index length
            const indexLength = node.index.toString().length;
            buttonContainer.setAttribute('data-index-length', indexLength);
            
            // Expand button
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            
            // Always set normal state (loading is handled in toggleNode)
            expandBtn.setAttribute('data-loading', 'false');
            expandBtn.textContent = node.expanded ? '‚ñº' : '‚ñ∂';
            
            expandBtn.onclick = () => toggleNode(node.id);
            
            // Index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            nodeDiv.appendChild(buttonContainer);
            
            // Children container - Only render direct children (lazy loading)
            if (node.children && node.children.length > 0 && node.expanded) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                childrenContainer.style.display = 'block';
                
                // Only render direct children - grandchildren will be loaded when their parent is expanded
                node.children.forEach(child => {
                    const childNode = createPyramidNode(child, level + 1);
                    childrenContainer.appendChild(childNode);
                });
                
                nodeDiv.appendChild(childrenContainer);
            }
            
            return nodeDiv;
        }

        // Toggle node expansion
        async function toggleNode(nodeId) {
            const node = findNode(pyramidData.root, nodeId);
            if (node) {
                // Find the expand button for this node
                const expandBtn = document.querySelector(`[onclick="toggleNode(${nodeId})"]`);
                
                // If expanding and no children loaded yet, show loading
                if (!node.expanded && (!node.children || node.children.length === 0)) {
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'true');
                        expandBtn.innerHTML = '<div class="loading-spinner"></div>';
                    }
                    
                    // Load children (only direct children - lazy loading)
                    await loadNodeChildren(node);
                    
                    // Hide loading for parent
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                    }
                    
                    // Don't set loading state for children - only the clicked button shows loading
                } else if (!node.expanded && node.children && node.children.length > 0) {
                    // If children already exist but node is collapsed, just expand
                    // No need to load children again
                } else if (node.expanded) {
                    // If collapsing, reset loading state for all children
                    resetChildrenLoading(node);
                }
                
                node.expanded = !node.expanded;
                
                // Re-render the network lists to show/hide children
                renderNetworkLists();
            }
        }

        // Load children for a specific node - Only direct children (lazy loading)
        async function loadNodeChildren(node) {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available for loading children');
                    // Reset loading state on error
                    const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                        expandBtn.textContent = '‚ñ∂';
                    }
                    return;
                }

                const contract = window.contractConfig.contract;
                
                // Use node index directly (no IAM prefix)
                const iamId = node.index;
                console.log(`üì° Loading children for IAM ID: ${iamId}`);
                
                // Get children from contract using correct methods
                let children = [];
                try {
                    // Convert IAM ID to address first
                    const childAddress = await window.getAddressByIndex(contract, iamId);
                    if (!childAddress || childAddress === '0x0000000000000000000000000000000000000000') {
                        console.log(`‚ö†Ô∏è No address found for IAM ID ${iamId}`);
                        return;
                    }
                    
                    // Get user tree for this child
                    const userTree = await contract.getUserTree(childAddress);
                    console.log(`‚úÖ User tree for ${node.index}:`, userTree);
                    
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è getUserTree failed for ${iamId}, trying getLeftChild/getRightChild...`);
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(iamId);
                        const rightChildIndex = await contract.getRightChild(iamId);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log(`‚ö†Ô∏è getLeftChild/getRightChild also failed for ${iamId}`);
                        children = [];
                    }
                }
                console.log(`‚úÖ Children indices for ${node.index}:`, children);
                
                if (children && children.length > 0) {
                    node.children = children.map((child, index) => ({
                        id: node.id * 10 + index + 1,
                        index: child.toString(),
                        expanded: false,
                        children: [], // Will be loaded when this child is expanded
                        loading: false // Children don't have loading state
                    }));
                    
                    console.log(`‚úÖ Created ${node.children.length} children for node ${node.index}`);
                } else {
                    console.log(`‚ö†Ô∏è No children found for node ${node.index}`);
                }
                
            } catch (error) {
                console.error(`‚ùå Error loading children for ${node.index}:`, error);
                // Reset loading state on error
                const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                if (expandBtn) {
                    expandBtn.setAttribute('data-loading', 'false');
                    expandBtn.textContent = '‚ñ∂';
                }
                // No need to reset children loading state since they don't have it
            }
        }

        // Reset loading state for all children of a node (simplified)
        function resetChildrenLoading(node) {
            // No longer needed since children don't have loading state
            // Only the clicked button shows loading
        }

        // Show user popup for a specific node
        async function showUserPopup(node) {
            try {
                if (!window.mobileUserPopup) {
                    console.log('‚ùå Mobile user popup not available');
                    return;
                }

                console.log('üîÑ Showing user popup for node:', node.index);

                // Get user address by index
                let userAddress = null;
                if (window.contractConfig && window.contractConfig.contract) {
                    try {
                        userAddress = await window.getAddressByIndex(window.contractConfig.contract, node.index);
                        console.log('‚úÖ User address found:', userAddress);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get address for index:', node.index, error);
                    }
                }

                // Get user data
                let userData = null;
                if (userAddress && window.contractConfig && window.contractConfig.contract) {
                    try {
                        userData = await window.contractConfig.contract.getUserByAddress(userAddress);
                        console.log('‚úÖ User data found:', userData);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get user data for address:', userAddress, error);
                    }
                }

                // Create user object for popup
                const user = {
                    index: node.index,
                    binaryPoints: userData ? userData.binaryPoints : 0,
                    binaryPointCap: userData ? userData.binaryPointCap : 0,
                    totalMonthlyRewarded: userData ? userData.totalMonthlyRewarded : 0,
                    binaryPointsClaimed: userData ? userData.binaryPointsClaimed : 0,
                    refclimed: userData ? userData.refclimed : '0',
                    depositedAmount: userData ? userData.depositedAmount : '0',
                    leftPoints: userData ? userData.leftPoints : 0,
                    rightPoints: userData ? userData.rightPoints : 0
                };

                // Show popup
                window.mobileUserPopup.show(userAddress, user);

            } catch (error) {
                console.error('‚ùå Error showing user popup:', error);
                
                // Show popup with minimal data if there's an error
                const fallbackUser = {
                    index: node.index,
                    binaryPoints: 0,
                    binaryPointCap: 0,
                    totalMonthlyRewarded: 0,
                    binaryPointsClaimed: 0,
                    refclimed: '0',
                    depositedAmount: '0',
                    leftPoints: 0,
                    rightPoints: 0
                };
                
                if (window.mobileUserPopup) {
                    window.mobileUserPopup.show(null, fallbackUser);
                }
            }
        }

        // Find node by ID - Recursive search through all loaded nodes
        function findNode(node, id) {
            if (node.id === id) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNode(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render file manager tree
        function renderPyramidTree() {
            console.log('üîÑ Rendering file manager tree...');
            
            // Initialize file manager
            initializeFileManager();
            
            // Load tree data
            loadFileManagerTree();
        }

        // File Manager Data
        let fileManagerData = {
            currentPath: ['root'],
            expandedNodes: new Set(),
            treeData: {},
            networks: []
        };

        // Initialize file manager
        function initializeFileManager() {
            console.log('üîß Initializing file manager...');
            
            // Setup event listeners
            setupFileManagerEvents();
            
            // Initialize breadcrumb
            updateBreadcrumb();
        }

        // Setup file manager event listeners
        function setupFileManagerEvents() {
            // No action buttons needed
        }



        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            if (!breadcrumb) return;
            
            const path = fileManagerData.currentPath;
            breadcrumb.innerHTML = path.map((item, index) => {
                const isLast = index === path.length - 1;
                return `
                    <span class="breadcrumb-item ${isLast ? 'active' : ''}" data-path="${path.slice(0, index + 1).join('/')}">
                        ${index === 0 ? 'üè†' : 'üìÅ'} ${item}
                    </span>
                    ${!isLast ? '<span class="breadcrumb-separator">/</span>' : ''}
                `;
            }).join('');
            
            // Add click listeners to breadcrumb items
            breadcrumb.querySelectorAll('.breadcrumb-item').forEach(item => {
                item.addEventListener('click', () => {
                    const newPath = item.dataset.path.split('/');
                    navigateToPath(newPath);
                });
            });
        }

        // Navigate to specific path
        function navigateToPath(path) {
            fileManagerData.currentPath = path;
            updateBreadcrumb();
            renderTreeView();
        }

        // Load file manager tree data
        async function loadFileManagerTree() {
            console.log('üìÅ Loading file manager tree data...');
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è No contract connection, showing empty state');
                    showEmptyTree();
                    return;
                }
                
                // Load root node
                await loadRootNode();
                
                // Render tree view
                renderTreeView();
                
            } catch (error) {
                console.error('‚ùå Error loading file manager tree:', error);
                showErrorTree();
            }
        }

        // Load root node
        async function loadRootNode() {
            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('No user address available');
            }
            
            // Get user info
            const user = await contract.users(userAddress);
            const userIndex = user.index ? user.index.toString() : '1';
            
            // Create root node
            fileManagerData.treeData = {
                id: 'root',
                index: userIndex,
                address: userAddress,
                type: 'root',
                expanded: false,
                children: [],
                hasChildren: true
            };
            
            console.log('‚úÖ Root node loaded:', fileManagerData.treeData);
        }

        // Render tree view - Flat structure
        function renderTreeView() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            if (!fileManagerData.treeData || Object.keys(fileManagerData.treeData).length === 0) {
                showEmptyTree();
                return;
            }
            
            treeView.innerHTML = '';
            
            // Render all nodes in flat structure
            renderFlatTree(fileManagerData.treeData, treeView, 0);
        }

        // Render flat tree structure - all nodes in single container
        function renderFlatTree(node, container, depth = 0) {
            // Debug logging
            console.log(`üå≥ Rendering node ${node.id} at depth ${depth}`);
            
            // Render current node
            renderFlatNode(node, container, depth);
            
            // If node is expanded and has children, render them
            const isExpanded = fileManagerData.expandedNodes.has(node.id);
            console.log(`üîç Node ${node.id} - expanded: ${isExpanded}, hasChildren: ${node.children && node.children.length > 0}, childrenCount: ${node.children ? node.children.length : 0}`);
            
            if (isExpanded && node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    console.log(`üë∂ Rendering child ${child.id} at depth ${depth + 1}`);
                    renderFlatTree(child, container, depth + 1);
                });
            }
        }

        // Render individual flat tree node
        function renderFlatNode(node, container, depth = 0) {
            const nodeElement = document.createElement('div');
            nodeElement.className = 'tree-node flat-tree-node';
            nodeElement.style.marginRight = `${depth * 1.5}rem`;
            nodeElement.setAttribute('data-node-id', node.id);
            nodeElement.setAttribute('data-depth', depth);
            
            // Dynamic color generation for very deep levels (26+)
            if (depth >= 26) {
                const intensity = Math.max(0.001, 0.02 - (depth - 26) * 0.001);
                const borderIntensity = Math.max(0.01, 0.1 - (depth - 26) * 0.002);
                const shadowIntensity = Math.max(0.005, 0.05 - (depth - 26) * 0.001);
                
                nodeElement.style.background = `linear-gradient(135deg, rgba(0, 34, 0, ${intensity}), rgba(0, 34, 0, ${intensity * 0.5}))`;
                nodeElement.style.border = `2px solid rgba(0, 34, 0, ${borderIntensity})`;
                nodeElement.style.boxShadow = `0 1px 1px rgba(0, 34, 0, ${shadowIntensity})`;
            }
            
            const isExpanded = fileManagerData.expandedNodes.has(node.id);
            const hasChildren = node.hasChildren || (node.children && node.children.length > 0);
            
            nodeElement.innerHTML = `
                <div class="tree-node-content ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                    ${hasChildren ? `
                        <button class="tree-expand-btn ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                            ${isExpanded ? '‚àí' : '+'}
                        </button>
                    ` : '<div style="width: 14px;"></div>'}
                    

                    <span class="tree-node-label">${node.index}</span>
                    ${!isMobile() ? `<span class="tree-node-info" onclick="copyToClipboard('${node.address}')" title="Click to copy full address">${node.address ? node.address.substring(0, 6) + '...' + node.address.substring(node.address.length - 4) : ''}</span>` : ''}
                </div>
            `;
            
            container.appendChild(nodeElement);
            
            // Add click listeners
            const expandBtn = nodeElement.querySelector('.tree-expand-btn');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNodeExpansion(node.id);
                });
            }
            
            const nodeContent = nodeElement.querySelector('.tree-node-content');
            nodeContent.addEventListener('click', () => {
                selectNode(node);
            });
        }



        // Toggle node expansion for flat structure
        async function toggleNodeExpansion(nodeId) {
            const node = findNodeInTree(fileManagerData.treeData, nodeId);
            if (!node) return;
            
            if (fileManagerData.expandedNodes.has(nodeId)) {
                // Collapsing - remove from expanded set
                fileManagerData.expandedNodes.delete(nodeId);
            } else {
                // Expanding - add to expanded set and load children if needed
                fileManagerData.expandedNodes.add(nodeId);
                
                // Load children if not already loaded
                if (!node.children || node.children.length === 0) {
                    await loadNodeChildren(node, 0);
                }
            }
            
            // Re-render the entire tree
            renderTreeView();
        }

        // Find node in tree structure
        function findNodeInTree(node, nodeId) {
            if (node.id === nodeId) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNodeInTree(child, nodeId);
                    if (found) return found;
                }
            }
            return null;
        }

        // Select node
        function selectNode(node) {
            console.log('üéØ Node selected:', node);
            
            // Update breadcrumb
            fileManagerData.currentPath = ['root', node.index];
            updateBreadcrumb();
            
            // Show node details (could be expanded later)
            showNodeDetails(node);
        }

        // Copy address to clipboard
        function copyToClipboard(text) {
            if (!text) return;
            
            navigator.clipboard.writeText(text).then(() => {
                // Show success message
                const toast = document.createElement('div');
                toast.style.cssText = `
            position: fixed;
            top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #00ff88, #00cc6a);
                    color: #1a202c;
                    padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
                    animation: slideIn 0.3s ease;
                `;
                toast.textContent = 'Address copied to clipboard!';
                document.body.appendChild(toast);
                
                // Remove toast after 3 seconds
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        document.body.removeChild(toast);
                    }, 300);
                }, 3000);
                
            }).catch(err => {
                console.error('Failed to copy address:', err);
                
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                alert('Address copied to clipboard!');
            });
        }

        // Show node details with typewriter effect
        async function showNodeDetails(node) {
            console.log('üìã Node details:', {
                index: node.index,
                address: node.address,
                type: node.type,
                hasChildren: node.hasChildren
            });
            
            if (!node.address) {
                console.log('‚ùå No address available');
                return;
            }
            
            try {
                let user = null;
                let contract = null;
                
                // Try to get contract from different sources
                if (window.contractConfig && window.contractConfig.contract) {
                    contract = window.contractConfig.contract;
                    console.log('‚úÖ Using contractConfig contract');
                } else if (typeof window.connectWallet === 'function') {
                    try {
                        const connection = await window.connectWallet();
                        if (connection && connection.contract) {
                            contract = connection.contract;
                            console.log('‚úÖ Using connectWallet contract');
                        }
                    } catch (error) {
                        console.log('‚ùå connectWallet failed:', error.message);
                    }
                }
                
                if (!contract) {
                    console.log('‚ùå No contract available');
                    return;
                }
                
                // Get user data from contract
                console.log('üîÑ Fetching user data for address:', node.address);
                user = await contract.users(node.address);
                
                console.log('üë§ User data:', user);
                
                // Validate user data
                if (!user || user.index === undefined) {
                    console.log('‚ùå Invalid user data received');
                    return;
                }
                
                // Show mobile user popup with typewriter effect
                if (window.mobileUserPopup) {
                    console.log('üîÑ Showing mobile user popup...');
                    await window.mobileUserPopup.show(node.address, user);
                    console.log('‚úÖ Mobile user popup shown successfully');
                } else {
                    console.log('‚ùå Mobile user popup not available');
                }
                
            } catch (error) {
                console.error('‚ùå Error fetching user data:', error);
                
                // Show error popup
                if (window.mobileUserPopup) {
                    const errorUser = {
                        index: node.index || 0,
                        binaryPoints: 0,
                        binaryPointCap: 0,
                        totalMonthlyRewarded: 0,
                        binaryPointsClaimed: 0,
                        refclimed: 0,
                        depositedAmount: 0,
                        leftPoints: 0,
                        rightPoints: 0
                    };
                    await window.mobileUserPopup.show(node.address, errorUser);
                }
            }
        }

        // Load node children for flat structure
        async function loadNodeChildren(node, depth) {
            try {
                const contract = window.contractConfig.contract;
                const nodeIndex = parseInt(node.index);
                
                // Get left and right children
                const leftAddress = await contract.getLeftAddress(nodeIndex);
                const rightAddress = await contract.getRightAddress(nodeIndex);
                
                const children = [];
                
                // Add left child if exists
                if (leftAddress !== '0x0000000000000000000000000000000000000000') {
                    const leftIndex = (nodeIndex * 2).toString();
                    children.push({
                        id: `node_${leftIndex}`,
                        index: leftIndex,
                        address: leftAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    });
                }
                
                // Add right child if exists
                if (rightAddress !== '0x0000000000000000000000000000000000000000') {
                    const rightIndex = (nodeIndex * 2 + 1).toString();
                    children.push({
                        id: `node_${rightIndex}`,
                        index: rightIndex,
                        address: rightAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    });
                }
                
                // Update node with children
                node.children = children;
                node.hasChildren = children.length > 0;
                
                // Re-render the entire tree to show new children
                renderTreeView();
                
            } catch (error) {
                console.error('‚ùå Error loading node children:', error);
            }
        }





        // Show empty tree state
        function showEmptyTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">üìÅ</div>
                    <div>No tree data available</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #a786ff;">
                        Connect your wallet to load the network tree
                    </div>
                </div>
            `;
        }

        // Show error tree state
        function showErrorTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">‚ùå</div>
                    <div>Error loading tree data</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #ff6b6b;">
                        Please try refreshing the page
                    </div>
                </div>
            `;
        }

        // Render all networks in 4 columns with fast traversal
        async function renderNetworkLists() {
            console.log('üöÄ Starting fast network traversal...');
            
            // Get all network lists
            const network1List = document.getElementById('network-1-list');
            const network2List = document.getElementById('network-2-list');
            const network3List = document.getElementById('network-3-list');
            const network4List = document.getElementById('network-4-list');
            
            if (!network1List || !network2List || !network3List || !network4List) return;
            
            // Clear existing content
            network1List.innerHTML = '';
            network2List.innerHTML = '';
            network3List.innerHTML = '';
            network4List.innerHTML = '';
            
            // Show loading state
            const loadingHtml = '<div style="text-align: center; color: #00ff88; padding: 1rem;">üîÑ Loading network...</div>';
            network1List.innerHTML = loadingHtml;
            network2List.innerHTML = loadingHtml;
            network3List.innerHTML = loadingHtml;
            network4List.innerHTML = loadingHtml;
            
            try {
                // Get all networks using fast traversal
                const allNetworks = await getAllNetworksFast();
                console.log('‚úÖ All networks loaded:', allNetworks);
                
                // Render each network in its column
                renderNetworkInColumn(network1List, allNetworks.network1, 'Network 1', 1);
                renderNetworkInColumn(network2List, allNetworks.network2, 'Network 2', 2);
                renderNetworkInColumn(network3List, allNetworks.network3, 'Network 3', 3);
                renderNetworkInColumn(network4List, allNetworks.network4, 'Network 4', 4);
                
            } catch (error) {
                console.error('‚ùå Error loading networks:', error);
                const errorHtml = '<div style="text-align: center; color: #ff4757; padding: 1rem;">‚ùå Error loading network</div>';
                network1List.innerHTML = errorHtml;
                network2List.innerHTML = errorHtml;
                network3List.innerHTML = errorHtml;
                network4List.innerHTML = errorHtml;
            }
        }

        // Fast traversal to get all networks
        async function getAllNetworksFast() {
            if (!window.contractConfig || !window.contractConfig.contract) {
                throw new Error('Contract not available');
            }

            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('User address not available');
            }

            console.log('üì° Starting fast traversal for user:', userAddress);
            
            // Get user's index
            const userIndex = await window.getIndexByAddress(contract, userAddress);
            console.log('‚úÖ User index:', userIndex.toString());
            
            const allNetworks = {
                network1: [],
                network2: [],
                network3: [],
                network4: []
            };
            
            // Get root children first
            const rootChildren = await getNodeChildrenFast(contract, userIndex);
            console.log('‚úÖ Root children:', rootChildren);
            
            if (rootChildren.length === 0) {
                return allNetworks;
            }
            
            // Process each root child and its descendants
            const promises = [];
            
            if (rootChildren.length > 0) {
                promises.push(traverseNetworkFast(contract, rootChildren[0], allNetworks.network1, 'Network 1'));
            }
            if (rootChildren.length > 1) {
                promises.push(traverseNetworkFast(contract, rootChildren[1], allNetworks.network2, 'Network 2'));
            }
            if (rootChildren.length > 2) {
                promises.push(traverseNetworkFast(contract, rootChildren[2], allNetworks.network3, 'Network 3'));
            }
            if (rootChildren.length > 3) {
                promises.push(traverseNetworkFast(contract, rootChildren[3], allNetworks.network4, 'Network 4'));
            }
            
            // Wait for all networks to be traversed
            await Promise.all(promises);
            
            console.log('‚úÖ Fast traversal completed:', allNetworks);
            return allNetworks;
        }

        // Fast traversal for a single network
        async function traverseNetworkFast(contract, rootIndex, networkArray, networkName) {
            console.log(`üîÑ Traversing ${networkName} starting from index:`, rootIndex.toString());
            
            const queue = [rootIndex];
            const visited = new Set();
            let maxDepth = 0;
            // No node limit - render unlimited tree
            
            while (queue.length > 0) {
                const currentIndex = queue.shift();
                
                if (visited.has(currentIndex.toString())) continue;
                visited.add(currentIndex.toString());
                
                // Add current node to network
                networkArray.push({
                    index: currentIndex.toString(),
                    depth: maxDepth,
                    expanded: false,
                    children: []
                });
                
                // Get children for current node
                try {
                    const children = await getNodeChildrenFast(contract, currentIndex);
                    
                    if (children && children.length > 0) {
                        // Add children to queue for next level
                        queue.push(...children);
                        maxDepth++;
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Could not get children for index ${currentIndex}:`, error);
                    // Continue with next node
                }
                
                // Small delay to prevent overwhelming the contract
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            console.log(`‚úÖ ${networkName} traversal completed: ${networkArray.length} nodes`);
        }

        // Fast method to get node children
        async function getNodeChildrenFast(contract, nodeIndex) {
            try {
                // Convert index to address
                const nodeAddress = await window.getAddressByIndex(contract, nodeIndex);
                if (!nodeAddress || nodeAddress === '0x0000000000000000000000000000000000000000') {
                    return [];
                }
                
                // Get user tree
                const userTree = await contract.getUserTree(nodeAddress);
                const leftAddress = userTree[0];
                const rightAddress = userTree[1];
                const activated = userTree[2];
                
                const children = [];
                
                if (activated) {
                    if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                        const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                        if (leftIndex && leftIndex > 0n) {
                            children.push(leftIndex);
                        }
                    }
                    
                    if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                        const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                        if (rightIndex && rightIndex > 0n) {
                            children.push(rightIndex);
                        }
                    }
                }
                
                return children;
            } catch (error) {
                console.warn(`‚ö†Ô∏è Error getting children for index ${nodeIndex}:`, error);
                return [];
            }
        }

        // Render network in a specific column
        function renderNetworkInColumn(container, networkData, networkName, networkNumber) {
            console.log(`üîÑ Rendering ${networkName}:`, networkData.length, 'nodes');
            
            if (networkData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #a0aec0; padding: 2rem;">No data available</div>';
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Add network stats
            const statsDiv = document.createElement('div');
            statsDiv.style.cssText = `
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                padding: 0.5rem;
                margin-bottom: 1rem;
                text-align: center;
                font-size: 0.9em;
                color: #00ff88;
            `;
            statsDiv.innerHTML = `üìä ${networkData.length} nodes found`;
            container.appendChild(statsDiv);
            
            // Render all nodes in the network
            networkData.forEach((node, index) => {
                const networkItem = createNetworkItem(node, networkName, networkNumber);
                container.appendChild(networkItem);
            });
            
            // Add expand button for manual expansion if needed
            const expandButton = document.createElement('button');
            expandButton.style.cssText = `
                width: 100%;
                background: linear-gradient(45deg, #00ff88, #00cc6a);
                color: #1a202c;
            border: none;
                padding: 0.5rem;
                border-radius: 6px;
                font-weight: 600;
            cursor: pointer;
                            margin-top: 1rem;
                transition: all 0.3s ease;
            `;
            expandButton.innerHTML = 'üîÑ Expand More';
            expandButton.onclick = () => expandNetworkManually(networkNumber, networkData);
            container.appendChild(expandButton);
        }

        // Manual expansion for a network
        async function expandNetworkManually(networkNumber, currentNetworkData) {
            console.log(`üîÑ Manual expansion for Network ${networkNumber}`);
            
            const container = document.getElementById(`network-${networkNumber}-list`);
            if (!container) return;
            
            // Show loading
            const expandButton = container.querySelector('button');
            if (expandButton) {
                expandButton.innerHTML = 'üîÑ Expanding...';
                expandButton.disabled = true;
            }
            
            try {
                // Get more nodes for this network
                const newNodes = await getMoreNodesForNetwork(networkNumber, currentNetworkData);
                
                if (newNodes.length > 0) {
                    // Add new nodes to the network
                    newNodes.forEach(node => {
                        const networkItem = createNetworkItem(node, `Network ${networkNumber}`, networkNumber);
                        container.insertBefore(networkItem, expandButton);
                    });
                    
                    // Update stats
                    const statsDiv = container.querySelector('div');
                    if (statsDiv) {
                        const totalNodes = currentNetworkData.length + newNodes.length;
                        statsDiv.innerHTML = `üìä ${totalNodes} nodes found`;
                    }
                }
                
            } catch (error) {
                console.error(`‚ùå Error expanding Network ${networkNumber}:`, error);
            } finally {
                // Reset button
                if (expandButton) {
                    expandButton.innerHTML = 'üîÑ Expand More';
                    expandButton.disabled = false;
                }
            }
        }

        // Get more nodes for a specific network
        async function getMoreNodesForNetwork(networkNumber, currentNetworkData) {
            // This is a simplified version - in reality, you'd implement more sophisticated expansion logic
            const newNodes = [];
            
            // For now, just return some dummy data or implement based on your specific needs
            console.log(`üì° Getting more nodes for Network ${networkNumber}`);
            
            return newNodes;
        }

        // Create a network item for the list
        function createNetworkItem(node, networkName, networkNumber) {
            const networkItem = document.createElement('div');
            networkItem.className = 'network-item';
            
            // Determine odd/even for styling
            const nodeIndex = parseInt(node.index);
            networkItem.classList.add(nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create expand button (for manual expansion)
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            expandBtn.textContent = '‚ñ∂';
            expandBtn.onclick = () => expandNodeManually(node, networkNumber);
            
            // Create index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            // Create depth indicator
            const depthIndicator = document.createElement('span');
            depthIndicator.style.cssText = `
                font-size: 0.7em;
                color: #a0aec0;
                margin-left: 0.5rem;
                background: rgba(0, 0, 0, 0.3);
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
            `;
            depthIndicator.textContent = `D${node.depth || 0}`;
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            buttonContainer.appendChild(depthIndicator);
            
            networkItem.appendChild(buttonContainer);
            
            return networkItem;
        }

        // Manual expansion for a specific node
        async function expandNodeManually(node, networkNumber) {
            console.log(`üîÑ Manual expansion for node ${node.index} in Network ${networkNumber}`);
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    throw new Error('Contract not available');
                }

                const contract = window.contractConfig.contract;
                
                // Get children for this node
                const children = await getNodeChildrenFast(contract, BigInt(node.index));
                
                if (children && children.length > 0) {
                    // Add children to the network
                    const container = document.getElementById(`network-${networkNumber}-list`);
                            if (container) {
                        children.forEach((childIndex, index) => {
                            const childNode = {
                                index: childIndex.toString(),
                                depth: (node.depth || 0) + 1,
                                expanded: false,
                                children: []
                            };
                            
                            const childItem = createNetworkItem(childNode, `Network ${networkNumber}`, networkNumber);
                            
                            // Insert after the current node
                            const currentItem = container.querySelector(`[data-node-index="${node.index}"]`);
                            if (currentItem) {
                                currentItem.insertAdjacentElement('afterend', childItem);
                            } else {
                                container.appendChild(childItem);
                            }
                        });
                            }
                        }
                        
                    } catch (error) {
                console.error(`‚ùå Error expanding node ${node.index}:`, error);
            }
        }





        // Load real data and render tree
        async function loadRealDataAndRender() {
            try {
                console.log('üîÑ Loading real wallet data...');
                

                
                // Check if wallet is connected
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è Wallet not connected, using default data');
                    renderPyramidTree();
                    return;
                }
                
                // Get real wallet data
                const realData = await getRealWalletData();
                if (realData) {
                    console.log('‚úÖ Real data loaded, rendering tree...');
                    
                    // Update button state after successful data load
                    const connectBtn = document.getElementById('connect-wallet-btn');
                    if (connectBtn && window.contractConfig && window.contractConfig.userAddress) {
                        const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                        connectBtn.className = 'connect-wallet-btn modern-btn connected';
                        connectBtn.textContent = `‚úÖ ${shortAddress}`;
                    }
                    
                    renderPyramidTree();
                } else {
                    console.log('‚ö†Ô∏è Could not load real data, using default data');
                    
                    // Update button state for failed data load
                    const connectBtn = document.getElementById('connect-wallet-btn');
                    if (connectBtn) {
                        connectBtn.className = 'connect-wallet-btn modern-btn error';
                        connectBtn.textContent = '‚ö†Ô∏è Data Load Failed';
                        setTimeout(() => {
                            if (window.contractConfig && window.contractConfig.userAddress) {
                                const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                                connectBtn.className = 'connect-wallet-btn modern-btn connected';
                                connectBtn.textContent = `‚úÖ ${shortAddress}`;
                            } else {
                                connectBtn.className = 'connect-wallet-btn modern-btn';
                                connectBtn.textContent = 'üîó Connect Wallet';
                            }
                        }, 3000);
                    }
                    
                    renderPyramidTree();
                }

            } catch (error) {
                console.error('‚ùå Error loading real data:', error);
                console.log('‚ö†Ô∏è Using default data');
                renderPyramidTree();
            }
        }
        
        // Simple connect wallet function
        async function simpleConnectWallet() {
            try {
                console.log('üîó Simple wallet connection...');
                
                // Check if MetaMask is available
                if (!window.ethereum) {
                    console.log('‚ùå MetaMask not detected');
                    alert('Please install MetaMask to connect your wallet');
                    return false;
                }
                
                // Request account access
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts && accounts.length > 0) {
                    console.log('‚úÖ Wallet connected:', accounts[0]);
                    
                    // Set up contract config
                    if (!window.contractConfig) {
                        window.contractConfig = {};
                    }
                    window.contractConfig.userAddress = accounts[0];
                    
                    // Try to create contract if we have the address and ABI
                    if (window.IAM_ADDRESS && window.IAM_ABI) {
                        try {
                            const provider = new ethers.BrowserProvider(window.ethereum);
                            const signer = await provider.getSigner();
                            window.contractConfig.contract = new ethers.Contract(
                                window.IAM_ADDRESS,
                                window.IAM_ABI,
                                signer
                            );
                            window.contractConfig.contractAddress = window.IAM_ADDRESS;
                            window.contractConfig.contractABI = window.IAM_ABI;
                            console.log('‚úÖ Contract created successfully');
                        } catch (contractError) {
                            console.log('‚ö†Ô∏è Contract creation failed:', contractError.message);
                        }
                    } else {
                        console.log('‚ö†Ô∏è IAM_ADDRESS or IAM_ABI not available, using fallback');
                        // Use fallback contract address if available
                        const fallbackAddress = '0x63F5a2085906f5fcC206d6589d78038FBc74d2FE'; // IAM contract address
                        if (fallbackAddress && (window.IAM_ABI || window.CONTRACT_ABI)) {
                            try {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                const abi = window.IAM_ABI || window.CONTRACT_ABI;
                                window.contractConfig.contract = new ethers.Contract(
                                    fallbackAddress,
                                    abi,
                                    signer
                                );
                                window.contractConfig.contractAddress = fallbackAddress;
                                window.contractConfig.contractABI = abi;
                                console.log('‚úÖ Fallback contract created successfully');
                            } catch (contractError) {
                                console.log('‚ö†Ô∏è Fallback contract creation failed:', contractError.message);
                            }
                        }
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå No accounts returned');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                if (error.code === 4001) {
                    console.log('üë§ User rejected connection');
                }
                return false;
            }
        }

        // Connect wallet button functionality
        function setupConnectWalletButton() {
            const connectBtn = document.getElementById('connect-wallet-btn');
            if (!connectBtn) {
                console.log('‚ùå Connect wallet button not found');
                return;
            }
            
            console.log('‚úÖ Connect wallet button found, setting up...');
            
            // Update button state
            function updateButtonState(state, text) {
                connectBtn.className = `connect-wallet-btn modern-btn ${state}`;
                connectBtn.textContent = text;
            }
            
            // Check initial connection state
            function checkConnectionState() {
                if (window.contractConfig && window.contractConfig.userAddress) {
                    const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                    updateButtonState('connected', `‚úÖ ${shortAddress}`);
                } else if (window.ethereum && window.ethereum.selectedAddress) {
                    const shortAddress = window.ethereum.selectedAddress.slice(0, 6) + '...' + window.ethereum.selectedAddress.slice(-4);
                    updateButtonState('connected', `‚úÖ ${shortAddress}`);
                } else {
                    updateButtonState('', 'üîó Connect Wallet');
                }
            }
            
            // Update button state during auto-connection
            function updateButtonForAutoConnection() {
                updateButtonState('connecting', 'üîÑ Auto-Connecting...');
            }
            
            // Connect wallet function
            async function connectWallet() {
                try {
                    console.log('üîÑ Connect wallet button clicked');
                    updateButtonState('connecting', 'üîÑ Connecting...');
                    
                    const success = await simpleConnectWallet();
                    
                    if (success) {
                        checkConnectionState();
                        console.log('‚úÖ Wallet connected successfully via button');
                        
                        // Try to render the tree with real data
                        try {
                            renderPyramidTree();
                        } catch (renderError) {
                            console.log('‚ö†Ô∏è Tree render failed:', renderError.message);
                        }
                    } else {
                        updateButtonState('error', '‚ùå Connection Failed');
                        setTimeout(() => {
                            checkConnectionState();
                        }, 3000);
                    }
                } catch (error) {
                    console.error('‚ùå Error connecting wallet:', error);
                    updateButtonState('error', '‚ùå Error');
                    setTimeout(() => {
                        checkConnectionState();
                    }, 3000);
                }
            }
            
            // Add click event listener
            connectBtn.addEventListener('click', connectWallet);
            console.log('‚úÖ Click event listener added');
            
            // Check connection state on load
            checkConnectionState();
            
            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    console.log('üîÑ Account changed, updating button state');
                    checkConnectionState();
                });
                
                window.ethereum.on('chainChanged', () => {
                    console.log('üîÑ Chain changed, updating button state');
                    checkConnectionState();
                });
            }
        }
        
        // Show auto-connection status
        function showAutoConnectionStatus() {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'auto-connection-status';
            statusDiv.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: rgba(0, 255, 136, 0.1);
                border: 1px solid rgba(0, 255, 136, 0.3);
                border-radius: 8px;
                padding: 10px 15px;
                color: #00ff88;
                font-size: 12px;
                z-index: 999;
                backdrop-filter: blur(10px);
                max-width: 200px;
            `;
            statusDiv.textContent = 'üîÑ Auto-connecting to wallet...';
            document.body.appendChild(statusDiv);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Pyramid Tree page loaded');
            
            // Show auto-connection status
            showAutoConnectionStatus();
            
            // Debug wallet connection
            console.log('üîç Debug Wallet Connection:');
            console.log('- window.ethereum:', !!window.ethereum);
            console.log('- window.IAM_ADDRESS:', window.IAM_ADDRESS);
            console.log('- window.IAM_ABI:', !!window.IAM_ABI);
            console.log('- window.contractConfig:', !!window.contractConfig);
            console.log('- window.connectWallet:', !!window.connectWallet);
            
            // Setup connect wallet button
            setupConnectWalletButton();
            
            // Test function for debugging
            window.testConnectWallet = async function() {
                console.log('üß™ Testing connect wallet...');
                const result = await simpleConnectWallet();
                console.log('üß™ Test result:', result);
                return result;
            };
            
            // Make functions globally available for debugging
            window.simpleConnectWallet = simpleConnectWallet;
            window.setupConnectWalletButton = setupConnectWalletButton;
            
            // Wait for scripts to load and try multiple times
            let attempts = 0;
            const maxAttempts = 5;
            
            const tryConnectWallet = async () => {
                attempts++;
                console.log(`üîÑ Attempt ${attempts}/${maxAttempts} to auto-connect wallet...`);
                
                try {
                    // Check if MetaMask is available
                    if (!window.ethereum) {
                        if (attempts < maxAttempts) {
                            console.log('‚è≥ MetaMask not detected, waiting...');
                            setTimeout(tryConnectWallet, 1000);
                            return;
                        } else {
                            console.log('‚ùå MetaMask not available after max attempts');
                            renderPyramidTree();
                            return;
                        }
                    }
                    
                    // Check if already connected
                    if (window.ethereum.selectedAddress) {
                        console.log('‚úÖ Wallet already connected:', window.ethereum.selectedAddress);
                        
                        // Set up contract config
                        if (!window.contractConfig) {
                            window.contractConfig = {};
                        }
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        
                        // Try to create contract
                        if (window.IAM_ADDRESS && (window.IAM_ABI || window.CONTRACT_ABI)) {
                            try {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                const abi = window.IAM_ABI || window.CONTRACT_ABI;
                                window.contractConfig.contract = new ethers.Contract(
                                    window.IAM_ADDRESS,
                                    abi,
                                    signer
                                );
                                window.contractConfig.contractAddress = window.IAM_ADDRESS;
                                window.contractConfig.contractABI = abi;
                                console.log('‚úÖ Contract created for auto-connection');
                            } catch (contractError) {
                                console.log('‚ö†Ô∏è Contract creation failed:', contractError.message);
                            }
                        }
                        
                        console.log('‚úÖ Auto-connection successful, loading real data...');
                        
                        // Update button state
                        if (connectBtn) {
                            const shortAddress = window.ethereum.selectedAddress.slice(0, 6) + '...' + window.ethereum.selectedAddress.slice(-4);
                            connectBtn.className = 'connect-wallet-btn modern-btn connected';
                            connectBtn.textContent = `‚úÖ ${shortAddress}`;
                        }
                        
                        await loadRealDataAndRender();
                        return;
                    }
                    
                    // Try to connect using simple method
                    const walletConnected = await simpleConnectWallet();
                    
                    if (walletConnected) {
                        console.log('‚úÖ Auto-connection successful, loading real data...');
                        
                        // Update button state
                        if (connectBtn && window.contractConfig && window.contractConfig.userAddress) {
                            const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                            connectBtn.className = 'connect-wallet-btn modern-btn connected';
                            connectBtn.textContent = `‚úÖ ${shortAddress}`;
                        }
                        
                        await loadRealDataAndRender();
                    } else {
                        console.log('‚ö†Ô∏è Auto-connection failed, showing default data');
                        
                        // Update button state
                        if (connectBtn) {
                            connectBtn.className = 'connect-wallet-btn modern-btn';
                            connectBtn.textContent = 'üîó Connect Wallet';
                        }
                        
                        renderPyramidTree();
                    }
            } catch (error) {
                    console.error(`‚ùå Error in auto-connection attempt ${attempts}:`, error);
                    if (attempts < maxAttempts) {
                        setTimeout(tryConnectWallet, 1000);
                    } else {
                        console.log('‚ùå Max auto-connection attempts reached, showing default data');
                        renderPyramidTree();
                    }
                }
            };
            
            // Debug MetaMask detection
            console.log('üîç Debug MetaMask Detection:');
            console.log('- window.ethereum:', !!window.ethereum);
            console.log('- window.web3:', !!window.web3);
            console.log('- window.web3.currentProvider:', !!window.web3?.currentProvider);
            console.log('- isMobile():', isMobile());
            console.log('- User Agent:', navigator.userAgent);
            console.log('- Screen width:', window.innerWidth);
            
            // Update button state for auto-connection
            const connectBtn = document.getElementById('connect-wallet-btn');
            if (connectBtn) {
                connectBtn.className = 'connect-wallet-btn modern-btn connecting';
                connectBtn.textContent = 'üîÑ Auto-Connecting...';
            }
            
            // Start trying to connect
            setTimeout(tryConnectWallet, 200);
            
            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', async (accounts) => {
                    console.log('üîÑ Account changed:', accounts);
                    if (accounts && accounts.length > 0) {
                        if (window.contractConfig) {
                            window.contractConfig.userAddress = accounts[0];
                        }
                        await loadRealDataAndRender();
                    } else {
                        renderPyramidTree();
                    }
                });
                
                window.ethereum.on('chainChanged', () => {
                    console.log('üîÑ Chain changed, reloading...');
                    window.location.reload();
                });
            }
        });
    </script>
    
    <!-- Floating Token Growth Card -->
    <script src="js/floating-token-card.js"></script>
    
    <!-- Mobile User Popup -->
    <script>
        // Check if mobile-user-popup is already loaded
        if (!window.mobileUserPopup) {
            // Load the script dynamically to avoid duplicate loading
            const script = document.createElement('script');
            script.src = 'js/mobile-user-popup.js';
            script.onload = function() {
                console.log('‚úÖ Mobile user popup loaded successfully');
            };
            script.onerror = function() {
                console.warn('‚ö†Ô∏è Failed to load mobile user popup');
            };
            document.head.appendChild(script);
        } else {
            console.log('‚úÖ Mobile user popup already loaded');
        }
    </script>
</body>
</html> 