<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Network Tree - IAM</title>
    
    <!-- Error handling for extension connections -->
    <script>
        // Suppress extension connection errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Suppress unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            if (e.reason && e.reason.message && e.reason.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/mobile-responsive.css">
    <link rel="stylesheet" href="css/mobile-user-popup.css">
    <link rel="stylesheet" href="css/pyramid-tree.css">
    
    <!-- Load ethers.js -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
</head>
<body>
    <!-- Back Button -->
    <a href="index.html" class="back-btn">
        ‚Üê Back to Dashboard
    </a>
    
    <div id="main-network" class="page-section expandable-container" style="width:100vw;max-width:none;margin:0;left:0;right:0;padding:0.5rem 0;">
        <div class="expand-header">
            <h2 style="color: #00ff88; margin: 0;">üåê Network</h2>
        </div>
        <div class="expand-content">
            <div class="network-container" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
                <!-- Network Stats -->
                <div id="network-stats" class="network-user-info-container"></div>
                
                <!-- Wallet Connection Status -->
                <div id="wallet-status" style="margin-bottom: 1rem; text-align: center;">
                    <div id="wallet-info" style="color: #00ccff; font-size: 0.9em;">
                        üîÑ Connecting to wallet...
                    </div>
                </div>
                
                <!-- Pyramid Tree Display -->
                <div id="pyramid-tree">
                    <div id="tree-display" class="pyramid-container">
                        <!-- Tree will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/config.js"></script>
    <script src="js/walletconnect-handler.js"></script>
            <script src="js/network.js?v=20250809-36"></script>
    <script src="js/navbar.js"></script>
    <script src="js/token-balances.js"></script>
    <script src="js/tree-events.js"></script>
    
    <script>
        // Pyramid Tree Data
        let pyramidData = {
            root: {
                id: 1,
                index: 'Connected Wallet',
                expanded: false,
                children: [
                    { id: 2, index: '2', expanded: false, children: [] },
                    { id: 3, index: '3', expanded: false, children: [] }
                ]
            }
        };

        // Connect to wallet and get real data
        async function connectWalletAndLoadData() {
            try {
                console.log('üîó Connecting to wallet...');
                
                // Check if wallet is already connected
                if (window.contractConfig && window.contractConfig.contract) {
                    console.log('‚úÖ Wallet already connected');
                    
                    // Ensure userAddress is set
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set from provider:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                }
                
                // Try to connect wallet
                if (window.connectWallet) {
                    await window.connectWallet();
                    console.log('‚úÖ Wallet connected successfully');
                    
                    // Ensure userAddress is set after connection
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set after connection:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå connectWallet function not available');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                return false;
            }
        }

        // Get real wallet data
        async function getRealWalletData() {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available');
                    return null;
                }

                const contract = window.contractConfig.contract;
                const userAddress = window.contractConfig.userAddress;
                
                if (!userAddress) {
                    console.log('‚ùå User address not available, trying to get from provider...');
                    // Try to get address from provider
                    if (window.ethereum && window.ethereum.selectedAddress) {
                        const providerAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ Got address from provider:', providerAddress);
                        window.contractConfig.userAddress = providerAddress;
                    } else {
                        console.log('‚ùå No address available from provider either');
                        return null;
                    }
                }

                console.log('üì° Fetching real wallet data...');
                
                // Use the updated userAddress
                const currentUserAddress = window.contractConfig.userAddress;
                console.log('üìç Using address:', currentUserAddress);
                
                // Get user's index (IAM ID)
                const userIndex = await window.getIndexByAddress(contract, currentUserAddress);
                console.log('‚úÖ User Index:', userIndex.toString());
                
                if (!userIndex || userIndex === 0n) {
                    console.log('‚ùå User not registered');
                    return null;
                }
                
                // Get user's children using getUserTree
                let children = [];
                try {
                    const userTree = await contract.getUserTree(currentUserAddress);
                    console.log('‚úÖ User tree data:', userTree);
                    
                    // userTree returns [leftAddress, rightAddress, activated, ...]
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                    } catch (error) {
                    console.log('‚ö†Ô∏è getUserTree failed, trying getLeftChild/getRightChild...');
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(userIndex);
                        const rightChildIndex = await contract.getRightChild(userIndex);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log('‚ö†Ô∏è getLeftChild/getRightChild also failed, using empty children');
                        children = [];
                    }
                }
                console.log('‚úÖ User children indices:', children);
                
                // Update pyramid data with real data
                pyramidData.root.index = userIndex.toString();
                
                if (children && children.length > 0) {
                    pyramidData.root.children = children.map((child, index) => ({
                        id: index + 2,
                        index: child.toString(),
                        expanded: false,
                        children: []
                    }));
                }
                
                console.log('‚úÖ Real wallet data loaded:', pyramidData);
                return pyramidData;

            } catch (error) {
                console.error('‚ùå Error fetching real wallet data:', error);
                return null;
            }
        }

                // Create pyramid node - Only render direct children (lazy loading)
        function createPyramidNode(node, level = 0) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'pyramid-node';
            nodeDiv.style.marginLeft = `${level * 20}px`;
            
            // Set data-index for color determination (odd/even)
            const nodeIndex = parseInt(node.index);
            nodeDiv.setAttribute('data-index', nodeIndex);
            nodeDiv.setAttribute('data-odd-even', nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            
            // Set data-index-length based on index length
            const indexLength = node.index.toString().length;
            buttonContainer.setAttribute('data-index-length', indexLength);
            
            // Expand button
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            
            // Always set normal state (loading is handled in toggleNode)
            expandBtn.setAttribute('data-loading', 'false');
            expandBtn.textContent = node.expanded ? '‚ñº' : '‚ñ∂';
            
            expandBtn.onclick = () => toggleNode(node.id);
            
            // Index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            nodeDiv.appendChild(buttonContainer);
            
            // Children container - Only render direct children (lazy loading)
            if (node.children && node.children.length > 0 && node.expanded) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                childrenContainer.style.display = 'block';
                
                // Only render direct children - grandchildren will be loaded when their parent is expanded
                node.children.forEach(child => {
                    const childNode = createPyramidNode(child, level + 1);
                    childrenContainer.appendChild(childNode);
                });
                
                nodeDiv.appendChild(childrenContainer);
            }
            
            return nodeDiv;
        }

        // Toggle node expansion
        async function toggleNode(nodeId) {
            const node = findNode(pyramidData.root, nodeId);
            if (node) {
                // Find the expand button for this node
                const expandBtn = document.querySelector(`[onclick="toggleNode(${nodeId})"]`);
                
                // If expanding and no children loaded yet, show loading
                if (!node.expanded && (!node.children || node.children.length === 0)) {
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'true');
                        expandBtn.innerHTML = '<div class="loading-spinner"></div>';
                    }
                    
                    // Load children (only direct children - lazy loading)
                    await loadNodeChildren(node);
                    
                    // Hide loading for parent
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                    }
                    
                    // Don't set loading state for children - only the clicked button shows loading
                } else if (!node.expanded && node.children && node.children.length > 0) {
                    // If children already exist but node is collapsed, just expand
                    // No need to load children again
                } else if (node.expanded) {
                    // If collapsing, reset loading state for all children
                    resetChildrenLoading(node);
                }
                
                node.expanded = !node.expanded;
                renderPyramidTree();
            }
        }

        // Load children for a specific node - Only direct children (lazy loading)
        async function loadNodeChildren(node) {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available for loading children');
                    // Reset loading state on error
                    const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                        expandBtn.textContent = '‚ñ∂';
                    }
                    return;
                }

                const contract = window.contractConfig.contract;
                
                // Use node index directly (no IAM prefix)
                const iamId = node.index;
                console.log(`üì° Loading children for IAM ID: ${iamId}`);
                
                // Get children from contract using correct methods
                let children = [];
                try {
                    // Convert IAM ID to address first
                    const childAddress = await window.getAddressByIndex(contract, iamId);
                    if (!childAddress || childAddress === '0x0000000000000000000000000000000000000000') {
                        console.log(`‚ö†Ô∏è No address found for IAM ID ${iamId}`);
                        return;
                    }
                    
                    // Get user tree for this child
                    const userTree = await contract.getUserTree(childAddress);
                    console.log(`‚úÖ User tree for ${node.index}:`, userTree);
                    
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è getUserTree failed for ${iamId}, trying getLeftChild/getRightChild...`);
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(iamId);
                        const rightChildIndex = await contract.getRightChild(iamId);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log(`‚ö†Ô∏è getLeftChild/getRightChild also failed for ${iamId}`);
                        children = [];
                    }
                }
                console.log(`‚úÖ Children indices for ${node.index}:`, children);
                
                if (children && children.length > 0) {
                    node.children = children.map((child, index) => ({
                        id: node.id * 10 + index + 1,
                        index: child.toString(),
                        expanded: false,
                        children: [], // Will be loaded when this child is expanded
                        loading: false // Children don't have loading state
                    }));
                    
                    console.log(`‚úÖ Created ${node.children.length} children for node ${node.index}`);
                } else {
                    console.log(`‚ö†Ô∏è No children found for node ${node.index}`);
                }
                
            } catch (error) {
                console.error(`‚ùå Error loading children for ${node.index}:`, error);
                // Reset loading state on error
                const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                if (expandBtn) {
                    expandBtn.setAttribute('data-loading', 'false');
                    expandBtn.textContent = '‚ñ∂';
                }
                // No need to reset children loading state since they don't have it
            }
        }

        // Reset loading state for all children of a node (simplified)
        function resetChildrenLoading(node) {
            // No longer needed since children don't have loading state
            // Only the clicked button shows loading
        }

        // Show user popup for a specific node
        async function showUserPopup(node) {
            try {
                if (!window.mobileUserPopup) {
                    console.log('‚ùå Mobile user popup not available');
                    return;
                }

                console.log('üîÑ Showing user popup for node:', node.index);

                // Get user address by index
                let userAddress = null;
                if (window.contractConfig && window.contractConfig.contract) {
                    try {
                        userAddress = await window.getAddressByIndex(window.contractConfig.contract, node.index);
                        console.log('‚úÖ User address found:', userAddress);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get address for index:', node.index, error);
                    }
                }

                // Get user data
                let userData = null;
                if (userAddress && window.contractConfig && window.contractConfig.contract) {
                    try {
                        userData = await window.contractConfig.contract.getUserByAddress(userAddress);
                        console.log('‚úÖ User data found:', userData);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get user data for address:', userAddress, error);
                    }
                }

                // Create user object for popup
                const user = {
                    index: node.index,
                    binaryPoints: userData ? userData.binaryPoints : 0,
                    binaryPointCap: userData ? userData.binaryPointCap : 0,
                    totalMonthlyRewarded: userData ? userData.totalMonthlyRewarded : 0,
                    binaryPointsClaimed: userData ? userData.binaryPointsClaimed : 0,
                    refclimed: userData ? userData.refclimed : '0',
                    depositedAmount: userData ? userData.depositedAmount : '0',
                    leftPoints: userData ? userData.leftPoints : 0,
                    rightPoints: userData ? userData.rightPoints : 0
                };

                // Show popup
                window.mobileUserPopup.show(userAddress, user);

            } catch (error) {
                console.error('‚ùå Error showing user popup:', error);
                
                // Show popup with minimal data if there's an error
                const fallbackUser = {
                    index: node.index,
                    binaryPoints: 0,
                    binaryPointCap: 0,
                    totalMonthlyRewarded: 0,
                    binaryPointsClaimed: 0,
                    refclimed: '0',
                    depositedAmount: '0',
                    leftPoints: 0,
                    rightPoints: 0
                };
                
                if (window.mobileUserPopup) {
                    window.mobileUserPopup.show(null, fallbackUser);
                }
            }
        }

        // Find node by ID - Recursive search through all loaded nodes
        function findNode(node, id) {
            if (node.id === id) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNode(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render pyramid tree
        function renderPyramidTree() {
            const treeDisplay = document.getElementById('tree-display');
            if (!treeDisplay) return;
            
            treeDisplay.innerHTML = '';
            treeDisplay.appendChild(createPyramidNode(pyramidData.root));
        }



        // Update wallet status
        function updateWalletStatus() {
            const walletInfo = document.getElementById('wallet-info');
            
            if (window.contractConfig && window.contractConfig.userAddress) {
                const userAddress = window.contractConfig.userAddress;
                if (userAddress) {
                    walletInfo.innerHTML = `‚úÖ Connected: ${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
                } else {
                    walletInfo.innerHTML = '‚úÖ Connected: Wallet Address Not Available';
                }
            } else {
                walletInfo.innerHTML = '‚ùå Wallet not connected';
            }
        }

        // Load real data and render tree
        async function loadRealDataAndRender() {
            try {
                console.log('üîÑ Loading real wallet data...');
                
                // Update wallet status
                updateWalletStatus();
                
                // Check if wallet is connected
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è Wallet not connected, using default data');
                    renderPyramidTree();
                    return;
                }
                
                // Get real wallet data
                const realData = await getRealWalletData();
                if (realData) {
                    console.log('‚úÖ Real data loaded, rendering tree...');
                    renderPyramidTree();
                } else {
                    console.log('‚ö†Ô∏è Could not load real data, using default data');
                    renderPyramidTree();
                }
                
            } catch (error) {
                console.error('‚ùå Error loading real data:', error);
                console.log('‚ö†Ô∏è Using default data');
                updateWalletStatus();
                renderPyramidTree();
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Pyramid Tree page loaded');
            
            // Wait a bit for other scripts to load
            setTimeout(async () => {
                try {
                    // Try to connect wallet automatically
                    console.log('üîÑ Attempting to connect wallet automatically...');
                    const walletConnected = await connectWalletAndLoadData();
                    
                    if (walletConnected) {
                        console.log('‚úÖ Wallet connected automatically, loading real data...');
                        await loadRealDataAndRender();
                    } else {
                        console.log('‚ö†Ô∏è Could not connect wallet automatically, showing default data');
                        updateWalletStatus();
                        renderPyramidTree();
                    }
                } catch (error) {
                    console.error('‚ùå Error in automatic wallet connection:', error);
                    updateWalletStatus();
                    renderPyramidTree();
                }
            }, 1000);
        });
    </script>
    
    <!-- Floating Token Growth Card -->
    <script src="js/floating-token-card.js"></script>
    
    <!-- Mobile User Popup -->
    <script>
        // Check if mobile-user-popup is already loaded
        if (!window.mobileUserPopup) {
            // Load the script dynamically to avoid duplicate loading
            const script = document.createElement('script');
            script.src = 'js/mobile-user-popup.js';
            script.onload = function() {
                console.log('‚úÖ Mobile user popup loaded successfully');
            };
            script.onerror = function() {
                console.warn('‚ö†Ô∏è Failed to load mobile user popup');
            };
            document.head.appendChild(script);
        } else {
            console.log('‚úÖ Mobile user popup already loaded');
        }
    </script>
</body>
</html> 