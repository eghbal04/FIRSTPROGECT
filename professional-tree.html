<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Network Tree - IAM</title>
    
    <!-- Error handling for extension connections -->
    <script>
        // Suppress extension connection errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Suppress unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            if (e.reason && e.reason.message && e.reason.message.includes('Could not establish connection')) {
                e.preventDefault();
                return false;
            }
        });
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css?v=1.1">
    <link rel="stylesheet" href="css/modern-theme.css">
    <link rel="stylesheet" href="css/mobile-responsive.css">
    <link rel="stylesheet" href="css/smooth-transitions.css">
    <link rel="stylesheet" href="css/mobile-user-popup.css">
    <link rel="stylesheet" href="css/pyramid-tree.css">
    
    <style>
        /* Professional Tree Theme Overrides */
        .modern-theme {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            font-family: 'Noto Sans Arabic', sans-serif;
        }
        
        .modern-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .modern-btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #1a202c;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        .modern-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }
        
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .connect-wallet-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            cursor: pointer;
            font-size: 14px;
            padding: 10px 20px;
        }
        
        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }
        
        .connect-wallet-btn:active {
            transform: translateY(0);
        }
        
        .connect-wallet-btn.connected {
            background: linear-gradient(135deg, #00cc6a, #00ff88);
            color: #1a202c;
        }
        
        .connect-wallet-btn.connecting {
            background: linear-gradient(135deg, #ffa500, #ff8c00);
            color: #1a202c;
            cursor: not-allowed;
        }
        
        .connect-wallet-btn.error {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #ffffff;
        }
        
        .file-manager-container {
            margin-top: 2rem;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        
        .file-manager-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .file-icon {
            margin-left: 0.5rem;
            font-size: 1.2em;
        }
        
        /* Mobile responsive for buttons */
        @media (max-width: 768px) {
            .back-btn {
                top: 10px;
                left: 10px;
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .connect-wallet-btn {
                top: 10px;
                right: 10px;
                padding: 8px 16px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .back-btn {
                top: 5px;
                left: 5px;
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .connect-wallet-btn {
                top: 5px;
                right: 5px;
                padding: 6px 12px;
                font-size: 11px;
            }
        }
        
        /* Tree container auto-expansion */
        #tree-view {
            width: auto !important;
            height: auto !important;
            min-width: 100%;
            min-height: 100%;
            max-width: none !important;
            max-height: none !important;
            overflow: visible !important;
            padding: 1rem;
            box-sizing: border-box;
        }
        
        /* Tree container responsive sizing */
        .tree-container {
            width: auto !important;
            height: auto !important;
            min-width: 100%;
            min-height: 100%;
            max-width: none !important;
            max-height: none !important;
            overflow: visible !important;
            display: block;
            position: relative;
        }
        
        /* Mobile responsive tree container */
        @media (max-width: 768px) {
            #tree-view {
                width: auto !important;
                height: auto !important;
                min-width: 100vw;
                min-height: 100vh;
                max-width: none !important;
                max-height: none !important;
                overflow: visible !important;
                padding: 0.5rem;
            }
            
            .flat-tree-node {
                width: fit-content;
                min-width: fit-content;
                max-width: 90vw;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
        }
        
        /* Tablet responsive tree container */
        @media (min-width: 769px) and (max-width: 1024px) {
            #tree-view {
                width: auto !important;
                height: auto !important;
                min-width: 100%;
                min-height: 100%;
                max-width: none !important;
                max-height: none !important;
                overflow: visible !important;
                padding: 1rem;
            }
        }
        
        /* Desktop responsive tree container */
        @media (min-width: 1025px) {
            #tree-view {
                width: auto !important;
                height: auto !important;
                min-width: 100%;
                min-height: 100%;
                max-width: none !important;
                max-height: none !important;
                overflow: visible !important;
                padding: 2rem;
            }
        }
        
        /* Distinct level-based color system for tree nodes */
        .flat-tree-node {
            transition: all 0.3s ease;
            border-radius: 8px;
            margin-bottom: 0.4rem;
            position: relative;
            overflow: hidden;
            width: fit-content;
            min-width: fit-content;
            max-width: none;
        }
        
        /* Level 0 - Root (Bright Cyan) */
        .flat-tree-node[data-depth="0"] {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.1));
            border: 3px solid #00ffff;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
            color: #00ffff;
        }
        
        /* Level 1 - Bright Green */
        .flat-tree-node[data-depth="1"] {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.18), rgba(0, 255, 100, 0.09));
            border: 3px solid #00ff88;
            box-shadow: 0 3px 10px rgba(0, 255, 136, 0.25);
            color: #00ff88;
        }
        
        /* Level 2 - Bright Yellow */
        .flat-tree-node[data-depth="2"] {
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.16), rgba(255, 200, 0, 0.08));
            border: 3px solid #ffff00;
            box-shadow: 0 3px 8px rgba(255, 255, 0, 0.2);
            color: #ffff00;
        }
        
        /* Level 3 - Bright Orange */
        .flat-tree-node[data-depth="3"] {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.14), rgba(255, 140, 0, 0.07));
            border: 3px solid #ffa500;
            box-shadow: 0 2px 6px rgba(255, 165, 0, 0.18);
            color: #ffa500;
        }
        
        /* Level 4 - Bright Red */
        .flat-tree-node[data-depth="4"] {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.12), rgba(255, 50, 50, 0.06));
            border: 3px solid #ff0000;
            box-shadow: 0 2px 5px rgba(255, 0, 0, 0.15);
            color: #ff0000;
        }
        
        /* Level 5 - Bright Magenta */
        .flat-tree-node[data-depth="5"] {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(255, 50, 255, 0.05));
            border: 3px solid #ff00ff;
            box-shadow: 0 2px 4px rgba(255, 0, 255, 0.12);
            color: #ff00ff;
        }
        
        /* Level 6 - Bright Blue */
        .flat-tree-node[data-depth="6"] {
            background: linear-gradient(135deg, rgba(0, 0, 255, 0.08), rgba(50, 50, 255, 0.04));
            border: 3px solid #0000ff;
            box-shadow: 0 1px 3px rgba(0, 0, 255, 0.1);
            color: #0000ff;
        }
        
        /* Level 7 - Bright Purple */
        .flat-tree-node[data-depth="7"] {
            background: linear-gradient(135deg, rgba(128, 0, 255, 0.06), rgba(150, 50, 255, 0.03));
            border: 3px solid #8000ff;
            box-shadow: 0 1px 3px rgba(128, 0, 255, 0.08);
            color: #8000ff;
        }
        
        /* Level 8 - Bright Pink */
        .flat-tree-node[data-depth="8"] {
            background: linear-gradient(135deg, rgba(255, 192, 203, 0.08), rgba(255, 150, 200, 0.04));
            border: 3px solid #ffc0cb;
            box-shadow: 0 1px 2px rgba(255, 192, 203, 0.06);
            color: #ffc0cb;
        }
        
        /* Level 9 - Bright Lime */
        .flat-tree-node[data-depth="9"] {
            background: linear-gradient(135deg, rgba(50, 255, 50, 0.06), rgba(100, 255, 100, 0.03));
            border: 3px solid #32ff32;
            box-shadow: 0 1px 2px rgba(50, 255, 50, 0.05);
            color: #32ff32;
        }
        
        /* Level 10 - Bright Teal */
        .flat-tree-node[data-depth="10"] {
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.05), rgba(50, 255, 220, 0.025));
            border: 3px solid #00ffc8;
            box-shadow: 0 1px 2px rgba(0, 255, 200, 0.04);
            color: #00ffc8;
        }
        
        /* Level 11 - Bright Gold */
        .flat-tree-node[data-depth="11"] {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(255, 200, 50, 0.025));
            border: 3px solid #ffd700;
            box-shadow: 0 1px 2px rgba(255, 215, 0, 0.04);
            color: #ffd700;
        }
        
        /* Level 12 - Bright Coral */
        .flat-tree-node[data-depth="12"] {
            background: linear-gradient(135deg, rgba(255, 127, 80, 0.05), rgba(255, 150, 100, 0.025));
            border: 3px solid #ff7f50;
            box-shadow: 0 1px 2px rgba(255, 127, 80, 0.04);
            color: #ff7f50;
        }
        
        /* Level 13 - Bright Indigo */
        .flat-tree-node[data-depth="13"] {
            background: linear-gradient(135deg, rgba(75, 0, 130, 0.05), rgba(100, 50, 150, 0.025));
            border: 3px solid #4b0082;
            box-shadow: 0 1px 2px rgba(75, 0, 130, 0.04);
            color: #4b0082;
        }
        
        /* Level 14 - Bright Turquoise */
        .flat-tree-node[data-depth="14"] {
            background: linear-gradient(135deg, rgba(64, 224, 208, 0.05), rgba(100, 240, 220, 0.025));
            border: 3px solid #40e0d0;
            box-shadow: 0 1px 2px rgba(64, 224, 208, 0.04);
            color: #40e0d0;
        }
        
        /* Level 15 - Bright Violet */
        .flat-tree-node[data-depth="15"] {
            background: linear-gradient(135deg, rgba(238, 130, 238, 0.05), rgba(255, 150, 255, 0.025));
            border: 3px solid #ee82ee;
            box-shadow: 0 1px 2px rgba(238, 130, 238, 0.04);
            color: #ee82ee;
        }
        
        /* Level 16+ - Dynamic colors for deeper levels */
        .flat-tree-node[data-depth="16"],
        .flat-tree-node[data-depth="17"],
        .flat-tree-node[data-depth="18"],
        .flat-tree-node[data-depth="19"],
        .flat-tree-node[data-depth="20"] {
            background: linear-gradient(135deg, rgba(200, 200, 200, 0.04), rgba(180, 180, 180, 0.02));
            border: 3px solid #c8c8c8;
            box-shadow: 0 1px 1px rgba(200, 200, 200, 0.03);
            color: #c8c8c8;
        }
        
        /* Level 21+ - Minimal visibility with distinct colors */
        .flat-tree-node[data-depth="21"],
        .flat-tree-node[data-depth="22"],
        .flat-tree-node[data-depth="23"],
        .flat-tree-node[data-depth="24"],
        .flat-tree-node[data-depth="25"] {
            background: linear-gradient(135deg, rgba(150, 150, 150, 0.03), rgba(130, 130, 130, 0.015));
            border: 3px solid #969696;
            box-shadow: 0 1px 1px rgba(150, 150, 150, 0.02);
            color: #969696;
        }
        
        /* Level indicators */
        .flat-tree-node::before {
            content: attr(data-depth);
            position: absolute;
            top: 2px;
            right: 6px;
            font-size: 10px;
            font-weight: bold;
            opacity: 0.7;
            z-index: 1;
        }
        
        /* Hover effects for all levels */
        .flat-tree-node:hover {
            transform: translateX(3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 255, 136, 0.3);
            z-index: 10;
        }
        
        /* Active/expanded state */
        .flat-tree-node.expanded {
            border-left: 6px solid currentColor;
            transform: translateX(2px);
        }
        
        /* Level separator lines */
        .flat-tree-node[data-depth="0"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #00ffff, transparent);
        }
        
        .flat-tree-node[data-depth="1"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #00ff88, transparent);
        }
        
        .flat-tree-node[data-depth="2"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #ffff00, transparent);
        }
        
        .flat-tree-node[data-depth="3"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #ffa500, transparent);
        }
        
        .flat-tree-node[data-depth="4"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #ff0000, transparent);
        }
        
        .flat-tree-node[data-depth="5"]::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #ff00ff, transparent);
        }
    </style>
    
    <!-- Load ethers.js -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
</head>
<body class="modern-theme">
    <!-- Back Button -->
    <a href="index.html" class="back-btn modern-btn">
        ‚Üê Back to Dashboard
    </a>
    
    <!-- Connect Wallet Button -->
    <button id="connect-wallet-btn" class="connect-wallet-btn modern-btn">
        üîó Connect Wallet
    </button>
    
    <div id="main-network" class="page-section expandable-container modern-card" style="width:100vw;max-width:none;margin:0;left:0;right:0;padding:0.5rem 0;">
        <div class="expand-header">
            <h2 style="color: #00ff88; margin: 0; font-family: 'Montserrat', sans-serif; font-weight: 700;">üåê Network</h2>
        </div>
        <div class="expand-content">
            <div class="network-container modern-card" style="max-width: 1200px; margin: 0 auto; padding: 1rem;">
                <!-- Network Stats -->
                <div id="network-stats" class="network-user-info-container"></div>
                

                <!-- File Manager Style Tree Display -->
                <div id="file-manager-tree">
                    <div class="file-manager-container">
                        <!-- File Manager Header -->
                        <div class="file-manager-header">
                            <div class="file-manager-title">
                                <span class="file-icon">üå≥</span>
                                <span style="font-family: 'Montserrat', sans-serif; font-weight: 700; color: #00ff88;">Tree Manager</span>
                            </div>

                        </div>
                        
                        <!-- File Manager Content -->
                        <div class="file-manager-content">
                            <div class="file-manager-main">
                                <div class="file-manager-breadcrumb" id="breadcrumb">
                                    <span class="breadcrumb-item active">üè† Root</span>
                                </div>
                                
                                <div class="file-manager-tree-view" id="tree-view">
                                    <!-- Tree structure will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/config.js"></script>
    <script src="js/walletconnect-handler.js"></script>
            <script src="js/network.js?v=20250809-36"></script>
    <script src="js/navbar.js"></script>
    <script src="js/token-balances.js"></script>
    <script src="js/tree-events.js"></script>
    
    <script>
        // Pyramid Tree Data
        let pyramidData = {
            root: {
                id: 1,
                index: 'Connected Wallet',
                expanded: false,
                children: [
                    { id: 2, index: '2', expanded: false, children: [] },
                    { id: 3, index: '3', expanded: false, children: [] }
                ]
            }
        };

        // Detect if running on mobile
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   window.innerWidth <= 768;
        }

        // Detect MetaMask on mobile
        function detectMetaMask() {
            console.log('üîç Detecting MetaMask...');
            console.log('üì± Is mobile:', isMobile());
            
            // Check for standard ethereum provider
            if (window.ethereum) {
                console.log('‚úÖ Standard ethereum provider found');
                return window.ethereum;
            }
            
            // Check for mobile MetaMask via web3
            if (window.web3 && window.web3.currentProvider) {
                console.log('üì± Mobile MetaMask detected via web3.currentProvider');
                return window.web3.currentProvider;
            }
            
            // Check for mobile MetaMask via web3
            if (window.web3) {
                console.log('üì± Mobile MetaMask detected via web3');
                return window.web3;
            }
            
            // Check for injected provider
            if (window.ethereum && window.ethereum.isMetaMask) {
                console.log('‚úÖ MetaMask injected provider found');
                return window.ethereum;
            }
            
            // Check for mobile-specific providers
            if (isMobile()) {
                console.log('üì± Checking mobile-specific providers...');
                
                // Check for Trust Wallet
                if (window.ethereum && window.ethereum.isTrust) {
                    console.log('‚úÖ Trust Wallet detected');
                    return window.ethereum;
                }
                
                // Check for Coinbase Wallet
                if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                    console.log('‚úÖ Coinbase Wallet detected');
                    return window.ethereum;
                }
                
                // Check for any ethereum provider
                if (window.ethereum) {
                    console.log('‚úÖ Generic ethereum provider found on mobile');
                    return window.ethereum;
                }
            }
            
            console.log('‚ùå No MetaMask detected');
            return null;
        }

        // Connect to wallet and get real data
        async function connectWalletAndLoadData() {
            try {
                console.log('üîó Connecting to wallet...');
                
                // Check if wallet is already connected
                if (window.contractConfig && window.contractConfig.contract) {
                    console.log('‚úÖ Wallet already connected');
                    
                    // Ensure userAddress is set
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set from provider:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                }
                
                // Detect MetaMask provider
                const ethereumProvider = detectMetaMask();
                if (!ethereumProvider) {
                    console.log('‚ùå No MetaMask provider detected');
                    return false;
                }
                
                // Set ethereum provider
                if (!window.ethereum) {
                    window.ethereum = ethereumProvider;
                    console.log('‚úÖ Ethereum provider set');
                }
                
                // Try to connect wallet
                if (window.connectWallet) {
                    console.log('üîÑ Calling connectWallet function...');
                    await window.connectWallet();
                    console.log('‚úÖ Wallet connected successfully');
                    
                    // Ensure userAddress is set after connection
                    if (!window.contractConfig.userAddress && window.ethereum?.selectedAddress) {
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ User address set after connection:', window.contractConfig.userAddress);
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå connectWallet function not available, trying direct connection...');
                    
                    // Try direct connection
                    try {
                        console.log('üîÑ Attempting direct connection...');
                        
                        // Check if already connected
                        if (window.ethereum.selectedAddress) {
                            console.log('‚úÖ Wallet already connected:', window.ethereum.selectedAddress);
                            
                            // Set up contract config if not exists
                            if (!window.contractConfig) {
                                window.contractConfig = {};
                            }
                            window.contractConfig.userAddress = window.ethereum.selectedAddress;
                            
                            // Try to get contract from other sources
                            if (window.contractConfig.contract) {
                                console.log('‚úÖ Contract already available');
                                return true;
                            }
                            
                            // Try to create contract
                            if (window.ethereum && window.contractConfig.contractAddress && window.contractConfig.contractABI) {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                window.contractConfig.contract = new ethers.Contract(
                                    window.contractConfig.contractAddress,
                                    window.contractConfig.contractABI,
                                    signer
                                );
                                console.log('‚úÖ Contract created successfully');
                                return true;
                            }
                            
                            console.log('‚ö†Ô∏è Contract not available, but wallet connected');
                            return true;
                        }
                        
                        // Request connection
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (accounts && accounts.length > 0) {
                            console.log('‚úÖ Direct wallet connection successful');
                            
                            // Set up contract config if not exists
                            if (!window.contractConfig) {
                                window.contractConfig = {};
                            }
                            window.contractConfig.userAddress = accounts[0];
                            
                            // Try to get contract from other sources
                            if (window.contractConfig.contract) {
                                console.log('‚úÖ Contract already available');
                                return true;
                            }
                            
                            // Try to create contract
                            if (window.ethereum && window.contractConfig.contractAddress && window.contractConfig.contractABI) {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                window.contractConfig.contract = new ethers.Contract(
                                    window.contractConfig.contractAddress,
                                    window.contractConfig.contractABI,
                                    signer
                                );
                                console.log('‚úÖ Contract created successfully');
                                return true;
                            }
                            
                            console.log('‚ö†Ô∏è Contract not available, but wallet connected');
                            return true;
                        }
                    } catch (directError) {
                        console.log('‚ùå Direct connection failed:', directError.message);
                        
                        // Check if it's a user rejection
                        if (directError.code === 4001 || directError.message.includes('User rejected')) {
                            console.log('üë§ User rejected connection');
                            return false;
                        }
                        
                        // Check if it's a mobile-specific error
                        if (directError.message.includes('Please install MetaMask')) {
                            console.log('üì± MetaMask not installed on mobile');
                            return false;
                        }
                    }
                    
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                return false;
            }
        }

        // Get real wallet data
        async function getRealWalletData() {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available');
                    return null;
                }

                const contract = window.contractConfig.contract;
                const userAddress = window.contractConfig.userAddress;
                
                if (!userAddress) {
                    console.log('‚ùå User address not available, trying to get from provider...');
                    // Try to get address from provider
                    if (window.ethereum && window.ethereum.selectedAddress) {
                        const providerAddress = window.ethereum.selectedAddress;
                        console.log('‚úÖ Got address from provider:', providerAddress);
                        window.contractConfig.userAddress = providerAddress;
                    } else {
                        console.log('‚ùå No address available from provider either');
                        return null;
                    }
                }

                console.log('üì° Fetching real wallet data...');
                
                // Use the updated userAddress
                const currentUserAddress = window.contractConfig.userAddress;
                console.log('üìç Using address:', currentUserAddress);
                
                // Get user's index (IAM ID)
                const userIndex = await window.getIndexByAddress(contract, currentUserAddress);
                console.log('‚úÖ User Index:', userIndex.toString());
                
                if (!userIndex || userIndex === 0n) {
                    console.log('‚ùå User not registered');
                    return null;
                }
                
                // Get user's children using getUserTree
                let children = [];
                try {
                    const userTree = await contract.getUserTree(currentUserAddress);
                    console.log('‚úÖ User tree data:', userTree);
                    
                    // userTree returns [leftAddress, rightAddress, activated, ...]
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                    } catch (error) {
                    console.log('‚ö†Ô∏è getUserTree failed, trying getLeftChild/getRightChild...');
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(userIndex);
                        const rightChildIndex = await contract.getRightChild(userIndex);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log('‚ö†Ô∏è getLeftChild/getRightChild also failed, using empty children');
                        children = [];
                    }
                }
                console.log('‚úÖ User children indices:', children);
                
                // Update pyramid data with real data
                pyramidData.root.index = userIndex.toString();
                
                if (children && children.length > 0) {
                    pyramidData.root.children = children.map((child, index) => ({
                        id: index + 2,
                        index: child.toString(),
                        expanded: false,
                        children: []
                    }));
                }
                
                console.log('‚úÖ Real wallet data loaded:', pyramidData);
                return pyramidData;

            } catch (error) {
                console.error('‚ùå Error fetching real wallet data:', error);
                return null;
            }
        }

                // Create pyramid node - Only render direct children (lazy loading)
        function createPyramidNode(node, level = 0) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'pyramid-node';
            nodeDiv.style.marginLeft = `${level * 20}px`;
            
            // Set data-index for color determination (odd/even)
            const nodeIndex = parseInt(node.index);
            nodeDiv.setAttribute('data-index', nodeIndex);
            nodeDiv.setAttribute('data-odd-even', nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            
            // Set data-index-length based on index length
            const indexLength = node.index.toString().length;
            buttonContainer.setAttribute('data-index-length', indexLength);
            
            // Expand button
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            
            // Always set normal state (loading is handled in toggleNode)
            expandBtn.setAttribute('data-loading', 'false');
            expandBtn.textContent = node.expanded ? '‚ñº' : '‚ñ∂';
            
            expandBtn.onclick = () => toggleNode(node.id);
            
            // Index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            nodeDiv.appendChild(buttonContainer);
            
            // Children container - Only render direct children (lazy loading)
            if (node.children && node.children.length > 0 && node.expanded) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                childrenContainer.style.display = 'block';
                
                // Only render direct children - grandchildren will be loaded when their parent is expanded
                node.children.forEach(child => {
                    const childNode = createPyramidNode(child, level + 1);
                    childrenContainer.appendChild(childNode);
                });
                
                nodeDiv.appendChild(childrenContainer);
            }
            
            return nodeDiv;
        }

        // Toggle node expansion
        async function toggleNode(nodeId) {
            const node = findNode(pyramidData.root, nodeId);
            if (node) {
                // Find the expand button for this node
                const expandBtn = document.querySelector(`[onclick="toggleNode(${nodeId})"]`);
                
                // If expanding and no children loaded yet, show loading
                if (!node.expanded && (!node.children || node.children.length === 0)) {
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'true');
                        expandBtn.innerHTML = '<div class="loading-spinner"></div>';
                    }
                    
                    // Load children (only direct children - lazy loading)
                    await loadNodeChildren(node);
                    
                    // Hide loading for parent
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                    }
                    
                    // Don't set loading state for children - only the clicked button shows loading
                } else if (!node.expanded && node.children && node.children.length > 0) {
                    // If children already exist but node is collapsed, just expand
                    // No need to load children again
                } else if (node.expanded) {
                    // If collapsing, reset loading state for all children
                    resetChildrenLoading(node);
                }
                
                node.expanded = !node.expanded;
                
                // Re-render the network lists to show/hide children
                renderNetworkLists();
            }
        }

        // Load children for a specific node - Only direct children (lazy loading)
        async function loadNodeChildren(node) {
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ùå Contract not available for loading children');
                    // Reset loading state on error
                    const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                    if (expandBtn) {
                        expandBtn.setAttribute('data-loading', 'false');
                        expandBtn.textContent = '‚ñ∂';
                    }
                    return;
                }

                const contract = window.contractConfig.contract;
                
                // Use node index directly (no IAM prefix)
                const iamId = node.index;
                console.log(`üì° Loading children for IAM ID: ${iamId}`);
                
                // Get children from contract using correct methods
                let children = [];
                try {
                    // Convert IAM ID to address first
                    const childAddress = await window.getAddressByIndex(contract, iamId);
                    if (!childAddress || childAddress === '0x0000000000000000000000000000000000000000') {
                        console.log(`‚ö†Ô∏è No address found for IAM ID ${iamId}`);
                        return;
                    }
                    
                    // Get user tree for this child
                    const userTree = await contract.getUserTree(childAddress);
                    console.log(`‚úÖ User tree for ${node.index}:`, userTree);
                    
                    const leftAddress = userTree[0];
                    const rightAddress = userTree[1];
                    const activated = userTree[2];
                    
                    if (activated) {
                        // Get indices for left and right children
                        if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                            const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                            if (leftIndex && leftIndex > 0n) {
                                children.push(leftIndex);
                            }
                        }
                        
                        if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                            const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                            if (rightIndex && rightIndex > 0n) {
                                children.push(rightIndex);
                            }
                        }
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è getUserTree failed for ${iamId}, trying getLeftChild/getRightChild...`);
                    try {
                        // Try using getLeftChild and getRightChild
                        const leftChildIndex = await contract.getLeftChild(iamId);
                        const rightChildIndex = await contract.getRightChild(iamId);
                        
                        if (leftChildIndex && leftChildIndex > 0n) {
                            children.push(leftChildIndex);
                        }
                        if (rightChildIndex && rightChildIndex > 0n) {
                            children.push(rightChildIndex);
                        }
                    } catch (error2) {
                        console.log(`‚ö†Ô∏è getLeftChild/getRightChild also failed for ${iamId}`);
                        children = [];
                    }
                }
                console.log(`‚úÖ Children indices for ${node.index}:`, children);
                
                if (children && children.length > 0) {
                    node.children = children.map((child, index) => ({
                        id: node.id * 10 + index + 1,
                        index: child.toString(),
                        expanded: false,
                        children: [], // Will be loaded when this child is expanded
                        loading: false // Children don't have loading state
                    }));
                    
                    console.log(`‚úÖ Created ${node.children.length} children for node ${node.index}`);
                } else {
                    console.log(`‚ö†Ô∏è No children found for node ${node.index}`);
                }
                
            } catch (error) {
                console.error(`‚ùå Error loading children for ${node.index}:`, error);
                // Reset loading state on error
                const expandBtn = document.querySelector(`[onclick="toggleNode(${node.id})"]`);
                if (expandBtn) {
                    expandBtn.setAttribute('data-loading', 'false');
                    expandBtn.textContent = '‚ñ∂';
                }
                // No need to reset children loading state since they don't have it
            }
        }

        // Reset loading state for all children of a node (simplified)
        function resetChildrenLoading(node) {
            // No longer needed since children don't have loading state
            // Only the clicked button shows loading
        }

        // Show user popup for a specific node
        async function showUserPopup(node) {
            try {
                if (!window.mobileUserPopup) {
                    console.log('‚ùå Mobile user popup not available');
                    return;
                }

                console.log('üîÑ Showing user popup for node:', node.index);

                // Get user address by index
                let userAddress = null;
                if (window.contractConfig && window.contractConfig.contract) {
                    try {
                        userAddress = await window.getAddressByIndex(window.contractConfig.contract, node.index);
                        console.log('‚úÖ User address found:', userAddress);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get address for index:', node.index, error);
                    }
                }

                // Get user data
                let userData = null;
                if (userAddress && window.contractConfig && window.contractConfig.contract) {
                    try {
                        userData = await window.contractConfig.contract.getUserByAddress(userAddress);
                        console.log('‚úÖ User data found:', userData);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get user data for address:', userAddress, error);
                    }
                }

                // Create user object for popup
                const user = {
                    index: node.index,
                    binaryPoints: userData ? userData.binaryPoints : 0,
                    binaryPointCap: userData ? userData.binaryPointCap : 0,
                    totalMonthlyRewarded: userData ? userData.totalMonthlyRewarded : 0,
                    binaryPointsClaimed: userData ? userData.binaryPointsClaimed : 0,
                    refclimed: userData ? userData.refclimed : '0',
                    depositedAmount: userData ? userData.depositedAmount : '0',
                    leftPoints: userData ? userData.leftPoints : 0,
                    rightPoints: userData ? userData.rightPoints : 0
                };

                // Show popup
                window.mobileUserPopup.show(userAddress, user);

            } catch (error) {
                console.error('‚ùå Error showing user popup:', error);
                
                // Show popup with minimal data if there's an error
                const fallbackUser = {
                    index: node.index,
                    binaryPoints: 0,
                    binaryPointCap: 0,
                    totalMonthlyRewarded: 0,
                    binaryPointsClaimed: 0,
                    refclimed: '0',
                    depositedAmount: '0',
                    leftPoints: 0,
                    rightPoints: 0
                };
                
                if (window.mobileUserPopup) {
                    window.mobileUserPopup.show(null, fallbackUser);
                }
            }
        }

        // Find node by ID - Recursive search through all loaded nodes
        function findNode(node, id) {
            if (node.id === id) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNode(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        // Render file manager tree
        function renderPyramidTree() {
            console.log('üîÑ Rendering file manager tree...');
            
            // Initialize file manager
            initializeFileManager();
            
            // Load tree data
            loadFileManagerTree();
        }

        // File Manager Data
        let fileManagerData = {
            currentPath: ['root'],
            expandedNodes: new Set(),
            treeData: {},
            networks: []
        };

        // Initialize file manager
        function initializeFileManager() {
            console.log('üîß Initializing file manager...');
            
            // Setup event listeners
            setupFileManagerEvents();
            
            // Initialize breadcrumb
            updateBreadcrumb();
        }

        // Setup file manager event listeners
        function setupFileManagerEvents() {
            // No action buttons needed
        }



        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            if (!breadcrumb) return;
            
            const path = fileManagerData.currentPath;
            breadcrumb.innerHTML = path.map((item, index) => {
                const isLast = index === path.length - 1;
                return `
                    <span class="breadcrumb-item ${isLast ? 'active' : ''}" data-path="${path.slice(0, index + 1).join('/')}">
                        ${index === 0 ? 'üè†' : 'üìÅ'} ${item}
                    </span>
                    ${!isLast ? '<span class="breadcrumb-separator">/</span>' : ''}
                `;
            }).join('');
            
            // Add click listeners to breadcrumb items
            breadcrumb.querySelectorAll('.breadcrumb-item').forEach(item => {
                item.addEventListener('click', () => {
                    const newPath = item.dataset.path.split('/');
                    navigateToPath(newPath);
                });
            });
        }

        // Navigate to specific path
        function navigateToPath(path) {
            fileManagerData.currentPath = path;
            updateBreadcrumb();
            renderTreeView();
        }

        // Load file manager tree data
        async function loadFileManagerTree() {
            console.log('üìÅ Loading file manager tree data...');
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è No contract connection, showing empty state');
                    showEmptyTree();
                    return;
                }
                
                // Load root node
                await loadRootNode();
                
                // Render tree view
                renderTreeView();
                
            } catch (error) {
                console.error('‚ùå Error loading file manager tree:', error);
                showErrorTree();
            }
        }

        // Load root node
        async function loadRootNode() {
            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('No user address available');
            }
            
            // Get user info
            const user = await contract.users(userAddress);
            const userIndex = user.index ? user.index.toString() : '1';
            
            // Create root node
            fileManagerData.treeData = {
                id: 'root',
                index: userIndex,
                address: userAddress,
                type: 'root',
                expanded: false,
                children: [],
                hasChildren: true
            };
            
            console.log('‚úÖ Root node loaded:', fileManagerData.treeData);
        }

        // Render tree view - Flat structure with auto-expansion
        function renderTreeView() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            if (!fileManagerData.treeData || Object.keys(fileManagerData.treeData).length === 0) {
                showEmptyTree();
                return;
            }
            
            treeView.innerHTML = '';
            
            // Render all nodes in flat structure
            renderFlatTree(fileManagerData.treeData, treeView, 0);
            
            // Auto-expand container after rendering
            setTimeout(() => {
                autoExpandTreeContainer();
            }, 100);
        }
        
        // Auto-expand tree container based on content
        function autoExpandTreeContainer() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            // Get all tree nodes
            const treeNodes = treeView.querySelectorAll('.flat-tree-node');
            if (treeNodes.length === 0) return;
            
            // Calculate required dimensions
            let maxWidth = 0;
            let totalHeight = 0;
            let maxDepth = 0;
            
            treeNodes.forEach(node => {
                const rect = node.getBoundingClientRect();
                const depth = parseInt(node.getAttribute('data-depth') || '0');
                
                // Calculate width including depth offset
                const nodeWidth = rect.width + (depth * 1.5 * 16); // 1.5rem * 16px
                maxWidth = Math.max(maxWidth, nodeWidth);
                
                // Calculate total height
                totalHeight += rect.height + 0.4 * 16; // margin-bottom
                
                // Track max depth
                maxDepth = Math.max(maxDepth, depth);
            });
            
            // Add padding and margins
            const padding = 2 * 16; // 2rem padding
            const requiredWidth = maxWidth + padding;
            const requiredHeight = totalHeight + padding;
            
            // Apply dynamic sizing
            treeView.style.width = `${Math.max(requiredWidth, window.innerWidth)}px`;
            treeView.style.height = `${Math.max(requiredHeight, window.innerHeight)}px`;
            treeView.style.minWidth = `${requiredWidth}px`;
            treeView.style.minHeight = `${requiredHeight}px`;
            
            console.log(`üìè Tree container resized: ${requiredWidth}x${requiredHeight}px (depth: ${maxDepth})`);
            
            // Also resize parent containers
            const parentContainer = treeView.closest('.expand-content');
            if (parentContainer) {
                parentContainer.style.width = 'auto';
                parentContainer.style.height = 'auto';
                parentContainer.style.overflow = 'visible';
            }
            
            const expandableContainer = treeView.closest('.expandable-container');
            if (expandableContainer) {
                expandableContainer.style.width = 'auto';
                expandableContainer.style.height = 'auto';
                expandableContainer.style.overflow = 'visible';
            }
        }

        // Global depth tracking
        let maxDepthReached = 0;
        
        // Test function to check current depth
        window.checkTreeDepth = function() {
            console.log(`üìä Current maximum depth reached: ${maxDepthReached}`);
            console.log(`üìä Total expanded nodes: ${fileManagerData.expandedNodes.size}`);
            console.log(`üìä Expanded nodes:`, Array.from(fileManagerData.expandedNodes));
            return maxDepthReached;
        };
        
        // Test function to expand all nodes to maximum depth
        window.expandAllNodes = async function() {
            console.log('üöÄ Expanding all nodes to maximum depth...');
            const startTime = Date.now();
            
            // Get all nodes that have children but are not expanded
            const nodesToExpand = [];
            function collectExpandableNodes(node) {
                if (node.hasChildren && !fileManagerData.expandedNodes.has(node.id)) {
                    nodesToExpand.push(node);
                }
                if (node.children) {
                    node.children.forEach(child => collectExpandableNodes(child));
                }
            }
            
            if (fileManagerData.treeData) {
                collectExpandableNodes(fileManagerData.treeData);
            }
            
            console.log(`üìã Found ${nodesToExpand.length} nodes to expand`);
            
            // Expand nodes in batches
            for (let i = 0; i < nodesToExpand.length; i++) {
                const node = nodesToExpand[i];
                console.log(`üîÑ Expanding node ${node.id} (${i + 1}/${nodesToExpand.length})`);
                
                // Add to expanded set
                fileManagerData.expandedNodes.add(node.id);
                
                // Load children if not already loaded
                if (!node.children || node.children.length === 0) {
                    await loadNodeChildren(node, 0);
                }
                
                // No delay - unlimited tree expansion speed
                // Removed delay for faster tree expansion
            }
            
            const endTime = Date.now();
            console.log(`‚úÖ Expansion completed in ${endTime - startTime}ms`);
            console.log(`üìä Final maximum depth: ${maxDepthReached}`);
        };
        
        // Test function to check specific node at level 9
        window.testLevel9Nodes = async function() {
            console.log('üîç Testing level 9 nodes...');
            
            // Find all nodes at level 9
            const level9Nodes = [];
            function findLevel9Nodes(node, depth = 0) {
                if (depth === 9) {
                    level9Nodes.push(node);
                }
                if (node.children) {
                    node.children.forEach(child => findLevel9Nodes(child, depth + 1));
                }
            }
            
            if (fileManagerData.treeData) {
                findLevel9Nodes(fileManagerData.treeData);
            }
            
            console.log(`üìä Found ${level9Nodes.length} nodes at level 9`);
            
            // Test each level 9 node
            for (let i = 0; i < level9Nodes.length; i++) {
                const node = level9Nodes[i];
                console.log(`üß™ Testing node ${node.id} (index: ${node.index}) at level 9`);
                
                // Try to load children
                await loadNodeChildren(node, 9);
                
                // Check if children were loaded
                if (node.children && node.children.length > 0) {
                    console.log(`‚úÖ Node ${node.id} has ${node.children.length} children`);
                } else {
                    console.log(`‚ùå Node ${node.id} has no children`);
                }
                
                // No delay - unlimited testing speed
                // Removed delay for faster testing
            }
        };
        
        // Test function to check contract calls for specific index
        window.testContractCall = async function(index) {
            console.log(`üß™ Testing contract call for index ${index}`);
            
            if (!window.contractConfig || !window.contractConfig.contract) {
                console.log('‚ùå Contract not available');
                return;
            }
            
            try {
                const contract = window.contractConfig.contract;
                const nodeIndex = parseInt(index);
                
                console.log(`üìû Calling getLeftAddress(${nodeIndex})...`);
                const leftAddress = await contract.getLeftAddress(nodeIndex);
                console.log(`üìç Left address: ${leftAddress}`);
                
                console.log(`üìû Calling getRightAddress(${nodeIndex})...`);
                const rightAddress = await contract.getRightAddress(nodeIndex);
                console.log(`üìç Right address: ${rightAddress}`);
                
                const leftValid = leftAddress !== '0x0000000000000000000000000000000000000000';
                const rightValid = rightAddress !== '0x0000000000000000000000000000000000000000';
                
                console.log(`üîç Left valid: ${leftValid}, Right valid: ${rightValid}`);
                
                if (leftValid) {
                    console.log(`‚úÖ Left child exists at index ${nodeIndex * 2}`);
                }
                if (rightValid) {
                    console.log(`‚úÖ Right child exists at index ${nodeIndex * 2 + 1}`);
                }
                
            } catch (error) {
                console.error('‚ùå Error testing contract call:', error);
            }
        };
        
        // Test function to check mathematical relationship and depth limits
        window.testDepthMath = function() {
            console.log('üßÆ Testing mathematical relationship for tree depth...');
            
            // Calculate theoretical maximum depth based on index
            const maxIndex = 1000000; // Test with large number
            const maxDepth = Math.floor(Math.log2(maxIndex));
            
            console.log(`üìä Theoretical maximum depth for index ${maxIndex}: ${maxDepth}`);
            
            // Test index calculation for different levels
            for (let level = 0; level <= 20; level++) {
                const maxIndexAtLevel = Math.pow(2, level + 1) - 1;
                const minIndexAtLevel = Math.pow(2, level);
                
                console.log(`üìä Level ${level}: Index range ${minIndexAtLevel} - ${maxIndexAtLevel}`);
                
                // Check if we're hitting any limits
                if (maxIndexAtLevel > 1000000) {
                    console.log(`‚ö†Ô∏è Level ${level} might hit practical limits (index > 1M)`);
                }
            }
            
            // Test specific indices that might be problematic
            const testIndices = [512, 1024, 2048, 4096, 8192, 16384, 32768, 65536];
            testIndices.forEach(index => {
                const level = Math.floor(Math.log2(index));
                console.log(`üìä Index ${index} is at level ${level}`);
            });
        };
        
        // Test function to check if there's a 50% rendering limit
        window.test50PercentLimit = async function() {
            console.log('üîç Testing for 50% rendering limit...');
            
            // Find all nodes at different levels
            const levelCounts = {};
            function countNodesByLevel(node, depth = 0) {
                if (!levelCounts[depth]) levelCounts[depth] = 0;
                levelCounts[depth]++;
                
                if (node.children) {
                    node.children.forEach(child => countNodesByLevel(child, depth + 1));
                }
            }
            
            if (fileManagerData.treeData) {
                countNodesByLevel(fileManagerData.treeData);
            }
            
            console.log('üìä Node counts by level:');
            Object.keys(levelCounts).forEach(level => {
                const count = levelCounts[level];
                const expectedCount = Math.pow(2, parseInt(level));
                const percentage = (count / expectedCount) * 100;
                
                console.log(`üìä Level ${level}: ${count} nodes (expected: ${expectedCount}, ${percentage.toFixed(1)}%)`);
                
                if (percentage < 50) {
                    console.log(`‚ö†Ô∏è Level ${level} has less than 50% of expected nodes!`);
                }
            });
        };
        
        // Force unlimited expansion - bypass all limits
        window.forceUnlimitedExpansion = async function() {
            console.log('üöÄ FORCING UNLIMITED EXPANSION - BYPASSING ALL LIMITS...');
            
            let expansionCount = 0;
            let maxIterations = 1000; // Prevent infinite loops
            
            while (expansionCount < maxIterations) {
                expansionCount++;
                console.log(`üîÑ FORCE EXPANSION ITERATION ${expansionCount}`);
                
                // Find all nodes that can be expanded
                const expandableNodes = [];
                function findExpandableNodes(node) {
                    if (node.hasChildren && !fileManagerData.expandedNodes.has(node.id)) {
                        expandableNodes.push(node);
                    }
                    if (node.children) {
                        node.children.forEach(child => findExpandableNodes(child));
                    }
                }
                
                if (fileManagerData.treeData) {
                    findExpandableNodes(fileManagerData.treeData);
                }
                
                console.log(`üìã Found ${expandableNodes.length} expandable nodes in iteration ${expansionCount}`);
                
                if (expandableNodes.length === 0) {
                    console.log('‚úÖ No more nodes to expand - tree fully expanded!');
                    break;
                }
                
                // Force expand all nodes
                for (let i = 0; i < expandableNodes.length; i++) {
                    const node = expandableNodes[i];
                    console.log(`üî• FORCE EXPANDING node ${node.id} (${i + 1}/${expandableNodes.length})`);
                    
                    // Force add to expanded set
                    fileManagerData.expandedNodes.add(node.id);
                    
                    // Force load children
                    if (!node.children || node.children.length === 0) {
                        try {
                            await loadNodeChildren(node, 0);
                        } catch (error) {
                            console.log(`‚ö†Ô∏è Error loading children for ${node.id}:`, error.message);
                        }
                    }
                }
                
                // Force re-render
                renderTreeView();
                
                // Check current depth
                console.log(`üìä Current max depth: ${maxDepthReached}`);
                
                // Small delay to prevent browser freeze
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            console.log(`üèÅ FORCE EXPANSION COMPLETED after ${expansionCount} iterations`);
            console.log(`üìä Final maximum depth: ${maxDepthReached}`);
        };
        
        // Test blockchain data directly - bypass tree structure
        window.testBlockchainDataDirectly = async function() {
            console.log('üîç TESTING BLOCKCHAIN DATA DIRECTLY...');
            
            if (!window.contractConfig || !window.contractConfig.contract) {
                console.log('‚ùå Contract not available');
                return;
            }
            
            const contract = window.contractConfig.contract;
            
            // Test specific indices to see if blockchain has data beyond level 9
            const testIndices = [
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536
            ];
            
            console.log('üß™ Testing blockchain data for specific indices...');
            
            for (let i = 0; i < testIndices.length; i++) {
                const index = testIndices[i];
                const level = Math.floor(Math.log2(index));
                
                try {
                    console.log(`üìû Testing index ${index} (level ${level})...`);
                    
                    const leftAddress = await contract.getLeftAddress(index);
                    const rightAddress = await contract.getRightAddress(index);
                    
                    const leftValid = leftAddress !== '0x0000000000000000000000000000000000000000';
                    const rightValid = rightAddress !== '0x0000000000000000000000000000000000000000';
                    
                    console.log(`üìç Index ${index} (Level ${level}): Left=${leftValid}, Right=${rightValid}`);
                    
                    if (leftValid || rightValid) {
                        console.log(`‚úÖ Level ${level} has valid data!`);
                    } else {
                        console.log(`‚ùå Level ${level} has no valid data`);
                    }
                    
                } catch (error) {
                    console.log(`‚ùå Error testing index ${index}:`, error.message);
                }
                
                // Small delay
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        };
        
        // Create unlimited tree manually - bypass all restrictions
        window.createUnlimitedTree = async function() {
            console.log('üöÄ CREATING UNLIMITED TREE MANUALLY...');
            
            if (!window.contractConfig || !window.contractConfig.contract) {
                console.log('‚ùå Contract not available');
                return;
            }
            
            const contract = window.contractConfig.contract;
            const unlimitedTree = {
                id: 'unlimited_root',
                index: '1',
                address: window.contractConfig.userAddress,
                type: 'node',
                expanded: true,
                children: [],
                hasChildren: true
            };
            
            // Manually create tree structure up to level 20
            async function createTreeLevel(parentNode, level, maxLevel = 20) {
                if (level >= maxLevel) return;
                
                console.log(`üå≥ Creating level ${level} for node ${parentNode.id}`);
                
                const nodeIndex = parseInt(parentNode.index);
                const leftIndex = nodeIndex * 2;
                const rightIndex = nodeIndex * 2 + 1;
                
                try {
                    // Get addresses
                    const leftAddress = await contract.getLeftAddress(nodeIndex);
                    const rightAddress = await contract.getRightAddress(nodeIndex);
                    
                    const leftValid = leftAddress !== '0x0000000000000000000000000000000000000000';
                    const rightValid = rightAddress !== '0x0000000000000000000000000000000000000000';
                    
                    if (leftValid) {
                        const leftChild = {
                            id: `unlimited_node_${leftIndex}`,
                            index: leftIndex.toString(),
                            address: leftAddress,
                            type: 'node',
                            expanded: false,
                            children: [],
                            hasChildren: true
                        };
                        parentNode.children.push(leftChild);
                        console.log(`‚úÖ Added left child: ${leftChild.id}`);
                        
                        // Recursively create next level
                        await createTreeLevel(leftChild, level + 1, maxLevel);
                    }
                    
                    if (rightValid) {
                        const rightChild = {
                            id: `unlimited_node_${rightIndex}`,
                            index: rightIndex.toString(),
                            address: rightAddress,
                            type: 'node',
                            expanded: false,
                            children: [],
                            hasChildren: true
                        };
                        parentNode.children.push(rightChild);
                        console.log(`‚úÖ Added right child: ${rightChild.id}`);
                        
                        // Recursively create next level
                        await createTreeLevel(rightChild, level + 1, maxLevel);
                    }
                    
                } catch (error) {
                    console.log(`‚ùå Error creating level ${level}:`, error.message);
                }
            }
            
            // Create unlimited tree
            await createTreeLevel(unlimitedTree, 0, 20);
            
            // Replace current tree data
            fileManagerData.treeData = unlimitedTree;
            
            // Force expand all nodes
            function forceExpandAll(node) {
                fileManagerData.expandedNodes.add(node.id);
                if (node.children) {
                    node.children.forEach(child => forceExpandAll(child));
                }
            }
            forceExpandAll(unlimitedTree);
            
            // Render the unlimited tree
            renderTreeView();
            
            console.log('üèÅ UNLIMITED TREE CREATED AND RENDERED!');
            console.log(`üìä Final maximum depth: ${maxDepthReached}`);
        };
        
        // Manual function to expand tree container
        window.expandTreeContainer = function() {
            console.log('üìè Manually expanding tree container...');
            autoExpandTreeContainer();
        };
        
        // Function to reset and re-expand container
        window.resetTreeContainer = function() {
            console.log('üîÑ Resetting tree container...');
            const treeView = document.getElementById('tree-view');
            if (treeView) {
                treeView.style.width = 'auto';
                treeView.style.height = 'auto';
                treeView.style.minWidth = '100%';
                treeView.style.minHeight = '100%';
                treeView.style.maxWidth = 'none';
                treeView.style.maxHeight = 'none';
                treeView.style.overflow = 'visible';
            }
            
            // Reset parent containers
            const parentContainer = treeView?.closest('.expand-content');
            if (parentContainer) {
                parentContainer.style.width = 'auto';
                parentContainer.style.height = 'auto';
                parentContainer.style.overflow = 'visible';
            }
            
            const expandableContainer = treeView?.closest('.expandable-container');
            if (expandableContainer) {
                expandableContainer.style.width = 'auto';
                expandableContainer.style.height = 'auto';
                expandableContainer.style.overflow = 'visible';
            }
            
            // Re-expand after reset
            setTimeout(() => {
                autoExpandTreeContainer();
            }, 100);
        };
        
        // Render flat tree structure - all nodes in single container
        function renderFlatTree(node, container, depth = 0) {
            // Track maximum depth
            if (depth > maxDepthReached) {
                maxDepthReached = depth;
                console.log(`üèÜ New maximum depth reached: ${depth} (node: ${node.id})`);
            }
            
            // Debug logging
            console.log(`üå≥ Rendering node ${node.id} at depth ${depth} (max: ${maxDepthReached})`);
            
            // Render current node
            renderFlatNode(node, container, depth);
            
            // If node is expanded and has children, render them
            const isExpanded = fileManagerData.expandedNodes.has(node.id);
            console.log(`üîç Node ${node.id} - expanded: ${isExpanded}, hasChildren: ${node.children && node.children.length > 0}, childrenCount: ${node.children ? node.children.length : 0}`);
            
            if (isExpanded && node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    console.log(`üë∂ Rendering child ${child.id} at depth ${depth + 1}`);
                    renderFlatTree(child, container, depth + 1);
                });
            }
        }

        // Render individual flat tree node
        function renderFlatNode(node, container, depth = 0) {
            const nodeElement = document.createElement('div');
            nodeElement.className = 'tree-node flat-tree-node';
            nodeElement.style.marginRight = `${depth * 1.5}rem`;
            nodeElement.setAttribute('data-node-id', node.id);
            nodeElement.setAttribute('data-depth', depth);
            
            // Dynamic color generation for very deep levels (26+)
            if (depth >= 26) {
                // Generate distinct colors for deeper levels
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                    '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
                    '#10ac84', '#ee5a24', '#0984e3', '#6c5ce7', '#a29bfe',
                    '#fd79a8', '#fdcb6e', '#e17055', '#81ecec', '#74b9ff'
                ];
                
                const colorIndex = (depth - 26) % colors.length;
                const selectedColor = colors[colorIndex];
                
                // Convert hex to RGB
                const r = parseInt(selectedColor.slice(1, 3), 16);
                const g = parseInt(selectedColor.slice(3, 5), 16);
                const b = parseInt(selectedColor.slice(5, 7), 16);
                
                const intensity = Math.max(0.02, 0.08 - (depth - 26) * 0.002);
                const borderIntensity = Math.max(0.1, 0.3 - (depth - 26) * 0.005);
                const shadowIntensity = Math.max(0.05, 0.15 - (depth - 26) * 0.003);
                
                nodeElement.style.background = `linear-gradient(135deg, rgba(${r}, ${g}, ${b}, ${intensity}), rgba(${r}, ${g}, ${b}, ${intensity * 0.5}))`;
                nodeElement.style.border = `3px solid rgba(${r}, ${g}, ${b}, ${borderIntensity})`;
                nodeElement.style.boxShadow = `0 2px 4px rgba(${r}, ${g}, ${b}, ${shadowIntensity})`;
                nodeElement.style.color = selectedColor;
            }
            
            const isExpanded = fileManagerData.expandedNodes.has(node.id);
            const hasChildren = node.hasChildren || (node.children && node.children.length > 0);
            
            nodeElement.innerHTML = `
                <div class="tree-node-content ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                    ${hasChildren ? `
                        <button class="tree-expand-btn ${isExpanded ? 'expanded' : ''}" data-node-id="${node.id}">
                            ${isExpanded ? '‚àí' : '+'}
                        </button>
                    ` : '<div style="width: 14px;"></div>'}
                    

                    <span class="tree-node-label">${node.index}</span>
                    ${!isMobile() ? `<span class="tree-node-info" onclick="copyToClipboard('${node.address}')" title="Click to copy full address">${node.address ? node.address.substring(0, 6) + '...' + node.address.substring(node.address.length - 4) : ''}</span>` : ''}
                </div>
            `;
            
            container.appendChild(nodeElement);
            
            // Add click listeners
            const expandBtn = nodeElement.querySelector('.tree-expand-btn');
            if (expandBtn) {
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNodeExpansion(node.id);
                });
            }
            
            const nodeContent = nodeElement.querySelector('.tree-node-content');
            nodeContent.addEventListener('click', () => {
                selectNode(node);
            });
        }



        // Toggle node expansion for flat structure
        async function toggleNodeExpansion(nodeId) {
            const node = findNodeInTree(fileManagerData.treeData, nodeId);
            if (!node) return;
            
            if (fileManagerData.expandedNodes.has(nodeId)) {
                // Collapsing - remove from expanded set
                fileManagerData.expandedNodes.delete(nodeId);
            } else {
                // Expanding - add to expanded set and load children if needed
                fileManagerData.expandedNodes.add(nodeId);
                
                // Load children if not already loaded
                if (!node.children || node.children.length === 0) {
                    await loadNodeChildren(node, 0);
                }
            }
            
            // Re-render the entire tree
            renderTreeView();
        }

        // Find node in tree structure
        function findNodeInTree(node, nodeId) {
            if (node.id === nodeId) return node;
            
            if (node.children && node.children.length > 0) {
                for (let child of node.children) {
                    const found = findNodeInTree(child, nodeId);
                    if (found) return found;
                }
            }
            return null;
        }

        // Select node
        function selectNode(node) {
            console.log('üéØ Node selected:', node);
            
            // Update breadcrumb
            fileManagerData.currentPath = ['root', node.index];
            updateBreadcrumb();
            
            // Show node details (could be expanded later)
            showNodeDetails(node);
        }

        // Copy address to clipboard
        function copyToClipboard(text) {
            if (!text) return;
            
            navigator.clipboard.writeText(text).then(() => {
                // Show success message
                const toast = document.createElement('div');
                toast.style.cssText = `
            position: fixed;
            top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #00ff88, #00cc6a);
                    color: #1a202c;
                    padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
                    animation: slideIn 0.3s ease;
                `;
                toast.textContent = 'Address copied to clipboard!';
                document.body.appendChild(toast);
                
                // Remove toast after 3 seconds
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        document.body.removeChild(toast);
                    }, 300);
                }, 3000);
                
            }).catch(err => {
                console.error('Failed to copy address:', err);
                
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                alert('Address copied to clipboard!');
            });
        }

        // Show node details with typewriter effect
        async function showNodeDetails(node) {
            console.log('üìã Node details:', {
                index: node.index,
                address: node.address,
                type: node.type,
                hasChildren: node.hasChildren
            });
            
            if (!node.address) {
                console.log('‚ùå No address available');
                return;
            }
            
            try {
                let user = null;
                let contract = null;
                
                // Try to get contract from different sources
                if (window.contractConfig && window.contractConfig.contract) {
                    contract = window.contractConfig.contract;
                    console.log('‚úÖ Using contractConfig contract');
                } else if (typeof window.connectWallet === 'function') {
                    try {
                        const connection = await window.connectWallet();
                        if (connection && connection.contract) {
                            contract = connection.contract;
                            console.log('‚úÖ Using connectWallet contract');
                        }
                    } catch (error) {
                        console.log('‚ùå connectWallet failed:', error.message);
                    }
                }
                
                if (!contract) {
                    console.log('‚ùå No contract available');
                    return;
                }
                
                // Get user data from contract
                console.log('üîÑ Fetching user data for address:', node.address);
                user = await contract.users(node.address);
                
                console.log('üë§ User data:', user);
                
                // Validate user data
                if (!user || user.index === undefined) {
                    console.log('‚ùå Invalid user data received');
                    return;
                }
                
                // Show mobile user popup with typewriter effect
                if (window.mobileUserPopup) {
                    console.log('üîÑ Showing mobile user popup...');
                    await window.mobileUserPopup.show(node.address, user);
                    console.log('‚úÖ Mobile user popup shown successfully');
                } else {
                    console.log('‚ùå Mobile user popup not available');
                }
                
            } catch (error) {
                console.error('‚ùå Error fetching user data:', error);
                
                // Show error popup
                if (window.mobileUserPopup) {
                    const errorUser = {
                        index: node.index || 0,
                        binaryPoints: 0,
                        binaryPointCap: 0,
                        totalMonthlyRewarded: 0,
                        binaryPointsClaimed: 0,
                        refclimed: 0,
                        depositedAmount: 0,
                        leftPoints: 0,
                        rightPoints: 0
                    };
                    await window.mobileUserPopup.show(node.address, errorUser);
                }
            }
        }

        // Load node children for flat structure - UNLIMITED VERSION
        async function loadNodeChildren(node, depth) {
            try {
                console.log(`üîÑ UNLIMITED LOADING children for node ${node.id} (index: ${node.index}) at depth ${depth}`);
                
                const contract = window.contractConfig.contract;
                const nodeIndex = parseInt(node.index);
                
                // FORCE load children - no timeout limits
                console.log(`üî• FORCE CALLING getLeftAddress(${nodeIndex})...`);
                const leftAddress = await contract.getLeftAddress(nodeIndex);
                console.log(`üî• FORCE CALLING getRightAddress(${nodeIndex})...`);
                const rightAddress = await contract.getRightAddress(nodeIndex);
                
                console.log(`üìç Node ${node.id} - Left: ${leftAddress}, Right: ${rightAddress}`);
                
                // Check if addresses are valid (not zero address)
                const leftValid = leftAddress !== '0x0000000000000000000000000000000000000000';
                const rightValid = rightAddress !== '0x0000000000000000000000000000000000000000';
                
                console.log(`üîç Node ${node.id} - Left valid: ${leftValid}, Right valid: ${rightValid}`);
                
                const children = [];
                
                // Add left child if exists
                if (leftValid) {
                    const leftIndex = (nodeIndex * 2).toString();
                    const leftChild = {
                        id: `node_${leftIndex}`,
                        index: leftIndex,
                        address: leftAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    };
                    children.push(leftChild);
                    console.log(`‚úÖ Added left child: ${leftChild.id} (index: ${leftIndex})`);
                } else {
                    console.log(`‚ùå Left child not valid for node ${node.id} (index: ${nodeIndex})`);
                }
                
                // Add right child if exists
                if (rightValid) {
                    const rightIndex = (nodeIndex * 2 + 1).toString();
                    const rightChild = {
                        id: `node_${rightIndex}`,
                        index: rightIndex,
                        address: rightAddress,
                        type: 'node',
                        expanded: false,
                        children: [],
                        hasChildren: true
                    };
                    children.push(rightChild);
                    console.log(`‚úÖ Added right child: ${rightChild.id} (index: ${rightIndex})`);
                } else {
                    console.log(`‚ùå Right child not valid for node ${node.id} (index: ${nodeIndex})`);
                }
                
                // Update node with children
                node.children = children;
                node.hasChildren = children.length > 0;
                
                console.log(`üéØ Node ${node.id} now has ${children.length} children`);
                
                // Re-render the entire tree to show new children
                renderTreeView();
                
            } catch (error) {
                console.error('‚ùå Error loading node children:', error);
            }
        }





        // Show empty tree state
        function showEmptyTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">üìÅ</div>
                    <div>No tree data available</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #a786ff;">
                        Connect your wallet to load the network tree
                    </div>
                </div>
            `;
        }

        // Show error tree state
        function showErrorTree() {
            const treeView = document.getElementById('tree-view');
            if (!treeView) return;
            
            treeView.innerHTML = `
                <div class="tree-empty">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">‚ùå</div>
                    <div>Error loading tree data</div>
                    <div style="font-size: 0.8rem; margin-top: 0.5rem; color: #ff6b6b;">
                        Please try refreshing the page
                    </div>
                </div>
            `;
        }

        // Render all networks in 4 columns with fast traversal
        async function renderNetworkLists() {
            console.log('üöÄ Starting fast network traversal...');
            
            // Get all network lists
            const network1List = document.getElementById('network-1-list');
            const network2List = document.getElementById('network-2-list');
            const network3List = document.getElementById('network-3-list');
            const network4List = document.getElementById('network-4-list');
            
            if (!network1List || !network2List || !network3List || !network4List) return;
            
            // Clear existing content
            network1List.innerHTML = '';
            network2List.innerHTML = '';
            network3List.innerHTML = '';
            network4List.innerHTML = '';
            
            // Show loading state
            const loadingHtml = '<div style="text-align: center; color: #00ff88; padding: 1rem;">üîÑ Loading network...</div>';
            network1List.innerHTML = loadingHtml;
            network2List.innerHTML = loadingHtml;
            network3List.innerHTML = loadingHtml;
            network4List.innerHTML = loadingHtml;
            
            try {
                // Get all networks using fast traversal
                const allNetworks = await getAllNetworksFast();
                console.log('‚úÖ All networks loaded:', allNetworks);
                
                // Render each network in its column
                renderNetworkInColumn(network1List, allNetworks.network1, 'Network 1', 1);
                renderNetworkInColumn(network2List, allNetworks.network2, 'Network 2', 2);
                renderNetworkInColumn(network3List, allNetworks.network3, 'Network 3', 3);
                renderNetworkInColumn(network4List, allNetworks.network4, 'Network 4', 4);
                
            } catch (error) {
                console.error('‚ùå Error loading networks:', error);
                const errorHtml = '<div style="text-align: center; color: #ff4757; padding: 1rem;">‚ùå Error loading network</div>';
                network1List.innerHTML = errorHtml;
                network2List.innerHTML = errorHtml;
                network3List.innerHTML = errorHtml;
                network4List.innerHTML = errorHtml;
            }
        }

        // Fast traversal to get all networks
        async function getAllNetworksFast() {
            if (!window.contractConfig || !window.contractConfig.contract) {
                throw new Error('Contract not available');
            }

            const contract = window.contractConfig.contract;
            const userAddress = window.contractConfig.userAddress;
            
            if (!userAddress) {
                throw new Error('User address not available');
            }

            console.log('üì° Starting fast traversal for user:', userAddress);
            
            // Get user's index
            const userIndex = await window.getIndexByAddress(contract, userAddress);
            console.log('‚úÖ User index:', userIndex.toString());
            
            const allNetworks = {
                network1: [],
                network2: [],
                network3: [],
                network4: []
            };
            
            // Get root children first
            const rootChildren = await getNodeChildrenFast(contract, userIndex);
            console.log('‚úÖ Root children:', rootChildren);
            
            if (rootChildren.length === 0) {
                return allNetworks;
            }
            
            // Process each root child and its descendants
            const promises = [];
            
            if (rootChildren.length > 0) {
                promises.push(traverseNetworkFast(contract, rootChildren[0], allNetworks.network1, 'Network 1'));
            }
            if (rootChildren.length > 1) {
                promises.push(traverseNetworkFast(contract, rootChildren[1], allNetworks.network2, 'Network 2'));
            }
            if (rootChildren.length > 2) {
                promises.push(traverseNetworkFast(contract, rootChildren[2], allNetworks.network3, 'Network 3'));
            }
            if (rootChildren.length > 3) {
                promises.push(traverseNetworkFast(contract, rootChildren[3], allNetworks.network4, 'Network 4'));
            }
            
            // Wait for all networks to be traversed
            await Promise.all(promises);
            
            console.log('‚úÖ Fast traversal completed:', allNetworks);
            return allNetworks;
        }

        // Fast traversal for a single network
        async function traverseNetworkFast(contract, rootIndex, networkArray, networkName) {
            console.log(`üîÑ Traversing ${networkName} starting from index:`, rootIndex.toString());
            
            const queue = [rootIndex];
            const visited = new Set();
            let maxDepth = 0;
            // No node limit - render unlimited tree
            
            while (queue.length > 0) {
                const currentIndex = queue.shift();
                
                if (visited.has(currentIndex.toString())) continue;
                visited.add(currentIndex.toString());
                
                // Add current node to network
                networkArray.push({
                    index: currentIndex.toString(),
                    depth: maxDepth,
                    expanded: false,
                    children: []
                });
                
                // Get children for current node
                try {
                    const children = await getNodeChildrenFast(contract, currentIndex);
                    
                    if (children && children.length > 0) {
                        // Add children to queue for next level
                        queue.push(...children);
                        maxDepth++;
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Could not get children for index ${currentIndex}:`, error);
                    // Continue with next node
                }
                
                // Small delay to prevent overwhelming the contract
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            console.log(`‚úÖ ${networkName} traversal completed: ${networkArray.length} nodes`);
        }

        // Fast method to get node children
        async function getNodeChildrenFast(contract, nodeIndex) {
            try {
                // Convert index to address
                const nodeAddress = await window.getAddressByIndex(contract, nodeIndex);
                if (!nodeAddress || nodeAddress === '0x0000000000000000000000000000000000000000') {
                    return [];
                }
                
                // Get user tree
                const userTree = await contract.getUserTree(nodeAddress);
                const leftAddress = userTree[0];
                const rightAddress = userTree[1];
                const activated = userTree[2];
                
                const children = [];
                
                if (activated) {
                    if (leftAddress && leftAddress !== '0x0000000000000000000000000000000000000000') {
                        const leftIndex = await window.getIndexByAddress(contract, leftAddress);
                        if (leftIndex && leftIndex > 0n) {
                            children.push(leftIndex);
                        }
                    }
                    
                    if (rightAddress && rightAddress !== '0x0000000000000000000000000000000000000000') {
                        const rightIndex = await window.getIndexByAddress(contract, rightAddress);
                        if (rightIndex && rightIndex > 0n) {
                            children.push(rightIndex);
                        }
                    }
                }
                
                return children;
            } catch (error) {
                console.warn(`‚ö†Ô∏è Error getting children for index ${nodeIndex}:`, error);
                return [];
            }
        }

        // Render network in a specific column
        function renderNetworkInColumn(container, networkData, networkName, networkNumber) {
            console.log(`üîÑ Rendering ${networkName}:`, networkData.length, 'nodes');
            
            if (networkData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #a0aec0; padding: 2rem;">No data available</div>';
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Add network stats
            const statsDiv = document.createElement('div');
            statsDiv.style.cssText = `
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                padding: 0.5rem;
                margin-bottom: 1rem;
                text-align: center;
                font-size: 0.9em;
                color: #00ff88;
            `;
            statsDiv.innerHTML = `üìä ${networkData.length} nodes found`;
            container.appendChild(statsDiv);
            
            // Render all nodes in the network
            networkData.forEach((node, index) => {
                const networkItem = createNetworkItem(node, networkName, networkNumber);
                container.appendChild(networkItem);
            });
            
            // Add expand button for manual expansion if needed
            const expandButton = document.createElement('button');
            expandButton.style.cssText = `
                width: 100%;
                background: linear-gradient(45deg, #00ff88, #00cc6a);
                color: #1a202c;
            border: none;
                padding: 0.5rem;
                border-radius: 6px;
                font-weight: 600;
            cursor: pointer;
                            margin-top: 1rem;
                transition: all 0.3s ease;
            `;
            expandButton.innerHTML = 'üîÑ Expand More';
            expandButton.onclick = () => expandNetworkManually(networkNumber, networkData);
            container.appendChild(expandButton);
        }

        // Manual expansion for a network
        async function expandNetworkManually(networkNumber, currentNetworkData) {
            console.log(`üîÑ Manual expansion for Network ${networkNumber}`);
            
            const container = document.getElementById(`network-${networkNumber}-list`);
            if (!container) return;
            
            // Show loading
            const expandButton = container.querySelector('button');
            if (expandButton) {
                expandButton.innerHTML = 'üîÑ Expanding...';
                expandButton.disabled = true;
            }
            
            try {
                // Get more nodes for this network
                const newNodes = await getMoreNodesForNetwork(networkNumber, currentNetworkData);
                
                if (newNodes.length > 0) {
                    // Add new nodes to the network
                    newNodes.forEach(node => {
                        const networkItem = createNetworkItem(node, `Network ${networkNumber}`, networkNumber);
                        container.insertBefore(networkItem, expandButton);
                    });
                    
                    // Update stats
                    const statsDiv = container.querySelector('div');
                    if (statsDiv) {
                        const totalNodes = currentNetworkData.length + newNodes.length;
                        statsDiv.innerHTML = `üìä ${totalNodes} nodes found`;
                    }
                }
                
            } catch (error) {
                console.error(`‚ùå Error expanding Network ${networkNumber}:`, error);
            } finally {
                // Reset button
                if (expandButton) {
                    expandButton.innerHTML = 'üîÑ Expand More';
                    expandButton.disabled = false;
                }
            }
        }

        // Get more nodes for a specific network
        async function getMoreNodesForNetwork(networkNumber, currentNetworkData) {
            // This is a simplified version - in reality, you'd implement more sophisticated expansion logic
            const newNodes = [];
            
            // For now, just return some dummy data or implement based on your specific needs
            console.log(`üì° Getting more nodes for Network ${networkNumber}`);
            
            return newNodes;
        }

        // Create a network item for the list
        function createNetworkItem(node, networkName, networkNumber) {
            const networkItem = document.createElement('div');
            networkItem.className = 'network-item';
            
            // Determine odd/even for styling
            const nodeIndex = parseInt(node.index);
            networkItem.classList.add(nodeIndex % 2 === 0 ? 'even' : 'odd');
            
            // Create expand button (for manual expansion)
            const expandBtn = document.createElement('button');
            expandBtn.className = 'expand-btn';
            expandBtn.textContent = '‚ñ∂';
            expandBtn.onclick = () => expandNodeManually(node, networkNumber);
            
            // Create index display
            const indexDisplay = document.createElement('span');
            indexDisplay.className = 'index-display';
            indexDisplay.textContent = node.index;
            indexDisplay.style.cursor = 'pointer';
            indexDisplay.onclick = (e) => {
                e.stopPropagation();
                showUserPopup(node);
            };
            
            // Create depth indicator
            const depthIndicator = document.createElement('span');
            depthIndicator.style.cssText = `
                font-size: 0.7em;
                color: #a0aec0;
                margin-left: 0.5rem;
                background: rgba(0, 0, 0, 0.3);
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
            `;
            depthIndicator.textContent = `D${node.depth || 0}`;
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'pyramid-button';
            buttonContainer.appendChild(expandBtn);
            buttonContainer.appendChild(indexDisplay);
            buttonContainer.appendChild(depthIndicator);
            
            networkItem.appendChild(buttonContainer);
            
            return networkItem;
        }

        // Manual expansion for a specific node
        async function expandNodeManually(node, networkNumber) {
            console.log(`üîÑ Manual expansion for node ${node.index} in Network ${networkNumber}`);
            
            try {
                if (!window.contractConfig || !window.contractConfig.contract) {
                    throw new Error('Contract not available');
                }

                const contract = window.contractConfig.contract;
                
                // Get children for this node
                const children = await getNodeChildrenFast(contract, BigInt(node.index));
                
                if (children && children.length > 0) {
                    // Add children to the network
                    const container = document.getElementById(`network-${networkNumber}-list`);
                            if (container) {
                        children.forEach((childIndex, index) => {
                            const childNode = {
                                index: childIndex.toString(),
                                depth: (node.depth || 0) + 1,
                                expanded: false,
                                children: []
                            };
                            
                            const childItem = createNetworkItem(childNode, `Network ${networkNumber}`, networkNumber);
                            
                            // Insert after the current node
                            const currentItem = container.querySelector(`[data-node-index="${node.index}"]`);
                            if (currentItem) {
                                currentItem.insertAdjacentElement('afterend', childItem);
                            } else {
                                container.appendChild(childItem);
                            }
                        });
                            }
                        }
                        
                    } catch (error) {
                console.error(`‚ùå Error expanding node ${node.index}:`, error);
            }
        }





        // Load real data and render tree
        async function loadRealDataAndRender() {
            try {
                console.log('üîÑ Loading real wallet data...');
                

                
                // Check if wallet is connected
                if (!window.contractConfig || !window.contractConfig.contract) {
                    console.log('‚ö†Ô∏è Wallet not connected, using default data');
                    renderPyramidTree();
                    return;
                }
                
                // Get real wallet data
                const realData = await getRealWalletData();
                if (realData) {
                    console.log('‚úÖ Real data loaded, rendering tree...');
                    
                    // Update button state after successful data load
                    const connectBtn = document.getElementById('connect-wallet-btn');
                    if (connectBtn && window.contractConfig && window.contractConfig.userAddress) {
                        const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                        connectBtn.className = 'connect-wallet-btn modern-btn connected';
                        connectBtn.textContent = `‚úÖ ${shortAddress}`;
                    }
                    
                    renderPyramidTree();
                } else {
                    console.log('‚ö†Ô∏è Could not load real data, using default data');
                    
                    // Update button state for failed data load
                    const connectBtn = document.getElementById('connect-wallet-btn');
                    if (connectBtn) {
                        connectBtn.className = 'connect-wallet-btn modern-btn error';
                        connectBtn.textContent = '‚ö†Ô∏è Data Load Failed';
                        setTimeout(() => {
                            if (window.contractConfig && window.contractConfig.userAddress) {
                                const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                                connectBtn.className = 'connect-wallet-btn modern-btn connected';
                                connectBtn.textContent = `‚úÖ ${shortAddress}`;
                            } else {
                                connectBtn.className = 'connect-wallet-btn modern-btn';
                                connectBtn.textContent = 'üîó Connect Wallet';
                            }
                        }, 3000);
                    }
                    
                    renderPyramidTree();
                }

            } catch (error) {
                console.error('‚ùå Error loading real data:', error);
                console.log('‚ö†Ô∏è Using default data');
                renderPyramidTree();
            }
        }
        
        // Simple connect wallet function
        async function simpleConnectWallet() {
            try {
                console.log('üîó Simple wallet connection...');
                
                // Check if MetaMask is available
                if (!window.ethereum) {
                    console.log('‚ùå MetaMask not detected');
                    alert('Please install MetaMask to connect your wallet');
                    return false;
                }
                
                // Request account access
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts && accounts.length > 0) {
                    console.log('‚úÖ Wallet connected:', accounts[0]);
                    
                    // Set up contract config
                    if (!window.contractConfig) {
                        window.contractConfig = {};
                    }
                    window.contractConfig.userAddress = accounts[0];
                    
                    // Try to create contract if we have the address and ABI
                    if (window.IAM_ADDRESS && window.IAM_ABI) {
                        try {
                            const provider = new ethers.BrowserProvider(window.ethereum);
                            const signer = await provider.getSigner();
                            window.contractConfig.contract = new ethers.Contract(
                                window.IAM_ADDRESS,
                                window.IAM_ABI,
                                signer
                            );
                            window.contractConfig.contractAddress = window.IAM_ADDRESS;
                            window.contractConfig.contractABI = window.IAM_ABI;
                            console.log('‚úÖ Contract created successfully');
                        } catch (contractError) {
                            console.log('‚ö†Ô∏è Contract creation failed:', contractError.message);
                        }
                    } else {
                        console.log('‚ö†Ô∏è IAM_ADDRESS or IAM_ABI not available, using fallback');
                        // Use fallback contract address if available
                        const fallbackAddress = '0x2D3923A5ba62B2bec13b9181B1E9AE0ea2C8118D'; // IAM contract address
                        if (fallbackAddress && (window.IAM_ABI || window.CONTRACT_ABI)) {
                            try {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                const abi = window.IAM_ABI || window.CONTRACT_ABI;
                                window.contractConfig.contract = new ethers.Contract(
                                    fallbackAddress,
                                    abi,
                                    signer
                                );
                                window.contractConfig.contractAddress = fallbackAddress;
                                window.contractConfig.contractABI = abi;
                                console.log('‚úÖ Fallback contract created successfully');
                            } catch (contractError) {
                                console.log('‚ö†Ô∏è Fallback contract creation failed:', contractError.message);
                            }
                        }
                    }
                    
                    return true;
                } else {
                    console.log('‚ùå No accounts returned');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error connecting wallet:', error);
                if (error.code === 4001) {
                    console.log('üë§ User rejected connection');
                }
                return false;
            }
        }

        // Connect wallet button functionality
        function setupConnectWalletButton() {
            const connectBtn = document.getElementById('connect-wallet-btn');
            if (!connectBtn) {
                console.log('‚ùå Connect wallet button not found');
                return;
            }
            
            console.log('‚úÖ Connect wallet button found, setting up...');
            
            // Update button state
            function updateButtonState(state, text) {
                connectBtn.className = `connect-wallet-btn modern-btn ${state}`;
                connectBtn.textContent = text;
            }
            
            // Check initial connection state
            function checkConnectionState() {
                if (window.contractConfig && window.contractConfig.userAddress) {
                    const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                    updateButtonState('connected', `‚úÖ ${shortAddress}`);
                } else if (window.ethereum && window.ethereum.selectedAddress) {
                    const shortAddress = window.ethereum.selectedAddress.slice(0, 6) + '...' + window.ethereum.selectedAddress.slice(-4);
                    updateButtonState('connected', `‚úÖ ${shortAddress}`);
                } else {
                    updateButtonState('', 'üîó Connect Wallet');
                }
            }
            
            // Update button state during auto-connection
            function updateButtonForAutoConnection() {
                updateButtonState('connecting', 'üîÑ Auto-Connecting...');
            }
            
            // Connect wallet function
            async function connectWallet() {
                try {
                    console.log('üîÑ Connect wallet button clicked');
                    updateButtonState('connecting', 'üîÑ Connecting...');
                    
                    const success = await simpleConnectWallet();
                    
                    if (success) {
                        checkConnectionState();
                        console.log('‚úÖ Wallet connected successfully via button');
                        
                        // Try to render the tree with real data
                        try {
                            renderPyramidTree();
                        } catch (renderError) {
                            console.log('‚ö†Ô∏è Tree render failed:', renderError.message);
                        }
                    } else {
                        updateButtonState('error', '‚ùå Connection Failed');
                        setTimeout(() => {
                            checkConnectionState();
                        }, 3000);
                    }
                } catch (error) {
                    console.error('‚ùå Error connecting wallet:', error);
                    updateButtonState('error', '‚ùå Error');
                    setTimeout(() => {
                        checkConnectionState();
                    }, 3000);
                }
            }
            
            // Add click event listener
            connectBtn.addEventListener('click', connectWallet);
            console.log('‚úÖ Click event listener added');
            
            // Check connection state on load
            checkConnectionState();
            
            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    console.log('üîÑ Account changed, updating button state');
                    checkConnectionState();
                });
                
                window.ethereum.on('chainChanged', () => {
                    console.log('üîÑ Chain changed, updating button state');
                    checkConnectionState();
                });
            }
        }
        
        // Show auto-connection status
        function showAutoConnectionStatus() {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'auto-connection-status';
            statusDiv.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: rgba(0, 255, 136, 0.1);
                border: 1px solid rgba(0, 255, 136, 0.3);
                border-radius: 8px;
                padding: 10px 15px;
                color: #00ff88;
                font-size: 12px;
                z-index: 999;
                backdrop-filter: blur(10px);
                max-width: 200px;
            `;
            statusDiv.textContent = 'üîÑ Auto-connecting to wallet...';
            document.body.appendChild(statusDiv);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Pyramid Tree page loaded');
            
            // Show auto-connection status
            showAutoConnectionStatus();
            
            // Debug wallet connection
            console.log('üîç Debug Wallet Connection:');
            console.log('- window.ethereum:', !!window.ethereum);
            console.log('- window.IAM_ADDRESS:', window.IAM_ADDRESS);
            console.log('- window.IAM_ABI:', !!window.IAM_ABI);
            console.log('- window.contractConfig:', !!window.contractConfig);
            console.log('- window.connectWallet:', !!window.connectWallet);
            
            // Setup connect wallet button
            setupConnectWalletButton();
            
            // Test function for debugging
            window.testConnectWallet = async function() {
                console.log('üß™ Testing connect wallet...');
                const result = await simpleConnectWallet();
                console.log('üß™ Test result:', result);
                return result;
            };
            
            // Make functions globally available for debugging
            window.simpleConnectWallet = simpleConnectWallet;
            window.setupConnectWalletButton = setupConnectWalletButton;
            
            // Wait for scripts to load and try multiple times
            let attempts = 0;
            const maxAttempts = 5;
            
            const tryConnectWallet = async () => {
                attempts++;
                console.log(`üîÑ Attempt ${attempts}/${maxAttempts} to auto-connect wallet...`);
                
                try {
                    // Check if MetaMask is available
                    if (!window.ethereum) {
                        if (attempts < maxAttempts) {
                            console.log('‚è≥ MetaMask not detected, waiting...');
                            setTimeout(tryConnectWallet, 1000);
                            return;
                        } else {
                            console.log('‚ùå MetaMask not available after max attempts');
                            renderPyramidTree();
                            return;
                        }
                    }
                    
                    // Check if already connected
                    if (window.ethereum.selectedAddress) {
                        console.log('‚úÖ Wallet already connected:', window.ethereum.selectedAddress);
                        
                        // Set up contract config
                        if (!window.contractConfig) {
                            window.contractConfig = {};
                        }
                        window.contractConfig.userAddress = window.ethereum.selectedAddress;
                        
                        // Try to create contract
                        if (window.IAM_ADDRESS && (window.IAM_ABI || window.CONTRACT_ABI)) {
                            try {
                                const provider = new ethers.BrowserProvider(window.ethereum);
                                const signer = await provider.getSigner();
                                const abi = window.IAM_ABI || window.CONTRACT_ABI;
                                window.contractConfig.contract = new ethers.Contract(
                                    window.IAM_ADDRESS,
                                    abi,
                                    signer
                                );
                                window.contractConfig.contractAddress = window.IAM_ADDRESS;
                                window.contractConfig.contractABI = abi;
                                console.log('‚úÖ Contract created for auto-connection');
                            } catch (contractError) {
                                console.log('‚ö†Ô∏è Contract creation failed:', contractError.message);
                            }
                        }
                        
                        console.log('‚úÖ Auto-connection successful, loading real data...');
                        
                        // Update button state
                        if (connectBtn) {
                            const shortAddress = window.ethereum.selectedAddress.slice(0, 6) + '...' + window.ethereum.selectedAddress.slice(-4);
                            connectBtn.className = 'connect-wallet-btn modern-btn connected';
                            connectBtn.textContent = `‚úÖ ${shortAddress}`;
                        }
                        
                        await loadRealDataAndRender();
                        return;
                    }
                    
                    // Try to connect using simple method
                    const walletConnected = await simpleConnectWallet();
                    
                    if (walletConnected) {
                        console.log('‚úÖ Auto-connection successful, loading real data...');
                        
                        // Update button state
                        if (connectBtn && window.contractConfig && window.contractConfig.userAddress) {
                            const shortAddress = window.contractConfig.userAddress.slice(0, 6) + '...' + window.contractConfig.userAddress.slice(-4);
                            connectBtn.className = 'connect-wallet-btn modern-btn connected';
                            connectBtn.textContent = `‚úÖ ${shortAddress}`;
                        }
                        
                        await loadRealDataAndRender();
                    } else {
                        console.log('‚ö†Ô∏è Auto-connection failed, showing default data');
                        
                        // Update button state
                        if (connectBtn) {
                            connectBtn.className = 'connect-wallet-btn modern-btn';
                            connectBtn.textContent = 'üîó Connect Wallet';
                        }
                        
                        renderPyramidTree();
                    }
            } catch (error) {
                    console.error(`‚ùå Error in auto-connection attempt ${attempts}:`, error);
                    if (attempts < maxAttempts) {
                        setTimeout(tryConnectWallet, 1000);
                    } else {
                        console.log('‚ùå Max auto-connection attempts reached, showing default data');
                        renderPyramidTree();
                    }
                }
            };
            
            // Debug MetaMask detection
            console.log('üîç Debug MetaMask Detection:');
            console.log('- window.ethereum:', !!window.ethereum);
            console.log('- window.web3:', !!window.web3);
            console.log('- window.web3.currentProvider:', !!window.web3?.currentProvider);
            console.log('- isMobile():', isMobile());
            console.log('- User Agent:', navigator.userAgent);
            console.log('- Screen width:', window.innerWidth);
            
            // Update button state for auto-connection
            const connectBtn = document.getElementById('connect-wallet-btn');
            if (connectBtn) {
                connectBtn.className = 'connect-wallet-btn modern-btn connecting';
                connectBtn.textContent = 'üîÑ Auto-Connecting...';
            }
            
            // Start trying to connect
            setTimeout(tryConnectWallet, 200);
            
            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', async (accounts) => {
                    console.log('üîÑ Account changed:', accounts);
                    if (accounts && accounts.length > 0) {
                        if (window.contractConfig) {
                            window.contractConfig.userAddress = accounts[0];
                        }
                        await loadRealDataAndRender();
                    } else {
                        renderPyramidTree();
                    }
                });
                
                window.ethereum.on('chainChanged', () => {
                    console.log('üîÑ Chain changed, reloading...');
                    window.location.reload();
                });
            }
        });
    </script>
    
    <!-- Floating Token Growth Card -->
    <script src="js/floating-token-card.js"></script>
    
    <!-- Mobile User Popup -->
    <script>
        // Check if mobile-user-popup is already loaded
        if (!window.mobileUserPopup) {
            // Load the script dynamically to avoid duplicate loading
            const script = document.createElement('script');
            script.src = 'js/mobile-user-popup.js';
            script.onload = function() {
                console.log('‚úÖ Mobile user popup loaded successfully');
            };
            script.onerror = function() {
                console.warn('‚ö†Ô∏è Failed to load mobile user popup');
            };
            document.head.appendChild(script);
        } else {
            console.log('‚úÖ Mobile user popup already loaded');
        }
    </script>
</body>
</html> 