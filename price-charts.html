<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Price Charts | PHOENIX (IAM)</title>
  
  <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
  
  <!-- Load ethers.js version 6 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.umd.min.js"></script>
  
  <!-- Main scripts -->
  <script src="js/index.js"></script>
  <script src="js/config.js"></script>
  <script src="js/auto-wallet-connect.js"></script>
  <script src="js/neon-api-service.js"></script>
  <script src="browser-price-service.js"></script>
  
  <style>
    body {
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #2d3748 100%);
      color: #e2e8f0;
      font-family: 'Noto Sans Arabic', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    
    .back-btn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      color: #181c2a;
      text-decoration: none;
      padding: 0.7rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(167, 134, 255, 0.3);
    }
    
    .back-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(167, 134, 255, 0.4);
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      padding-top: 4rem;
    }
    
    .page-header {
      text-align: center;
      margin-bottom: 3rem;
    }
    
    .page-title {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }
    
    .page-subtitle {
      font-size: 1.1rem;
      color: #94a3b8;
      margin-bottom: 2rem;
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    
    @media (max-width: 768px) {
    .charts-grid {
      grid-template-columns: 1fr;
        gap: 1.5rem;
      }
    }
    
    .chart-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 1.5rem;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .chart-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.3rem;
      font-weight: 600;
      color: #e2e8f0;
      margin: 0;
    }
    
    .chart-icon {
      font-size: 1.5rem;
    }
    
    .chart-stats {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }
    
    .stat-item {
      text-align: center;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .stat-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #00ff88;
      margin-bottom: 0.25rem;
    }
    
    .stat-label {
      font-size: 0.8rem;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
    }
    
    .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Token chart specific styling for low prices */
    #tokenChart {
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 136, 0.02) 100%);
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
    
    /* Point chart specific styling */
    #pointChart {
      background: linear-gradient(135deg, rgba(167, 134, 255, 0.05) 0%, rgba(167, 134, 255, 0.02) 100%);
      border-radius: 8px;
      border: 1px solid rgba(167, 134, 255, 0.2);
    }
    
    /* Chart tooltip styling */
    .chartjs-tooltip {
      background: rgba(0, 0, 0, 0.9) !important;
      border: 1px solid #00ff88 !important;
      border-radius: 6px !important;
      box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3) !important;
    }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 1.1rem;
      color: #94a3b8;
    }
    
    .error {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #ff6b6b;
      text-align: center;
      flex-direction: column;
      gap: 1rem;
    }
    
    .error-icon {
      font-size: 3rem;
    }
    
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }
    
    .status-online {
      background: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }
    
    .status-offline {
      background: #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
    }
    
    .status-warning {
      background: #ffa726;
      box-shadow: 0 0 10px rgba(255, 167, 38, 0.5);
    }
  </style>
</head>

<body>
  <a href="index.html" class="back-btn">‚Üê Back to Home</a>
  
  <div class="container">
    <div class="page-header">
      <h1 class="page-title">Price Charts</h1>
      <p class="page-subtitle">Real-time IAM Token and Point Price Analysis</p>
      <button onclick="testCharts()" style="background: #00ff88; color: #181c2a; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">Test Charts</button>
    </div>

    
    <div class="charts-grid">
      <!-- Point Price Chart -->
      <div class="chart-card">
        <div class="chart-header">
          <h3 class="chart-title">
            <span class="chart-icon">‚≠ê</span>
            Point Price Chart
          </h3>
          <div class="chart-stats" id="pointStats">
            <div class="stat-item">
              <div class="stat-value current-price" id="currentPointPrice">$0.00</div>
              <div class="stat-label">Current Price</div>
            </div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="pointChart"></canvas>
        </div>
      </div>

      <!-- Token Price Chart -->
      <div class="chart-card">
        <div class="chart-header">
          <h3 class="chart-title">
            <span class="chart-icon">üí∞</span>
            Token Price Chart
          </h3>
          <div class="chart-stats" id="tokenStats">
            <div class="stat-item">
              <div class="stat-value current-price" id="currentTokenPrice">Loading...</div>
              <div class="stat-label">Current Price</div>
            </div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="tokenChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let priceService = null;
    let tokenChart = null;
    let pointChart = null;
    let refreshInterval = null;
    
    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üöÄ Initializing Price Charts...');
      console.log('üìä Chart.js available:', typeof Chart !== 'undefined');
      
      // Auto test charts after 2 seconds
        setTimeout(() => {
        console.log('üß™ Auto-testing charts...');
        testCharts();
      }, 2000);
      
      try {
        // Initialize price service
        priceService = new BrowserPriceService();
        await priceService.connectToDatabase();
        await priceService.connectToContract();
        
        // Load charts automatically
        await loadCharts();
        
        // Start real-time updates automatically
        startRealTimeAutoRefresh();
        
        console.log('‚úÖ Price Charts initialized successfully - Auto mode enabled');
        
      } catch (error) {
        console.error('‚ùå Error initializing Price Charts:', error);
        showError('Failed to initialize charts. Please refresh the page.');
      }
    });
    
    // Load charts with real data
    async function loadCharts() {
      try {
        console.log('üîÑ Loading charts...');
        
        // Ensure canvas elements exist
        const tokenCanvas = document.getElementById('tokenChart');
        const pointCanvas = document.getElementById('pointChart');
        
        if (!tokenCanvas || !pointCanvas) {
          console.error('‚ùå Canvas elements not found');
          return;
        }
        
        console.log('‚úÖ Canvas elements ready');
        
        // Load charts directly from database
        console.log('üîÑ Loading charts from database...');
        
        // First, clear database and create initial data
        await clearDatabaseAndCreateInitial();
        
        // Then save current blockchain data to database
        await saveCurrentBlockchainData();
        
        // Load token chart from database
        await loadTokenChartFromDatabase();
        
        // Load point chart from database
        await loadPointChartFromDatabase();
        
        console.log('‚úÖ Charts loaded successfully');
        
      } catch (error) {
        console.error('‚ùå Error loading charts:', error);
        // Auto-retry after 5 seconds
        setTimeout(() => {
          console.log('üîÑ Auto-retrying chart load...');
          loadCharts();
        }, 5000);
      }
    }
    
    // Load token chart
    async function loadTokenChart() {
      try {
        console.log('üîÑ Loading token chart...');
        
        const canvas = document.getElementById('tokenChart');
        if (!canvas) return;
        
        // Get latest token price
        const latestPrice = await priceService.getLatestTokenPrice('IAM');
          console.log('üìä Latest token price:', latestPrice);
        
        if (!latestPrice || !latestPrice.price_usd) {
          console.warn('‚ö†Ô∏è No valid token price data, using fallback');
          // Use fallback data
          const fallbackPrice = {
            price_usd: '1.28e-15',
            total_supply: '4579431465023559287516108250615514281',
            symbol: 'IAM',
            name: 'IAM Token'
          };
          updateTokenStats(fallbackPrice);
          return;
        }
        
        // Update stats
        updateTokenStats(latestPrice);
        
        // Generate real-time history
        const history = await priceService.generateRealTimeHistory('token', 'IAM', 24);
        console.log('üìä Token history loaded:', history.length, 'points');
        
        // Create chart
        createTokenChart(canvas, history);
        
      } catch (error) {
        console.error('‚ùå Error loading token chart:', error);
        showChartError(document.getElementById('tokenChart'), 'Failed to load token chart');
      }
    }
    
    // Load point chart
    async function loadPointChart() {
      try {
        console.log('üîÑ Loading point chart...');
        
        const canvas = document.getElementById('pointChart');
        if (!canvas) return;
        
        // Get latest point price
        const latestPrice = await priceService.getLatestPointPrice('binary_points');
          console.log('üìä Latest point price:', latestPrice);
        
        if (!latestPrice || !latestPrice.point_value_usd) {
          console.warn('‚ö†Ô∏è No valid point price data, using fallback');
          // Use fallback data
          const fallbackPrice = {
            point_value_usd: '15.63',
            point_value_iam: '12182186011218572.00',
            point_type: 'binary_points'
          };
          updatePointStats(fallbackPrice);
          return;
        }
        
        // Update stats
        updatePointStats(latestPrice);
        
        // Generate real-time history
        const history = await priceService.generateRealTimeHistory('point', 'binary_points', 24);
        console.log('üìä Point history loaded:', history.length, 'points');
        
        // Create chart
        createPointChart(canvas, history);
        
      } catch (error) {
        console.error('‚ùå Error loading point chart:', error);
        showChartError(document.getElementById('pointChart'), 'Failed to load point chart');
      }
    }
    
    // Get prices from floating-token-card
    async function getPricesFromFloatingCard() {
      try {
        // Check if floating token card exists
        if (window.floatingTokenGrowthCard && typeof window.floatingTokenGrowthCard.getTokenGrowthData === 'function') {
          const data = await window.floatingTokenGrowthCard.getTokenGrowthData();
          console.log('üìä Prices from floating-token-card:', data);
          return data;
        }
        
        // Fallback: try to get from priceHistoryManager
        if (window.priceHistoryManager && window.priceHistoryManager.tokenHistory.length > 0) {
          const tokenHistory = window.priceHistoryManager.tokenHistory;
          const currentPrice = tokenHistory[tokenHistory.length - 1];
          const initialPrice = 1e-15; // Default from floating-token-card
          
          return {
            currentPrice: currentPrice,
            initialPrice: initialPrice,
            growthPercentage: ((currentPrice - initialPrice) / initialPrice) * 100,
            source: 'priceHistoryManager'
          };
        }
        
        return null;
      } catch (error) {
        console.error('‚ùå Error getting prices from floating-token-card:', error);
        return null;
      }
    }

    // Clear database and save prices from floating-token-card
    async function savePricesToNeon(initialPrice, currentPrice) {
      try {
        console.log('üíæ Clearing database and saving prices from floating-token-card:', {
          initialPrice: initialPrice,
          currentPrice: currentPrice
        });

        // First, clear all existing records
        console.log('üóëÔ∏è Clearing existing database records...');
        const clearResponse = await fetch('/api/clear-database', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });

        if (clearResponse.ok) {
          console.log('‚úÖ Database cleared successfully');
        } else {
          console.warn('‚ö†Ô∏è Failed to clear database, continuing...');
        }

        // Save initial price (25 days ago) as first record
        const initialDate = new Date();
        initialDate.setDate(initialDate.getDate() - 25);
        
        const initialPriceData = {
          symbol: 'IAM',
          name: 'IAM Token',
          price_usd: initialPrice.toString(),
          price_dai: initialPrice.toString(),
          market_cap: (initialPrice * 1000000000).toString(),
          total_supply: '1000000000',
          created_at: initialDate.toISOString()
        };

        console.log('üíæ Saving initial price (first record):', initialPriceData);

        // Save initial price to database
        const initialResponse = await fetch('/api/token-prices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(initialPriceData)
        });

        if (initialResponse.ok) {
          console.log('‚úÖ Initial price saved as first record');
              } else {
          console.error('‚ùå Failed to save initial price');
        }

        // Save current price (now) as second record
        const currentPriceData = {
          symbol: 'IAM',
          name: 'IAM Token',
          price_usd: currentPrice.toString(),
          price_dai: currentPrice.toString(),
          market_cap: (currentPrice * 1000000000).toString(),
          total_supply: '1000000000',
          created_at: new Date().toISOString()
        };

        console.log('üíæ Saving current price (second record):', currentPriceData);

        // Save current price to database
        const currentResponse = await fetch('/api/token-prices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(currentPriceData)
        });

        if (currentResponse.ok) {
          console.log('‚úÖ Current price saved as second record');
          } else {
          console.error('‚ùå Failed to save current price');
        }

        // Generate additional historical data points for better chart visualization
        console.log('üìä Generating additional historical data points...');
        const additionalPoints = 4; // Generate 4 more points
        const timeDiff = (new Date() - initialDate) / (additionalPoints + 1);
        
        for (let i = 1; i <= additionalPoints; i++) {
          const pointDate = new Date(initialDate.getTime() + (timeDiff * i));
          const progress = i / (additionalPoints + 1);
          const pointPrice = initialPrice + (currentPrice - initialPrice) * progress;
          
          const pointData = {
            symbol: 'IAM',
            name: 'IAM Token',
            price_usd: pointPrice.toString(),
            price_dai: pointPrice.toString(),
            market_cap: (pointPrice * 1000000000).toString(),
            total_supply: '1000000000',
            created_at: pointDate.toISOString()
          };

          const pointResponse = await fetch('/api/token-prices', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(pointData)
          });

          if (pointResponse.ok) {
            console.log(`‚úÖ Historical point ${i} saved`);
          }
        }

        console.log('üéâ All prices saved successfully to Neon database');
        return true;
      } catch (error) {
        console.error('‚ùå Error saving prices to Neon:', error);
        return false;
      }
    }

    // Global variables for price comparison
    let lastTokenPrice = null;
    let lastPointPrice = null;
    let chartUpdateNeeded = false;

    // Update token stats with price comparison
    function updateTokenStats(priceData) {
      const priceElement = document.getElementById('currentTokenPrice');
      
      if (priceElement) {
        const price = parseFloat(priceData.price_usd || priceData.priceUsd || 0);
        if (isNaN(price)) {
          priceElement.textContent = 'Loading...';
        } else {
          // Get prices from floating-token-card
          getPricesFromFloatingCard().then(floatingData => {
            if (floatingData) {
              const currentPrice = floatingData.currentPrice;
              
              // Check if price has changed significantly (more than 0.1%)
              const priceChanged = !lastTokenPrice || 
                Math.abs(currentPrice - lastTokenPrice) / lastTokenPrice > 0.001;
              
              if (priceChanged) {
                console.log('üìä Price changed, updating chart:', {
                  lastPrice: lastTokenPrice ? lastTokenPrice.toExponential(6) : 'None',
                  currentPrice: currentPrice.toExponential(6),
                  changePercent: lastTokenPrice ? 
                    ((currentPrice - lastTokenPrice) / lastTokenPrice * 100).toFixed(4) + '%' : 'N/A'
                });
                
                // Update last price
                lastTokenPrice = currentPrice;
                chartUpdateNeeded = true;
                
                // Save to Neon database only if price changed
                savePricesToNeon(floatingData.initialPrice, currentPrice);
                
                // Use floating-token-card prices
                const initialPrice = floatingData.initialPrice;
                const percentageChange = floatingData.growthPercentage;
                
                // Format price display
                const priceInWei = (currentPrice * 1e18).toFixed(0);
                const priceScientific = currentPrice.toExponential(6);
                const priceUSD = currentPrice.toExponential(2);
                
                // Update price display
                priceElement.innerHTML = `
                  <div style="color: #ffffff; font-size: 1.2em; font-weight: bold;">${priceScientific}</div>
                  <div style="color: #00ff88; font-size: 0.9em; margin-top: 4px;">USD: $${priceUSD}</div>
                  <div style="color: #888; font-size: 0.8em; margin-top: 2px;">Wei: ${priceInWei}</div>
                  <div style="color: #00ff88; font-size: 0.7em; margin-top: 2px;">From Floating Card</div>
                `;
                
                console.log('üìä Token stats updated from floating-token-card:', {
                  initialPrice: initialPrice.toExponential(6),
                  currentPrice: priceScientific,
                  priceInWei: priceInWei,
                  percentageChange: percentageChange.toFixed(2) + '%',
                  chartUpdateNeeded: chartUpdateNeeded
                });
              } else {
                console.log('üìä Price unchanged, skipping chart update:', {
                  currentPrice: currentPrice.toExponential(6),
                  lastPrice: lastTokenPrice.toExponential(6)
                });
            }
          } else {
              // Fallback to original logic
              const initialPrice = 10e-15;
              const currentPrice = price;
              const percentageChange = ((currentPrice - initialPrice) / initialPrice) * 100;
              
              // Check if price has changed
              const priceChanged = !lastTokenPrice || 
                Math.abs(currentPrice - lastTokenPrice) / lastTokenPrice > 0.001;
              
              if (priceChanged) {
                lastTokenPrice = currentPrice;
                chartUpdateNeeded = true;
                
                // Format price display
                const priceInWei = (currentPrice * 1e18).toFixed(0);
                const priceScientific = currentPrice.toExponential(6);
                const priceUSD = currentPrice.toExponential(2);
                
                // Update price display
                priceElement.innerHTML = `
                  <div style="color: #ffffff; font-size: 1.2em; font-weight: bold;">${priceScientific}</div>
                  <div style="color: #00ff88; font-size: 0.9em; margin-top: 4px;">USD: $${priceUSD}</div>
                  <div style="color: #888; font-size: 0.8em; margin-top: 2px;">Wei: ${priceInWei}</div>
                `;
              }
            }
          });
        }
      }
    }
    
    // Update point stats
    function updatePointStats(priceData) {
      const priceElement = document.getElementById('currentPointPrice');
      
      if (priceElement) {
        const price = parseFloat(priceData.point_value_usd || priceData.pointValueUsd || 0);
        if (isNaN(price)) {
          priceElement.textContent = '$0.00';
      } else {
          priceElement.textContent = `$${price.toFixed(2)}`;
        }
      }
    }
    
    // Create token chart
    function createTokenChart(canvas, history) {
      console.log('üîÑ Creating token chart with', history.length, 'data points');
      
      if (tokenChart) {
        tokenChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }

      const ctx = canvas.getContext('2d');

      // Use real data if available, otherwise generate sample data
      let labels = [];
      let prices = [];

      if (history && history.length > 0) {
        labels = history.map(item => {
          const date = new Date(item.created_at);
          return date.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit'
          });
        });
        prices = history.map(item => parseFloat(item.price_usd));
              } else {
        // Generate sample data
        labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
        prices = [1.2e-15, 1.3e-15, 1.1e-15, 1.4e-15, 1.25e-15, 1.35e-15];
      }

      // Calculate price range for better scaling
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const priceRange = maxPrice - minPrice;
      const centerPrice = (minPrice + maxPrice) / 2;

      console.log('üìä Price range:', {
        min: minPrice,
        max: maxPrice,
        range: priceRange,
        center: centerPrice,
        prices: prices
      });

      // If we have only one data point, create a range around it
      if (prices.length === 1) {
        const singlePrice = prices[0];
        const padding = singlePrice * 0.1; // 10% padding
        const adjustedMin = Math.max(0, singlePrice - padding);
        const adjustedMax = singlePrice + padding;
        
        console.log('üìä Single data point adjustment:', {
          original: singlePrice,
          adjustedMin: adjustedMin,
          adjustedMax: adjustedMax
        });
      }

      const data = {
          labels: labels,
          datasets: [{
          label: 'Token Price (USD)',
            data: prices,
            borderColor: '#00ff88',
            backgroundColor: 'rgba(0, 255, 136, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointRadius: 4,
          pointHoverRadius: 6,
          pointBackgroundColor: '#00ff88',
          pointBorderColor: '#ffffff',
          pointBorderWidth: 2
        }]
      };

      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#00ff88',
              borderColor: '#00ff88',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                    const value = parseFloat(context.raw);
                    return [
                      'Token Price: ' + value.toExponential(6),
                      'USD: $' + value.toExponential(3),
                      'Scientific: ' + value.toExponential(6),
                      'Percentage: ' + ((value / 1e-15) * 100).toFixed(2) + '% of 1e-15'
                    ];
                  },
                title: function(context) {
                  const date = new Date(context[0].label);
                  return date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                  });
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time',
                color: '#ffffff',
                font: {
                  size: 12
                }
              },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              }
            },
            y: {
              display: true,
                   title: {
                     display: true,
                     text: 'Price (Scientific)',
                     color: '#ffffff',
                     font: {
                       size: 12
                     }
                   },
              ticks: {
                color: '#ffffff',
                font: {
                  size: 10
                },
                callback: function(value) {
                  const val = parseFloat(value);
                  return val.toExponential(2);
                }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)',
                drawBorder: false
              },
              // Set min and max with some padding for better visualization
              min: prices.length === 1 ? 
                Math.max(0, minPrice - minPrice * 0.1) : 
                Math.max(0, minPrice - priceRange * 0.1),
              max: prices.length === 1 ? 
                maxPrice + maxPrice * 0.1 : 
                maxPrice + priceRange * 0.1
            }
          },
          elements: {
            line: {
              tension: 0.4
            }
          }
        }
      };

      try {
        tokenChart = new Chart(ctx, config);
        console.log('‚úÖ Token chart created with', prices.length, 'data points');
        console.log('üìä Chart configured for low prices:', {
          minPrice: minPrice,
          maxPrice: maxPrice,
          priceRange: priceRange
        });
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }
    
    // Create point chart
    function createPointChart(canvas, history) {
      console.log('üîÑ Creating point chart with', history.length, 'data points');
      
      if (pointChart) {
        pointChart.destroy();
      }
      
      if (!canvas) {
        console.error('‚ùå Canvas element not found');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      
      // Use real data if available, otherwise generate sample data
      let labels = [];
      let prices = [];
      
      if (history && history.length > 0) {
        labels = history.map(item => {
          const date = new Date(item.created_at);
          return date.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit' 
          });
        });
        prices = history.map(item => parseFloat(item.point_value_usd));
      } else {
        // Generate sample data
        labels = ['12:00', '14:00', '16:00', '18:00', '20:00', '22:00'];
        prices = [15.2, 15.8, 14.9, 16.1, 15.5, 16.3];
      }
      
      const data = {
          labels: labels,
          datasets: [{
          label: 'Point Price (USD)',
            data: prices,
            borderColor: '#a786ff',
            backgroundColor: 'rgba(167, 134, 255, 0.1)',
            borderWidth: 2,
            fill: true,
          tension: 0.4
        }]
      };
      
      const config = {
        type: 'line',
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return '$' + parseFloat(context.raw).toFixed(2);
                }
              }
            }
          },
          scales: {
            y: {
              ticks: {
                callback: function(value) {
                  return '$' + parseFloat(value).toFixed(2);
                }
              }
            }
          }
        }
      };
      
      try {
        pointChart = new Chart(ctx, config);
        console.log('‚úÖ Point chart created with', prices.length, 'data points');
      } catch (error) {
        console.error('‚ùå Chart error:', error);
      }
    }
    
    // Show chart error
    function showChartError(canvas, message) {
      if (!canvas) return;
      
      const container = canvas.parentElement;
      container.innerHTML = `
        <div class="error">
          <div class="error-icon">‚ö†Ô∏è</div>
          <div>${message}</div>
        </div>
      `;
    }
    
    // Show general error
    function showError(message) {
      const container = document.querySelector('.container');
      const errorDiv = document.createElement('div');
      errorDiv.className = 'chart-card';
      errorDiv.innerHTML = `
        <div class="error">
          <div class="error-icon">‚ùå</div>
          <div>${message}</div>
        </div>
      `;
      container.appendChild(errorDiv);
    }
    
    // Start real-time auto refresh with smart updates
    function startRealTimeAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
      
      // Auto-refresh every 30 seconds
      refreshInterval = setInterval(async () => {
        console.log('üîÑ Auto-refresh triggered...');
        
        try {
          // Get current prices from floating-token-card
          const floatingData = await getPricesFromFloatingCard();
          
          if (floatingData) {
            const currentPrice = floatingData.currentPrice;
            
            // Check if price has changed significantly
            const priceChanged = !lastTokenPrice || 
              Math.abs(currentPrice - lastTokenPrice) / lastTokenPrice > 0.001;
            
            if (priceChanged) {
              console.log('üìä Price changed, updating chart and database:', {
                lastPrice: lastTokenPrice ? lastTokenPrice.toExponential(6) : 'None',
                currentPrice: currentPrice.toExponential(6),
                changePercent: lastTokenPrice ? 
                  ((currentPrice - lastTokenPrice) / lastTokenPrice * 100).toFixed(4) + '%' : 'N/A'
              });
              
              // Update last price
              lastTokenPrice = currentPrice;
              
              // Save current blockchain data to database
              await saveCurrentBlockchainData();
              
              // Load charts from database
              await loadTokenChartFromDatabase();
              await loadPointChartFromDatabase();
              
              console.log('‚úÖ Chart updated due to price change');
            } else {
              console.log('üìä Price unchanged, skipping chart update:', {
                currentPrice: currentPrice.toExponential(6),
                lastPrice: lastTokenPrice.toExponential(6)
              });
            }
          } else {
            // Fallback: update charts anyway if floating data not available
            console.log('‚ö†Ô∏è Floating data not available, updating charts anyway');
            await saveCurrentBlockchainData();
            await loadTokenChartFromDatabase();
            await loadPointChartFromDatabase();
          }
        } catch (error) {
          console.error('‚ùå Error in auto-refresh:', error);
        }
      }, 30000); // 30 seconds
      
      console.log('‚úÖ Smart auto-refresh enabled: 30 seconds (only updates when price changes)');
      
      // Also start price service auto-update
      if (priceService) {
        priceService.startAutoUpdate(1); // Every 1 minute
      }
    }
    
    
    // Format number with commas
    function formatNumber(num) {
      if (isNaN(num) || num === null || num === undefined) {
        return '0';
      }
      return new Intl.NumberFormat('en-US').format(num);
    }
    
    // Test charts function
    function testCharts() {
      console.log('üß™ Testing charts...');
      
      const tokenCanvas = document.getElementById('tokenChart');
      const pointCanvas = document.getElementById('pointChart');
      
      console.log('Token canvas:', tokenCanvas);
      console.log('Point canvas:', pointCanvas);
      console.log('Chart.js available:', typeof Chart !== 'undefined');
      console.log('Window.Chart:', window.Chart);
      
      if (!tokenCanvas) {
        console.error('‚ùå Token canvas not found!');
        return;
      }
      
      if (!pointCanvas) {
        console.error('‚ùå Point canvas not found!');
        return;
      }
      
      if (typeof Chart === 'undefined') {
        console.error('‚ùå Chart.js not loaded!');
        return;
      }
      
      console.log('‚úÖ All elements found, loading real data...');
      
      // Load real data from API
      loadRealData();
    }
    
    // Load token chart from database
    async function loadTokenChartFromDatabase() {
      try {
        console.log('üîÑ Loading token chart from database...');
        const tokenCanvas = document.getElementById('tokenChart');
        
        // Load token data from API
        const tokenResponse = await fetch('http://localhost:3000/api/token-prices?symbol=IAM&hours=24');
        const tokenData = await tokenResponse.json();
        console.log('üìä Token data from database:', tokenData);
        
        if (tokenData.success && tokenData.data && tokenData.data.length > 0) {
          // Update stats with latest data
          const latestToken = tokenData.data[0];
          updateTokenStats(latestToken);
          
          // If we have only one data point, generate some historical data for better visualization
          if (tokenData.data.length === 1) {
            console.log('üìä Only one data point, generating historical data for better visualization');
            const basePrice = parseFloat(tokenData.data[0].price_usd);
            const historicalData = [];
            
            // Generate 6 data points over the last 6 hours
            for (let i = 5; i >= 0; i--) {
              const time = new Date();
              time.setHours(time.getHours() - i);
              
              // Add some variation to the price (¬±5%)
              const variation = (Math.random() - 0.5) * 0.1; // ¬±5% variation
              const variedPrice = basePrice * (1 + variation);
              
              historicalData.push({
                created_at: time.toISOString(),
                price_usd: variedPrice.toString(),
                symbol: 'IAM',
                name: 'IAM Token'
              });
            }
            
            createTokenChart(tokenCanvas, historicalData);
            console.log('‚úÖ Token chart created with generated historical data');
          } else {
            // Create chart with all data
            createTokenChart(tokenCanvas, tokenData.data);
            console.log('‚úÖ Token chart loaded from database with', tokenData.data.length, 'records');
        }
      } else {
          console.log('‚ö†Ô∏è No token data in database, using fallback');
          createTokenChart(tokenCanvas, []);
        }
        
      } catch (error) {
        console.error('‚ùå Error loading token chart from database:', error);
        const tokenCanvas = document.getElementById('tokenChart');
        createTokenChart(tokenCanvas, []);
      }
    }
    
    // Load point chart from database
    async function loadPointChartFromDatabase() {
      try {
        console.log('üîÑ Loading point chart from database...');
        const pointCanvas = document.getElementById('pointChart');
        
        // Load point data from API
        const pointResponse = await fetch('http://localhost:3000/api/point-prices?pointType=binary_points&hours=24');
        const pointData = await pointResponse.json();
        console.log('üìä Point data from database:', pointData);
        
        if (pointData.success && pointData.data && pointData.data.length > 0) {
          // Update stats with latest data
          const latestPoint = pointData.data[0];
          updatePointStats(latestPoint);
          
          // Create chart with all data
          createPointChart(pointCanvas, pointData.data);
          console.log('‚úÖ Point chart loaded from database with', pointData.data.length, 'records');
          } else {
          console.log('‚ö†Ô∏è No point data in database, using fallback');
          createPointChart(pointCanvas, []);
        }
        
      } catch (error) {
        console.error('‚ùå Error loading point chart from database:', error);
        const pointCanvas = document.getElementById('pointChart');
        createPointChart(pointCanvas, []);
      }
    }
    
    // Clear database and create initial data
    async function clearDatabaseAndCreateInitial() {
      try {
        console.log('üóëÔ∏è Clearing database and creating initial data...');
        
        // Clear database
        const clearResponse = await fetch('http://localhost:3000/api/clear-database', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        const clearResult = await clearResponse.json();
        console.log('üóëÔ∏è Database clear result:', clearResult);
        
        // Create initial token price (1e-15)
        const initialTokenResponse = await fetch('http://localhost:3000/api/token-prices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            symbol: 'IAM',
            name: 'IAM Token',
            priceUsd: '1e-15',
            priceDai: '1e-15',
            marketCap: '1000000',
            totalSupply: '1000000000',
            decimals: 18,
            source: 'initial'
          })
        });
        
        const initialTokenResult = await initialTokenResponse.json();
        console.log('üìä Initial token price created:', initialTokenResult);
        
        // Create initial point price
        const initialPointResponse = await fetch('http://localhost:3000/api/point-prices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            pointType: 'binary_points',
            pointValueUsd: '15.00',
            pointValueIam: '0.1',
            source: 'initial'
          })
        });
        
        const initialPointResult = await initialPointResponse.json();
        console.log('üìä Initial point price created:', initialPointResult);
        
        console.log('‚úÖ Database cleared and initial data created');
        
      } catch (error) {
        console.error('‚ùå Error clearing database and creating initial data:', error);
      }
    }
    
    // Save current blockchain data to database
    async function saveCurrentBlockchainData() {
      try {
        console.log('üîÑ Saving current blockchain data to database...');
        
        if (priceService && priceService.contract) {
          // Get current token price from blockchain
          const tokenPrice = await priceService.getRealTokenPrice();
          if (tokenPrice) {
            console.log('üìä Current token price from blockchain:', tokenPrice);
            
            // Save to database via API
            const tokenResponse = await fetch('http://localhost:3000/api/token-prices', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                symbol: 'IAM',
                name: 'IAM Token',
                priceUsd: tokenPrice.priceUsd.toString(),
                priceDai: tokenPrice.priceDai.toString(),
                marketCap: tokenPrice.marketCap.toString(),
                totalSupply: tokenPrice.totalSupply.toString(),
                decimals: 18,
                source: 'blockchain'
              })
            });
            
            const tokenResult = await tokenResponse.json();
            console.log('üíæ Token price save result:', tokenResult);
          }
          
          // Get current point price from blockchain
          const pointPrice = await priceService.getRealPointPrice('binary_points');
          if (pointPrice) {
            console.log('üìä Current point price from blockchain:', pointPrice);
            
            // Save to database via API
            const pointResponse = await fetch('http://localhost:3000/api/point-prices', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                pointType: 'binary_points',
                pointValueUsd: pointPrice.pointValueUsd.toString(),
                pointValueIam: pointPrice.pointValueIam.toString(),
                source: 'blockchain'
              })
            });
            
            const pointResult = await pointResponse.json();
            console.log('üíæ Point price save result:', pointResult);
          }
        }
        
        console.log('‚úÖ Blockchain data saved to database');
        
      } catch (error) {
        console.error('‚ùå Error saving blockchain data to database:', error);
      }
    }
    
    // Load real data from API
    async function loadRealData() {
      try {
        console.log('üîÑ Loading real data from API...');
        
        // Load token data
        const tokenResponse = await fetch('http://localhost:3000/api/token-prices?symbol=IAM&hours=24');
        const tokenData = await tokenResponse.json();
        console.log('üìä Token data:', tokenData);
        
        // Load point data
        const pointResponse = await fetch('http://localhost:3000/api/point-prices?pointType=binary_points&hours=24');
        const pointData = await pointResponse.json();
        console.log('üìä Point data:', pointData);
        
        // Create charts with real data
        const tokenCanvas = document.getElementById('tokenChart');
        const pointCanvas = document.getElementById('pointChart');
        
        if (tokenData.success && tokenData.data) {
          createTokenChart(tokenCanvas, tokenData.data);
        } else {
          createTokenChart(tokenCanvas, []);
        }
        
        if (pointData.success && pointData.data) {
          createPointChart(pointCanvas, pointData.data);
        } else {
          createPointChart(pointCanvas, []);
        }
        
        console.log('‚úÖ Real data loaded successfully');
        
      } catch (error) {
        console.error('‚ùå Error loading real data:', error);
        
        // Fallback to sample data
        const tokenCanvas = document.getElementById('tokenChart');
        const pointCanvas = document.getElementById('pointChart');
        createTokenChart(tokenCanvas, []);
        createPointChart(pointCanvas, []);
      }
    }
  </script>
</body>
</html>
