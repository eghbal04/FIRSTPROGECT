<!DOCTYPE html>
<html lang="en" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Register - IAMPHOENIX</title>
  <script>
    function parseFloatSafe(text){
      if (!text) return NaN;
      try { return parseFloat(String(text).replace(/[^0-9.]/g,'')); } catch { return NaN; }
    }

    function enforceRegisterButtonState(){
      try {
        const btn = document.getElementById('register-btn');
        const status = document.getElementById('status-message');
        const iamText = document.getElementById('IAM-balance')?.textContent || '';
        const reqText = document.getElementById('required-cost-text')?.textContent || '';
        const iam = parseFloatSafe(iamText);
        const req = parseFloatSafe(reqText);
        if (!isFinite(iam) || !isFinite(req)) { return; }
        if (iam + 1e-9 < req) {
          if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; }
          if (status) { status.style.color = '#ff6b6b'; status.textContent = `Insufficient IAM balance. Need ${req.toFixed(2)} IAM, you have ${iam.toFixed(2)} IAM.`; }
        } else {
          if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
        }
      } catch {}
    }
    // Suppress noisy MetaMask RPC messages that don't affect functionality
    window.addEventListener('error', function(e){
      const m = (e && e.message) || '';
      if (m.includes('getEnabledChains') || m.includes('isDefaultWallet') || m.includes('Could not establish connection') || m.includes('Internal JSON-RPC error') || m.includes('Receiving end does not exist') || m.includes('Extension context invalidated') || m.includes('ethereum.send(...) is deprecated')) { 
        e.preventDefault(); 
        return false; 
      }
    });
    window.addEventListener('unhandledrejection', function(e){
      const r = e && e.reason; const msg = (r && (r.message || r)) || '';
      if (typeof msg === 'string' && (msg.includes('getEnabledChains') || msg.includes('isDefaultWallet') || msg.includes('Could not establish connection') || msg.includes('Internal JSON-RPC error') || msg.includes('Receiving end does not exist') || msg.includes('Extension context invalidated') || msg.includes('ethereum.send(...) is deprecated'))) { 
        e.preventDefault(); 
        return false; 
      }
    });
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
  <!-- Removed missing assets to avoid 404s -->
  <!-- <link rel="stylesheet" href="css/style.css?v=1.1"> -->
  <!-- <link rel="stylesheet" href="css/mobile-responsive.css"> -->
  <!-- <link rel="stylesheet" href="css/modern-theme.css"> -->
  <!-- <script src="js/mobile-optimizer.js"></script> -->
  <style>
    body {
      background: linear-gradient(135deg, #0a0f1c, #1a1f2e);
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      font-family: 'Noto Sans Arabic', sans-serif;
    }
    .main-container {
      max-width: 600px;
      margin: 0 auto;
      background: #1a1f2e;
      border-radius: 15px;
      padding: 1rem;
      border: 1px solid #00ff88;
      margin-top: 4rem;
    }
    
    .register-form {
      background: linear-gradient(135deg, #232946 80%, #181c2a 100%) !important;
      color: #fff !important;
      border-radius: 16px;
      box-shadow: 0 8px 32px #00000033, 0 1.5px 6px #00ff8840;
      padding: 16px 12px 12px 12px;
    }
    
    /* Back Button Styles */
    .back-btn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: linear-gradient(135deg, #a786ff, #00ff88);
      color: #0a0f1c;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(167, 134, 255, 0.3);
      z-index: 1000;
    }
    
    .back-btn:hover {
      background: linear-gradient(135deg, #00ff88, #a786ff);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(167, 134, 255, 0.4);
    }
    .register-form label,
    .register-form-title {
      color: #a786ff !important;
    }
    .register-form input,
    .register-form-input {
      background: #232946 !important;
      color: #fff !important;
      border: 1px solid #444;
    }
    .register-form input:focus {
      border-color: #00ff88;
      background: #232946;
      color: #fff;
    }
    .info-box {
      background: rgba(28,28,40,0.97) !important;
      color: #fff !important;
      border: 1px solid #444;
      box-shadow: 0 2px 8px #00ff8840;
    }
    /* Tab buttons - separate from main register button */
    .tab-btn {
      background: transparent;
      color: #a786ff;
      font-weight: bold;
      border-radius: 6px;
      font-size: 0.9rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    
    
    /* Main register button */
    .register-btn, .buy-btn {
      background: linear-gradient(90deg,#00ff88,#00cc66) !important;
      color: #232946 !important;
      font-weight: bold;
      border-radius: 10px;
      font-size: 1.13rem;
      box-shadow: 0 2px 8px rgba(0, 255, 136, 0.3);
    }
    .register-btn:active, .buy-btn:active {
      background: linear-gradient(90deg,#00cc66,#00ff88) !important;
    }
    
    /* Loading state for register button */
    .register-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: linear-gradient(90deg, #666, #555) !important;
      box-shadow: none !important;
    }
    
    .register-btn:disabled:hover {
      filter: none !important;
    }
    .register-form-status {
      color: #fff !important;
    }
    .form-group {
       margin-bottom: 4px;
    }
    .form-group label {
       margin-bottom: 1px;
       font-size: 0.7rem;
    }
    .register-form-input {
       padding: 2px 4px;
       font-size: 0.45rem;
       word-break: break-all;
       line-height: 1.0;
       font-family: monospace;
       font-style: italic;
    }
    
    /* Index Input - Full Width */
    .index-input {
      width: 100%;
      margin-bottom: 4px;
      padding: 10px 12px;
      font-size: 1rem;
      font-weight: bold;
    }
    
    .apply-btn {
      width: auto;
      padding: 3px 6px;
      font-size: 0.6rem;
      margin-bottom: 3px;
    }
    .avatar-row {
       margin-bottom: 3px;
    }
    .avatar-choice {
       font-size: 1rem;
       padding: 1px;
     }
     .register-form {
       padding: 12px 8px 8px 8px;
     }
     .register-form-title {
       margin-bottom: 4px;
       font-size: 1rem;
    }
    
    /* Register Status Styles */
    .register-form-status {
      margin-top: 1rem;
      padding: 0.8rem;
      border-radius: 8px;
      font-size: 0.9rem;
      text-align: center;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    
    .register-form-status.success {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 0.5px solid rgba(0, 255, 136, 0.3);
    }
    
    .register-form-status.error {
      background: rgba(255, 68, 68, 0.1);
      color: #ff4444;
      border: 0.5px solid rgba(255, 68, 68, 0.3);
    }
    
    .register-form-status.loading {
      background: rgba(167, 134, 255, 0.1);
      color: #a786ff;
      border: 0.5px solid rgba(167, 134, 255, 0.3);
    }
    
    /* Address Input Group Styles */
    .address-input-group {
      display: flex;
      gap: 0.3rem;
      margin-bottom: 0.3rem;
      align-items: center;
    }
    
    .address-input-group input {
      flex: 1;
      font-size: 0.7rem;
      padding: 0.4rem 0.5rem;
    }
    
    .address-input-group .apply-btn {
      padding: 0.3rem 0.5rem;
      font-size: 0.55rem;
      white-space: nowrap;
      min-width: 40px;
    }
    
    .address-field {
      font-size: 0.35rem;
      padding: 0.2rem 0.3rem;
      background: rgba(35, 41, 70, 0.8) !important;
      border: 0.5px solid #555 !important;
      color: #ccc !important;
      word-break: break-all;
      line-height: 1.0;
      font-family: monospace;
      font-style: italic;
    }
    
    .input-with-button {
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    .input-with-button input {
      flex: 0 0 83.33%;
      padding-right: 0.3rem;
    }
    
    .paste-btn-inside {
      flex: 0 0 16.67%;
      background: rgba(52, 152, 219, 0.8);
      border: none;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
      font-size: 0.6rem;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 0.2rem;
    }
    
    .paste-btn-inside:hover {
      background: rgba(52, 152, 219, 1);
      transform: scale(1.05);
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .address-input-group {
        gap: 0.2rem;
        margin-bottom: 0.2rem;
      }
      
      .address-input-group input {
        flex: 0 0 83.33%;
        font-size: 0.65rem;
        padding: 0.3rem 0.4rem;
      }
      
      .address-input-group .apply-btn {
        flex: 0 0 16.67%;
        padding: 0.25rem 0.4rem;
        font-size: 0.5rem;
        min-width: auto;
        width: 100%;
      }
      
      /* Upper index Apply button - 1/6 of screen width */
      .input-with-button input {
        flex: 0 0 83.33%;
        padding-right: 0.2rem;
        font-size: 0.45rem;
        word-break: break-all;
        line-height: 1.0;
        font-family: monospace;
        font-style: italic;
      }
      
      .input-with-button .paste-btn-inside {
        flex: 0 0 16.67%;
        font-size: 0.55rem;
        padding: 0.15rem 0.3rem;
        margin-left: 0.1rem;
      }
      
      .address-field {
        font-size: 0.3rem;
        padding: 0.15rem 0.25rem;
        word-break: break-all;
        line-height: 0.9;
        font-family: monospace;
        font-style: italic;
      }
      
      .input-with-button input {
        flex: 0 0 83.33%;
        padding-right: 0.2rem;
        font-size: 0.65rem;
        font-family: 'Fira Mono', monospace;
        letter-spacing: 0.3px;
      }
      
      .paste-btn-inside {
        flex: 0 0 16.67%;
        font-size: 0.55rem;
        padding: 0.15rem 0.3rem;
        margin-left: 0.1rem;
        min-width: 50px;
      }
      
      /* Mobile-specific improvements for new user field */
      #new-user-address {
        font-family: 'Fira Mono', monospace !important;
        letter-spacing: 0.5px !important;
        font-size: 0.75rem !important;
        padding: 12px 8px !important;
        line-height: 1.3 !important;
        word-break: break-all !important;
        white-space: pre-wrap !important;
        overflow-x: auto !important;
        min-height: 50px !important;
        resize: vertical !important;
        width: 100% !important;
        box-sizing: border-box !important;
      }
      
      #new-user-address::placeholder {
        font-family: 'Fira Mono', monospace;
        letter-spacing: 0.3px;
        opacity: 0.7;
        font-size: 0.7rem;
      }
      
      /* Mobile paste button */
      #paste-new-user-btn {
        font-size: 0.7rem !important;
        padding: 6px 10px !important;
        margin-bottom: 6px !important;
      }
    }
  /* Modern theme override */
  :root{
    --bg: #0b0f17; --card:#0f1420; --elev:#121a2a; --border:#22304a; --accent:#5da0ff; --accent-2:#33d69f; --text:#e6eaf0; --muted:#aab6d3;
  }
  body{ background: var(--bg); color: var(--text); padding:16px; }
  .main-container{ max-width:560px; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
  .register-form{ background:var(--elev)!important; border:1px solid var(--border); border-radius:14px; padding:16px 14px; }
  .register-form-title, .register-form label{ color:#cfe3ff!important; font-weight:600; }
  .form-group{ margin-bottom:10px; }
  .register-form-input, .register-form input{ background:#0f1420!important; color:var(--text)!important; border:1px solid var(--border); border-radius:12px; padding:12px; font-size:1rem; box-sizing:border-box; }
  .register-form input:focus{ border-color:var(--accent); outline:none; box-shadow:0 0 0 3px rgba(93,160,255,.15); }
  .index-input{ height:48px; font-size:1.05rem; }
  .address-input-group{ gap:8px; }
  .address-input-group input{ height:48px; font-size:1.05rem; }
  .address-field{ background:#0f1420!important; border:1px solid var(--border)!important; color:#cfd7ea!important; height:48px; font-size:1.05rem; padding:12px; border-radius:12px; line-height:1.2; }
  
  /* New user address field - show full address */
  #new-user-address {
    font-family: 'Fira Mono', monospace !important;
    letter-spacing: 0.5px !important;
    font-size: 0.85rem !important;
    padding: 12px !important;
    line-height: 1.3 !important;
    word-break: break-all !important;
    white-space: pre-wrap !important;
    overflow-x: auto !important;
    min-height: 60px !important;
    resize: vertical !important;
    background: #0f1420 !important;
    border: 1px solid var(--border) !important;
    color: #cfd7ea !important;
    border-radius: 12px !important;
    width: 100% !important;
    box-sizing: border-box !important;
  }
  
  #new-user-address::placeholder {
    font-family: 'Fira Mono', monospace;
    letter-spacing: 0.3px;
    opacity: 0.7;
    font-size: 0.8rem;
  }
  
  /* Paste button for new user address */
  #paste-new-user-btn {
    background: rgba(0, 255, 136, 0.2) !important;
    color: #00ff88 !important;
    border: 1px solid rgba(0, 255, 136, 0.4) !important;
    border-radius: 8px !important;
    font-weight: 600 !important;
    transition: all 0.3s ease !important;
    cursor: pointer !important;
  }
  
  #paste-new-user-btn:hover {
    background: rgba(0, 255, 136, 0.3) !important;
    border-color: rgba(0, 255, 136, 0.6) !important;
    transform: translateY(-1px) !important;
  }
  
  #paste-new-user-btn:active {
    transform: translateY(0) !important;
  }
  .tab-btn{ background:#0f1420; color:#cfe3ff; border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-weight:600; }
  /* Ensure high-contrast label for Normal Registration */
  .register-btn, .buy-btn{ background:linear-gradient(135deg, #2f9950, #2b8a3e)!important; color:var(--text)!important; border:1px solid #3aa654; padding:12px; border-radius:12px; font-weight:700; font-size:1.05rem; }
  .register-btn:hover, .buy-btn:hover{ filter:brightness(1.05); }
  .apply-btn, .paste-btn-inside{ background:#1a2335; color:#cfe3ff; border:1px solid var(--border); border-radius:12px; padding:14px 16px; font-size:1.05rem; min-width: 88px; }
  .register-form-status{ border-radius:12px; }
  .register-form-status.success{ background:rgba(46,204,113,.08); color:#2ecc71; border:1px solid rgba(46,204,113,.25); }
  .register-form-status.error{ background:rgba(231,76,60,.08); color:#e74c3c; border:1px solid rgba(231,76,60,.25); }
  .register-form-status.loading{ background:rgba(93,160,255,.08); color:#5da0ff; border:1px solid rgba(93,160,255,.25); }
  @media(max-width:480px){
    body{ padding:12px; }
    .register-form-input, .register-form input, .address-input-group input, .address-field{ height:50px; font-size:1.06rem; padding:12px; }
    .apply-btn, .paste-btn-inside{ font-size:1.08rem; padding:14px; }
    .register-btn, .buy-btn{ font-size:1.08rem; padding:13px; }
    .form-group label{ font-size:.95rem; }
  }
  
  </style>
</head>
<body>
  
  <!-- Back Button -->
  <a href="index.html" class="back-btn">‚Üê Back</a>

  <!-- Main Content -->
  <div class="main-container">
         <form class="register-form" autocomplete="off">
               <!-- Registration tabs -->
      <div class="register-form-status warning" id="register-suggestion" style="display:none;"></div>
      
      <!-- Registration Permission Notice -->
      <div class="info-box" style="margin-bottom: 16px; padding: 12px; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); color: #00ff88; border-radius: 8px;">
        <div style="font-weight: 600; margin-bottom: 4px;">üìã Registration Rules:</div>
        <div style="font-size: 0.85rem; line-height: 1.4;">
          ‚Ä¢ <strong>New users:</strong> Can register for themselves only<br>
          ‚Ä¢ <strong>Active users:</strong> Can register for themselves or their <strong>downlines</strong><br>
          ‚Ä¢ <strong>Auto-fill:</strong> If you're active, your info will be auto-filled as upper (locked)<br>
          ‚Ä¢ <strong>Upper field:</strong> You can change upper to yourself or your downlines<br>
          ‚Ä¢ Crossline and upline registrations are not allowed<br>
          ‚Ä¢ This ensures proper tree structure and prevents conflicts
        </div>
      </div>
      
      <!-- Referrer Index -->
      <div class="form-group">
        <label for="referrer-index">Referrer Index</label>
        <div class="input-with-button">
          <input type="text" id="referrer-index" class="register-form-input" placeholder="e.g. 123 or IAM123" autocomplete="off">
          <button type="button" id="apply-referrer-index-btn" class="paste-btn-inside">Apply</button>
        </div>
        <input type="text" id="referrer-address-display" class="register-form-input address-field" placeholder="0x..." autocomplete="off" readonly>
        <div id="referrer-validation-status" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem;"></div>
      </div>

      <!-- Upper Address with Index -->
      <div class="form-group">
        <label for="upper-index" id="upper-label">Upper Index</label>
        <div class="input-with-button">
          <input type="text" id="upper-index" class="register-form-input" placeholder="e.g. 123" autocomplete="off">
          <button type="button" id="apply-upper-index-btn" class="paste-btn-inside">Apply</button>
        </div>
        <input type="text" id="upper-address" class="register-form-input address-field" placeholder="0x..." autocomplete="off" value="root" readonly>
        <div id="upper-validation-status" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem;"></div>
      </div>

      <!-- New User Address -->
      <div class="form-group">
        <label for="new-user-address">New User Address</label>
        <textarea id="new-user-address" class="register-form-input" placeholder="0x..." autocomplete="off" rows="2" style="font-family: 'Fira Mono', monospace; letter-spacing: 0.5px; resize: vertical; min-height: 60px; width: 100%; margin-bottom: 8px;"></textarea>
        <button type="button" id="paste-new-user-btn" class="paste-btn-inside" style="width: 100%; margin-bottom: 4px; padding: 8px 12px; font-size: 0.8rem;">üìã Paste Address</button>
        <div id="new-user-address-info" class="register-form-status" style="display:none; margin-top: 4px; font-size: 0.7rem; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); color: #00ff88;"></div>
      </div>
       
                       <button class="register-btn buy-btn" id="register-btn" type="button" style="width:100%;margin-top:6px;">Register</button>
      
      <script>
         // Function to display general messages
     function showMessageBox(message, type = 'info') {
         // Remove previous message box if exists
         const existingBox = document.getElementById('message-box');
         if (existingBox) {
             existingBox.remove();
         }
         
         // Create new message box
         const messageBox = document.createElement('div');
         messageBox.id = 'message-box';
         messageBox.style.cssText = `
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: ${type === 'error' ? 'rgba(255, 0, 0, 0.95)' : type === 'success' ? 'rgba(0, 255, 136, 0.95)' : 'rgba(167, 134, 255, 0.95)'};
             color: white;
             padding: 20px 30px;
             border-radius: 12px;
             box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
             z-index: 10000;
             max-width: 400px;
             text-align: center;
             font-size: 14px;
             line-height: 1.5;
             backdrop-filter: blur(10px);
             border: 1px solid ${type === 'error' ? 'rgba(255, 0, 0, 0.3)' : type === 'success' ? 'rgba(0, 255, 136, 0.3)' : 'rgba(167, 134, 255, 0.3)'};
         `;
         
         // Icon based on message type
         const icon = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
         
         messageBox.innerHTML = `
             <div style="margin-bottom: 10px; font-size: 24px;">${icon}</div>
             <div style="margin-bottom: 15px;">${message}</div>
             <button onclick="this.parentElement.remove()" style="
                 background: rgba(255, 255, 255, 0.2);
                 border: 1px solid rgba(255, 255, 255, 0.3);
                 color: white;
                 padding: 8px 20px;
                 border-radius: 6px;
                 cursor: pointer;
                 font-size: 13px;
                 transition: all 0.3s ease;
             " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                 Close
             </button>
         `;
         
         document.body.appendChild(messageBox);
         
         // Auto remove after 5 seconds
         setTimeout(() => {
             if (messageBox.parentElement) {
                 messageBox.remove();
             }
         }, 5000);
     }

     // Function to display message box for index checking (without exit button)
     function showIndexCheckMessage(message, type = 'info') {
         // Remove previous message box if exists
         const existingBox = document.getElementById('index-check-message');
         if (existingBox) {
             existingBox.remove();
         }
         
         // Determine color and icon based on type
         let bgColor, borderColor, icon;
         if (type === 'error') {
             bgColor = 'rgba(255, 0, 0, 0.95)';
             borderColor = 'rgba(255, 0, 0, 0.3)';
             icon = '‚ùå';
         } else if (type === 'success') {
             bgColor = 'rgba(0, 255, 136, 0.95)';
             borderColor = 'rgba(0, 255, 136, 0.3)';
             icon = '‚úÖ';
         } else if (type === 'warning') {
             bgColor = 'rgba(255, 165, 0, 0.95)';
             borderColor = 'rgba(255, 165, 0, 0.3)';
             icon = '‚ö†Ô∏è';
         } else {
             bgColor = 'rgba(0, 123, 255, 0.95)';
             borderColor = 'rgba(0, 123, 255, 0.3)';
             icon = '‚ÑπÔ∏è';
         }
         
         // Create new message box
         const messageBox = document.createElement('div');
         messageBox.id = 'index-check-message';
         messageBox.style.cssText = `
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background: ${bgColor};
             color: white;
             padding: 25px 30px;
             border-radius: 16px;
             box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
             z-index: 10000;
             max-width: 90vw;
             width: 350px;
             text-align: center;
             font-size: 16px;
             line-height: 1.6;
             backdrop-filter: blur(15px);
             border: 2px solid ${borderColor};
             font-weight: 500;
         `;
         
         messageBox.innerHTML = `
             <div style="margin-bottom: 15px; font-size: 32px;">${icon}</div>
             <div style="margin-bottom: 20px; font-size: 18px; font-weight: bold;">Index Check Result</div>
             <div style="margin-bottom: 20px; font-size: 15px; line-height: 1.5;">${message}</div>
         `;
         
         document.body.appendChild(messageBox);
         
         // Auto remove after 4 seconds
         setTimeout(() => {
             if (messageBox.parentElement) {
                 messageBox.style.animation = 'fadeOut 0.5s ease';
                 setTimeout(() => messageBox.remove(), 500);
             }
         }, 4000);
     }


    // Function to display temporary messages (for validation)
    function showTempMessage(message, type = 'info', duration = 3000) {
        const tempBox = document.createElement('div');
        tempBox.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'error' ? 'rgba(255, 0, 0, 0.9)' : type === 'success' ? 'rgba(0, 255, 136, 0.9)' : 'rgba(167, 134, 255, 0.9)'};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            z-index: 9999;
            font-size: 13px;
            max-width: 300px;
            backdrop-filter: blur(8px);
            border: 1px solid ${type === 'error' ? 'rgba(255, 0, 0, 0.3)' : type === 'success' ? 'rgba(0, 255, 136, 0.3)' : 'rgba(167, 134, 255, 0.3)'};
            animation: slideIn 0.3s ease;
        `;
        
        const icon = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
        tempBox.innerHTML = `${icon} ${message}`;
        
        document.body.appendChild(tempBox);
        
        setTimeout(() => {
            if (tempBox.parentElement) {
                tempBox.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => tempBox.remove(), 300);
            }
        }, duration);
    }

    // Add CSS animations
    if (!document.getElementById('message-box-styles')) {
        const style = document.createElement('style');
        style.id = 'message-box-styles';
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                to { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            }
        `;
        document.head.appendChild(style);
    }

         // Define input variables before any use
         let newUserInput, referrerAddressDisplay, referrerIndexInput, upperInput, refInput, indexInput;
         
          // Function to handle referral parameters from URL
          function handleReferralParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const upperIndex = urlParams.get('upper');
            const upperAddress = urlParams.get('upperAddr');
            const emptyIndex = urlParams.get('emptyIndex');
            const position = urlParams.get('position');
            
            console.log('üîó Referral parameters:', { upperIndex, upperAddress, emptyIndex, position });
            
            // Auto-fill referrer information if provided
            if (upperIndex) {
              if (referrerIndexInput) referrerIndexInput.value = upperIndex;
              // Trigger validation and address lookup
              setTimeout(async () => {
                await checkAddressValidity(referrerIndexInput, 'referrer');
              }, 700);
            }
            
            if (upperAddress) {
              if (referrerAddressDisplay) {
                referrerAddressDisplay.value = truncateAddress(upperAddress);
                referrerAddressDisplay.setAttribute('data-full-address', upperAddress);
              }
              // Trigger validation
              setTimeout(async () => {
                await checkAddressValidity(referrerAddressDisplay, 'referrer');
              }, 700);
            }
            
            // Show success message if referrer parameters were processed
            if (upperIndex || upperAddress) {
              setTimeout(() => {
                const statusDiv = document.getElementById('referrer-validation-status');
                if (statusDiv) {
                  statusDiv.style.display = 'block';
                  statusDiv.className = 'register-form-status success';
                  statusDiv.textContent = `‚úÖ Referrer information loaded from link successfully! (Slot: ${emptyIndex || 'N/A'}, Position: ${position || 'N/A'})`;
                }
              }, 1000);
            }
          }
         
         document.addEventListener('DOMContentLoaded', function() {
           newUserInput = document.getElementById('new-user-address');
           referrerAddressDisplay = document.getElementById('referrer-address-display');
           referrerIndexInput = document.getElementById('referrer-index');
           upperIndexInput = document.getElementById('upper-index');
           upperInput = document.getElementById('upper-address');
           refInput = document.getElementById('upper-address');
           indexInput = referrerIndexInput; // Use referrer index as the main index input
           
           // Handle URL parameters for referral links
           handleReferralParameters();
           
           // Initialize global variables
           window.newUserInput = newUserInput;
           window.referrerAddressDisplay = referrerAddressDisplay;
           window.referrerIndexInput = referrerIndexInput;
           window.upperIndexInput = upperIndexInput;
           window.upperInput = upperInput;
           window.refInput = refInput;
           // Alias for backward compatibility
           window.upperDisplay = referrerAddressDisplay;
           
           // Set up all event listeners here
           setupEventListeners();
           
           function setupEventListeners() {
             // Ensure referrer address display is available
             if (!referrerAddressDisplay) {
               referrerAddressDisplay = document.getElementById('referrer-address-display');
             }
             
             // Referrer index application button
             document.getElementById('apply-referrer-index-btn').addEventListener('click', async function() {
               await applyIndexToAddress(referrerIndexInput, referrerAddressDisplay, 'referrer');
             });
             
             // Upper index application button
             document.getElementById('apply-upper-index-btn').addEventListener('click', async function() {
               await applyIndexToAddress(upperIndexInput, upperInput, 'upper');
             });
             
             // Enter key support for referrer index field
             referrerIndexInput.addEventListener('keypress', async function(e) {
               if (e.key === 'Enter') {
                 e.preventDefault();
                 document.getElementById('apply-referrer-index-btn').click();
               }
             });

             // Enter key support for upper index
             upperIndexInput.addEventListener('keypress', async function(e) {
               if (e.key === 'Enter') {
                 e.preventDefault();
                 document.getElementById('apply-upper-index-btn').click();
               }
             });
             
             // Paste button for new user address
             const pasteNewUserBtn = document.getElementById('paste-new-user-btn');
             const newUserInput = document.getElementById('new-user-address');
             
             if (pasteNewUserBtn && newUserInput) {
               pasteNewUserBtn.addEventListener('click', async function() {
                 try {
                   const text = await navigator.clipboard.readText();
                   if (text && text.trim()) {
                     // Clean the pasted text - remove extra spaces and newlines
                     const cleanedText = text.trim().replace(/\s+/g, '');
                     newUserInput.value = cleanedText;
                     
                     // Trigger validation
                     newUserInput.dispatchEvent(new Event('input'));
                     
                     showTempMessage('‚úÖ Address pasted successfully', 'success');
                   } else {
                     showTempMessage('‚ùå No text found in clipboard', 'error');
                   }
                 } catch (error) {
                   console.error('Paste failed:', error);
                   showTempMessage('‚ùå Paste failed. Please paste manually.', 'error');
                 }
               });
             }
             
             // Address field event listeners (for manual editing)
             referrerAddressDisplay.addEventListener('change', async function() {
               await checkAddressValidity(referrerAddressDisplay, 'referrer');
               await validateUpperAgainstupper();
               await calculatePlacementForNewUser();
             });
             
             // New user address input handler - clean spaces automatically
             if (newUserInput) {
               let isUpdating = false; // Prevent infinite loop
               newUserInput.addEventListener('input', function() {
                 if (isUpdating) return; // Skip if we're updating from code
                 // Remove any spaces, newlines, or extra characters
                 const cleanedValue = this.value.replace(/\s+/g, '');
                 if (this.value !== cleanedValue) {
                   isUpdating = true;
                   this.value = cleanedValue;
                   setTimeout(() => { isUpdating = false; }, 0);
                 }
               });
               
               newUserInput.addEventListener('paste', function(e) {
                 if (isUpdating) return; // Skip if we're updating from code
                 // Allow paste to complete, then clean it
                 setTimeout(() => {
                   if (isUpdating) return;
                   const cleanedValue = this.value.replace(/\s+/g, '');
                   if (this.value !== cleanedValue) {
                     isUpdating = true;
                     this.value = cleanedValue;
                     showTempMessage('‚úÖ Address cleaned automatically', 'success');
                     setTimeout(() => { isUpdating = false; }, 0);
                   }
                 }, 10);
               });
             }
             
             upperIndexInput.addEventListener('change', async function() {
               // Only validate if it's a valid index format
               const value = this.value.trim();
               if (value && (value.match(/^\d+$/) || value.match(/^IAM\d+$/))) {
                 await checkAddressValidity(upperIndexInput, 'upper');
                 await validateUpperAgainstupper();
                 await calculatePlacementForNewUser();
               }
             });
             
             upperInput.addEventListener('change', async function() {
               await checkAddressValidity(upperInput, 'upper');
               await validateUpperAgainstupper();
               await checkUpperCapacityAndShowStatus();
             });
             
             // Add real-time capacity checking for upper field
             upperInput.addEventListener('input', async function() {
               await checkUpperCapacityAndShowStatus();
             });
           }
           
           
           
          // When user clicks on upper index input
           upperIndexInput.addEventListener('click', async function() {
               try {
              // Read clipboard content
                 const clipboardText = await navigator.clipboard.readText();
                 
              // Check if copied text looks like a number or IAM format
                 if (clipboardText.match(/^(\d+|IAM\d+)$/)) {
                   upperIndexInput.value = clipboardText;
                
                                 // Display success message (optional)
                 alert('upper index copied from clipboard successfully!');
                 }
               } catch (err) {
                           console.error('Error accessing clipboard:', err);
             // If needed, you can display an error message to user
             }
           });

          // When user clicks on upper input
           upperInput.addEventListener('click', async function() {
               try {
              // Read clipboard content
                 const clipboardText = await navigator.clipboard.readText();
                 
              // Check if copied text looks like Ethereum address
                 if (clipboardText.match(/^0x[a-fA-F0-9]{40}$/)) {
                   upperInput.value = clipboardText;
                
                                 // Display success message (optional)
                 alert('Upper address copied from clipboard successfully!');
                 }
               } catch (err) {
                           console.error('Error accessing clipboard:', err);
             // If needed, you can display an error message to user
             }
           });

          // When user clicks on upper index input
           upperIndexInput.addEventListener('click', async function() {
               try {
              // Read clipboard content
                 const clipboardText = await navigator.clipboard.readText();
                 
              // Check if copied text looks like a number or IAM format
                 if (clipboardText.match(/^(\d+|IAM\d+)$/)) {
                   upperIndexInput.value = clipboardText;
                
                                 // Display success message (optional)
                 alert('Upper index copied from clipboard successfully!');
                 }
               } catch (err) {
                           console.error('Error accessing clipboard:', err);
             // If needed, you can display an error message to user
             }
           });
           
           // New user input event listeners
           if (newUserInput) {
             newUserInput.addEventListener('change', async function() {
               await checkNewUserAddress();
             });
             
             newUserInput.addEventListener('input', async function() {
               await checkNewUserAddress();
               await calculatePlacementForNewUser();
             });
             
             newUserInput.addEventListener('paste', async function() {
               setTimeout(async () => {
                 await checkNewUserAddress();
                 await calculatePlacementForNewUser();
               }, 100);
             });
           }
           
           // Index input event listeners
           if (indexInput) {
             const defaultGuide = 'e.g. 123 or IAM123';
             
             indexInput.addEventListener('focus', function() {
               if (this.value === defaultGuide) {
                 this.value = '';
                 this.style.background = '';
                 this.style.color = '';
                 this.style.opacity = '';
               }
             });
             
             indexInput.addEventListener('blur', function() {
               if (this.value.trim() === '') {
                 this.value = defaultGuide;
                 this.style.background = '#f3f3f3';
                 this.style.color = '#888';
                 this.style.opacity = '0.7';
                 if (refInput) {
                   refInput.value = 'root';
                 }
               }
             });
           }
         });
       </script>
             <div class="info-box" id="register-info" style="background:rgba(28,28,40,0.97);color:#fff;font-size:0.8rem;box-shadow:0 2px 8px #a786ff22;margin-bottom:6px;padding:6px;">
        <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
          <span>Cost: <b id="register-cost" style="color:#00ff88;">...</b></span>
          <span>Type: <b id="registration-type" style="color:#a786ff;">Normal</b></span>
        </div>
        <div style="display:flex;justify-content:space-between;font-size:0.75rem;">
          <span>MATIC: <b id="matic-balance">...</b></span>
          <span>IAM: <b id="IAM-balance">...</b></span>
        </div>
             </div>
      <div class="avatar-row" style="display:none; margin:0;">
        <span class="avatar-choice selected" data-avatar="man">üë®‚Äçüíº</span>
        <span class="avatar-choice" data-avatar="woman">üë©‚Äçüíº</span>
        <span class="avatar-choice" data-avatar="student-man">üë®‚Äçüéì</span>
        <span class="avatar-choice" data-avatar="student-woman">üë©‚Äçüéì</span>
      </div>
      <div class="register-form-status" id="status-message"></div>
      
      <!-- Manual retry button for wallet connection issues -->
      <div id="wallet-retry-section" style="display: none; margin-top: 10px; text-align: center;">
        <button id="retry-wallet-btn" class="btn" style="background: linear-gradient(135deg, #a786ff, #00ff88); color: #0a0f1c; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer;">
          üîÑ Retry Wallet Connection
        </button>
      </div>
  
  <div class="info-box" id="required-cost-box" style="display:none; margin-top:8px; padding:8px; border-radius:8px;">
    <span>Required IAM for this registration: </span>
    <b id="required-cost-text">...</b>
  </div>
      

    </form>
  </div>
  <!-- Web3 and Ethers.js - Load first -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
  
  <!-- Ensure ethers is loaded -->
  <script>
      if (typeof ethers === 'undefined') {
          console.error('‚ùå Ethers.js not loaded properly');
      } else {
          console.log('‚úÖ Ethers.js loaded:', ethers.version);
      }
  </script>
  
  <script>window.SKIP_META = true;</script>
  <script>
    // Force register page to use Old Contract (Default)
    const OLD_CONTRACT_ADDRESS = '0x2D3923A5ba62B2bec13b9181B1E9AE0ea2C8118D'; // Old contract (default)
    
    // Override config.js behavior for register page
    window.IAM_ADDRESS = OLD_CONTRACT_ADDRESS;
    
    // Clear any old contract selection from localStorage
    try {
      localStorage.removeItem('iam_selected_address');
      localStorage.setItem('iam_selected_address', OLD_CONTRACT_ADDRESS);
      console.log('‚úÖ Set localStorage to old contract:', OLD_CONTRACT_ADDRESS);
    } catch (e) {
      console.warn('‚ö†Ô∏è Could not update localStorage:', e);
    }
    
    // Override the config.js IAM_ADDRESS assignment
    window.addEventListener('load', function() {
      window.IAM_ADDRESS = OLD_CONTRACT_ADDRESS;
      console.log('‚úÖ Register page: Final IAM_ADDRESS override:', window.IAM_ADDRESS);
    });
    
    console.log('‚úÖ Register page: IAM_ADDRESS set to old contract (default):', window.IAM_ADDRESS);
  </script>
  <script src="js/config.js"></script>
  <script src="js/floating-token-card.js"></script>
  <script src="js/auto-wallet-connect.js"></script>
  <script>
    // Override connectWallet to force old contract and cache connection
    const originalConnectWallet = window.connectWallet;
    let cachedConnection = null;
    let isConnecting = false;
    
    window.connectWallet = async function() {
      // Return cached connection if available
      if (cachedConnection && cachedConnection.address && cachedConnection.contract) {
        console.log('‚úÖ Using cached wallet connection');
        return cachedConnection;
      }
      
      // Prevent concurrent connection attempts
      if (isConnecting) {
        console.log('‚è≥ Wallet connection in progress, waiting...');
        while (isConnecting) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        if (cachedConnection) {
          return cachedConnection;
        }
      }
      
      isConnecting = true;
      console.log('üîÑ Register page: Overriding connectWallet to use old contract (default)');
      
      try {
        // Force IAM_ADDRESS to old contract
        window.IAM_ADDRESS = OLD_CONTRACT_ADDRESS;
        
        // Call original function
        const result = await originalConnectWallet.call(this);
        
        // Cache the connection if successful
        if (result && result.contract && result.address) {
          cachedConnection = result;
          const contractAddress = result.contract?.target || window.IAM_ADDRESS;
          console.log('‚úÖ Register page: Contract connected to:', contractAddress);
        }
        
        return result;
      } finally {
        isConnecting = false;
      }
    };
    
    // Set contract to old contract (Default) on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Force connection to old contract only (Contract 1)
      if (window.CONTRACT_1_ADDRESS) {
        window.IAM_ADDRESS = window.CONTRACT_1_ADDRESS;
        console.log('‚úÖ Register page locked to old contract (default):', window.CONTRACT_1_ADDRESS);
      }
    });
    
    // Fallback helpers to avoid calling non-existent contract functions
    window.safeGetRegPrice = async function(contract){
      try {
        if (contract && typeof contract.getRegPrice === 'function') {
          return await contract.getRegPrice();
        }
      } catch(_) {}
      // Default fallback (100 IAM)
      try { return ethers.parseUnits('100', 18); } catch(_) { return null; }
    };

    window.safeGetLeftAddress = async function(contract, parentIndex){
      if (!contract) return null;
      if (typeof contract.getLeftChild === 'function') {
        try { return await contract.getLeftChild(parentIndex); } catch(_) {}
      }
      return null; // gracefully fallback
    };
    window.safeGetRightAddress = async function(contract, parentIndex){
      if (!contract) return null;
      if (typeof contract.getRightChild === 'function') {
        try { return await contract.getRightChild(parentIndex); } catch(_) {}
      }
      return null; // gracefully fallback
    };
  </script>
  <script>
    async function updateRegistrationCost(){
      try {
        const box = document.getElementById('required-cost-box');
        const txt = document.getElementById('required-cost-text');
        if (!box || !txt) return;
        let contract = window.contractConfig && window.contractConfig.contract;
        if (!contract && typeof window.connectWallet === 'function') {
          try { const conn = await window.connectWallet(); contract = conn && conn.contract ? conn.contract : contract; } catch(_) {}
        }
        if (!contract) return;
        if (currentRegistrationType === 'free') {
          // Reserve: 23 USD worth of IAM
          let price = 1;
          try {
            let p;
            if (typeof contract.getTokenPrice === 'function') p = await contract.getTokenPrice();
            else if (typeof contract.tokenPrice === 'function') p = await contract.tokenPrice();
            if (p !== undefined) price = Number(ethers.formatUnits(p, 18)) || 1;
          } catch(_) {}
          const required = 23 / price;
          txt.textContent = `${required.toFixed(2)} IAM`;
          box.style.display = 'block';
        } else {
          // Normal: regPrice from contract
          try {
            const wei = await (window.safeGetRegPrice ? window.safeGetRegPrice(contract) : null);
            if (wei) {
              const val = Number(ethers.formatUnits(wei, 18));
              txt.textContent = `${val.toFixed(2)} IAM`;
              box.style.display = 'block';
            } else {
              box.style.display = 'none';
            }
          } catch(_) {}
        }
      } catch(_) {}
    }
    // Try to connect wallet on load and report status
    // Wrapped in a named function for better debugging
    async function initializeWalletConnection() {
      console.log('üöÄ Register page: Initializing wallet connection...');
      
      try {
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
          await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));
        }
        
        // Wait for scripts to load
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        if (typeof window.connectWallet === 'function') {
          console.log('üîó Attempting wallet connection (register)...');
          
          // Add retry logic for MetaMask connection issues
          let conn = null;
          let retryCount = 0;
          const maxRetries = 3;
          
          while (retryCount < maxRetries && !conn) {
            try {
              // Add a small delay before each attempt to let MetaMask stabilize
              if (retryCount > 0) {
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
              
              conn = await window.connectWallet();
              if (conn && conn.address) {
                break;
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è Wallet connection attempt ${retryCount + 1} failed:`, error.message);
              retryCount++;
              if (retryCount < maxRetries) {
                console.log(`‚è≥ Retrying wallet connection in 2 seconds... (${retryCount}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            }
          }
          
          if (conn && conn.address) {
            console.log('‚úÖ Wallet connected on register:', conn.address);
            // Set new user field to connected address ONLY if user is inactive
            try {
              const nu = document.getElementById('new-user-address');
              if (nu && conn.contract) {
                let userActive = false;
                let userIndex = null;
                try {
                  const u = await conn.contract.users(conn.address);
                  console.log('üîç Checking user data:', u);
                  
                  // Try to get index field from struct (ONLY u.index)
                  let userIndexValue = null;
                  
                  // Only check u.index
                  if (u && u.index !== undefined && u.index !== null) {
                    userIndexValue = u.index;
                    console.log('üìç Found index as u.index:', userIndexValue);
                  }
                  
                  // User is active if index exists and is non-zero
                  userActive = !!(userIndexValue && BigInt(userIndexValue) !== 0n);
                  console.log('‚úÖ User active:', userActive, 'Index value:', userIndexValue);
                  if (userActive) {
                    userIndex = Number(userIndexValue);
                    console.log('üìä User index:', userIndex);
                  }
                } catch(e) {
                  console.log('‚ùå Error checking user:', e);
                }
                
                if (!userActive) {
                  console.log('‚ÑπÔ∏è User is not active, setting new-user address to connected wallet');
                  nu.value = conn.address;
                  nu.setAttribute('data-full-address', conn.address);
                } else {
                  // Always auto-fill upper fields with connected wallet address
                  console.log('üîÑ Auto-filling fields for active user...');
                  await autoFillupperFields(conn.address, userIndex);
                  console.log('‚úÖ Auto-fill completed for active user');
                }
              }
            } catch(_) {}
            // Fetch and show registration price
            try {
              const box = document.getElementById('reg-price-box');
              const txt = document.getElementById('reg-price-text');
              if (box && txt && conn.contract) {
                const wei = await (window.safeGetRegPrice ? window.safeGetRegPrice(conn.contract) : null);
                if (wei !== null && wei !== undefined) {
                  const val = (typeof ethers !== 'undefined') ? ethers.formatUnits(wei, 18) : String(wei);
                  txt.textContent = `${Number(val).toFixed(2)} IAM`;
                  box.style.display = 'block';
                }
              }
            } catch(e) { console.warn('Reg price fetch failed:', e && (e.message||e)); }

            // Also update required cost box now that we are connected
            try { await updateRegistrationCost(); } catch(_) {}

            // Fetch and populate balances box
            try {
              const mEl = document.getElementById('matic-balance');
              const iEl = document.getElementById('IAM-balance');
              if (mEl && iEl) {
                const provider = conn.provider || (window.contractConfig && window.contractConfig.provider);
                if (provider) {
                  const mBal = await provider.getBalance(conn.address);
                  const mNum = ethers.formatUnits(mBal, 18);
                  mEl.textContent = Number(mNum).toFixed(4);
                }
                try {
                  const c = conn.contract || (window.contractConfig && window.contractConfig.contract);
                  if (c && typeof c.balanceOf === 'function') {
                    const ib = await c.balanceOf(conn.address);
                    const iNum = ethers.formatUnits(ib, 18);
                    iEl.textContent = Number(iNum).toFixed(2);
                  }
                } catch(_) {}
              }
            } catch(_) {}
            enforceRegisterButtonState();
          } else {
            console.warn('‚ö†Ô∏è Wallet not connected on register after all retry attempts');
            // Show user-friendly message and retry button
            const statusEl = document.getElementById('status-message');
            const retrySection = document.getElementById('wallet-retry-section');
            if (statusEl) {
              statusEl.className = 'register-form-status warning';
              statusEl.textContent = '‚ö†Ô∏è Wallet connection failed. Please try again.';
            }
            if (retrySection) {
              retrySection.style.display = 'block';
            }
          }
        } else {
          console.warn('‚ö†Ô∏è connectWallet is not available on register');
          // Show user-friendly message
          const statusEl = document.getElementById('status-message');
          if (statusEl) {
            statusEl.className = 'register-form-status error';
            statusEl.textContent = '‚ùå Wallet connection not available. Please check if MetaMask is installed.';
          }
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Wallet connect attempt failed on register:', e && (e.message||e));
        // Show user-friendly message
        const statusEl = document.getElementById('status-message');
        if (statusEl) {
          statusEl.className = 'register-form-status error';
          statusEl.textContent = '‚ùå Wallet connection failed. Please refresh the page and try again.';
        }
      }

      // Add retry button functionality
      const retryBtn = document.getElementById('retry-wallet-btn');
      if (retryBtn) {
        retryBtn.addEventListener('click', async function() {
          console.log('üîÑ Manual wallet retry requested...');
          retryBtn.disabled = true;
          retryBtn.textContent = '‚è≥ Connecting...';
            
            try {
              if (typeof window.connectWallet === 'function') {
                const conn = await window.connectWallet();
                if (conn && conn.address) {
                  console.log('‚úÖ Manual wallet connection successful:', conn.address);
                  const statusEl = document.getElementById('status-message');
                  const retrySection = document.getElementById('wallet-retry-section');
                  
                  if (statusEl) {
                    statusEl.className = 'register-form-status success';
                    statusEl.textContent = '‚úÖ Wallet connected successfully!';
                  }
                  if (retrySection) {
                    retrySection.style.display = 'none';
                  }
                  
                  // Reload the page to refresh all wallet-dependent functionality
                  setTimeout(() => {
                    window.location.reload();
                  }, 2000);
                } else {
                  throw new Error('Wallet connection failed');
                }
              } else {
                throw new Error('Wallet connection not available');
              }
            } catch (error) {
              console.error('‚ùå Manual wallet retry failed:', error);
              const statusEl = document.getElementById('status-message');
              if (statusEl) {
                statusEl.className = 'register-form-status error';
                statusEl.textContent = '‚ùå Wallet connection failed. Please check MetaMask and try again.';
              }
            } finally {
              retryBtn.disabled = false;
              retryBtn.textContent = 'üîÑ Retry Wallet Connection';
            }
          });
        }

        // Keep new user field in sync with account changes
        if (window.ethereum && window.ethereum.on) {
          try {
            window.ethereum.on('accountsChanged', async (accounts) => {
              const addr = (accounts && accounts[0]) ? accounts[0] : null;
              const nu = document.getElementById('new-user-address');
              if (nu && addr) {
                // Only fill New User if account is inactive
                try {
                  let contract = (window.contractConfig && window.contractConfig.contract) || null;
                  if (!contract && typeof window.connectWallet === 'function') {
                    const c = await window.connectWallet();
                    contract = c && c.contract ? c.contract : contract;
                  }
                  let userActive = false;
                  if (contract) {
                    try { 
                      const u = await contract.users(addr);
                      // User is active if index exists and is non-zero
                      userActive = isUserActive(u);
                    } catch(_) {}
                  }
                  if (!userActive) {
                    nu.value = addr;
                    nu.setAttribute('data-full-address', addr);
                  } else {
                    // If user is active, update upper fields with new wallet address
                    try {
                      const contract = (window.contractConfig && window.contractConfig.contract) || null;
                      if (contract) {
                        const u = await contract.users(addr);
                        const userIndex = u && u.index ? Number(u.index) : null;
                        if (userIndex) {
                          await autoFillupperFields(addr, userIndex);
                          console.log('üîó upper updated to new wallet address:', addr);
                        }
                      }
                    } catch(_) {}
                  }
                } catch(_) {}
              }
              // Refresh registration price on account change
              try {
                if (typeof window.connectWallet === 'function') {
                  const conn = await window.connectWallet();
                  const box = document.getElementById('reg-price-box');
                  const txt = document.getElementById('reg-price-text');
                  if (box && txt && conn && conn.contract) {
                    const wei = await (window.safeGetRegPrice ? window.safeGetRegPrice(conn.contract) : null);
                    if (wei !== null && wei !== undefined) {
                      const val = (typeof ethers !== 'undefined') ? ethers.formatUnits(wei, 18) : String(wei);
                      txt.textContent = `${Number(val).toFixed(2)} IAM`;
                      box.style.display = 'block';
                    }
                  }
                }
              } catch(_) {}

              // Refresh required cost box
              try { await updateRegistrationCost(); } catch(_) {}
              enforceRegisterButtonState();
            });
          } catch(_) {}
        }

      }
      // End of initializeWalletConnection function

      // Call wallet connection on page load
      initializeWalletConnection();
  </script>
  <script>
    let selectedAvatar = 'man';
    
    // Contract addresses (already set above)
    // const IAM_ADDRESS_NEW = '0x12155e0B8a536455d4AEe3eCa7Fbd3582c374cd2'; // New contract (Contract 5)
    
    // Default to new contract (already set above)
    // window.IAM_ADDRESS = IAM_ADDRESS_NEW;
    


    // Show status message
    function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('status-message');
        if (!statusEl) return;
        
        let className = 'register-form-status';
        let icon = '';
        
        switch(type) {
            case 'success':
                className += ' success';
                icon = '‚úÖ ';
                break;
            case 'error':
                className += ' error';
                icon = '‚ùå ';
                break;
            case 'loading':
                className += ' loading';
                icon = '‚è≥ ';
                break;
            default:
                className += ' info';
                icon = '‚ÑπÔ∏è ';
        }
        
        statusEl.className = className;
        statusEl.textContent = icon + message;
    }

    // Function to check if user is active (checks only user.index)
    function isUserActive(user) {
      if (!user) return false;
      
      // Only check user.index
      if (user.index !== undefined && user.index !== null) {
        return BigInt(user.index) !== 0n;
      }
      
      return false;
    }

    // Function to get user num value (checks only user.index)
    function getUserNumValue(user) {
      if (!user) return null;
      
      // Only check user.index
      if (user.index !== undefined && user.index !== null) {
        return BigInt(user.index);
      }
      
      return null;
    }

    // Function to check if target index is in current user's subtree
          function isIndexInUserSubtree(targetIndex, currentUserIndex) {
            console.log(`üîç Checking: target index=${targetIndex}, current user=${currentUserIndex}`);
            
            if (targetIndex === currentUserIndex) {
              console.log(`‚ùå Cannot be a subtree of itself`);
              return false;
            }
            
            // Check if target index is in current user's subtree
            let checkIndex = targetIndex;
            while (checkIndex > currentUserIndex) {
              checkIndex = Math.floor(checkIndex / 2);
              console.log(`üîç Checking path: ${checkIndex}`);
              if (checkIndex === currentUserIndex) {
                console.log(`‚úÖ Is in subtree`);
                return true;
              }
            }
            
            // Additional check: if target index is less than current user, it's not in subtree
            if (targetIndex < currentUserIndex) {
              console.log(`‚ùå Target index is less than current user`);
              return false;
            }
            
            console.log(`‚ùå Not in subtree`);
            return false;
                    }

          // Function to auto-fill upper fields with current user's info
          async function autoFillupperFields(userAddress, userIndex) {
            try {
              console.log(`üîÑ Auto-filling referrer and upper fields for active user: ${userAddress} (Index: ${userIndex})`);
              
              // Fill referrer index field
              referrerIndexInput = document.getElementById('referrer-index');
              console.log('üìç Referrer index input found:', !!referrerIndexInput);
              if (referrerIndexInput && userIndex) {
                referrerIndexInput.value = userIndex;
                console.log('‚úÖ Referrer index set to:', userIndex);
              }
              
              // Fill referrer address field
              referrerAddressDisplay = document.getElementById('referrer-address-display');
              console.log('üìç Referrer address display found:', !!referrerAddressDisplay);
              if (referrerAddressDisplay) {
                referrerAddressDisplay.value = truncateAddress(userAddress);
                referrerAddressDisplay.setAttribute('data-full-address', userAddress);
                console.log('‚úÖ Referrer address set to:', truncateAddress(userAddress));
              }
              
              // Fill upper index field (same as referrer by default)
              upperIndexInput = document.getElementById('upper-index');
              console.log('üìç Upper index input found:', !!upperIndexInput);
              if (upperIndexInput && userIndex) {
                upperIndexInput.value = userIndex;
                console.log('‚úÖ Upper index set to:', userIndex);
              }
              
              // Fill upper address field (same as referrer by default)
              upperInput = document.getElementById('upper-address');
              console.log('üìç Upper address input found:', !!upperInput);
              if (upperInput) {
                upperInput.value = truncateAddress(userAddress);
                upperInput.setAttribute('data-full-address', userAddress);
                console.log('‚úÖ Upper address set to:', truncateAddress(userAddress));
              }
              
              // Disable referrer apply button
              const applyReferrerBtn = document.getElementById('apply-referrer-index-btn');
              if (applyReferrerBtn) {
                applyReferrerBtn.disabled = true;
                applyReferrerBtn.style.opacity = '0.5';
                applyReferrerBtn.style.cursor = 'not-allowed';
                applyReferrerBtn.textContent = 'Auto-filled';
                console.log('‚úÖ Referrer apply button disabled');
              }
              
              // Upper field remains editable - user can change upper to their downlines
              
              // Show success message
              showTempMessage(`‚úÖ Auto-filled referrer and upper with your info (Index: ${userIndex}). Both fields locked by default.`, 'success');
              console.log('‚úÖ Auto-fill completed successfully');
              
              // Trigger validation
              setTimeout(async () => {
                await validateUpperAgainstupper();
                await calculatePlacementForNewUser();
              }, 500);
              
            } catch (error) {
              console.error('‚ùå Error auto-filling referrer and upper fields:', error);
            }
          }

          // Function to check if current user can register for the given address
          async function canUserRegisterForAddress(targetAddress, addressType) {
            try {
              // Try to get contract from multiple sources
              let contract = null;
              
              if (window.contractConfig && window.contractConfig.contract) {
                contract = window.contractConfig.contract;
              } else if (typeof window.connectWallet === 'function') {
                try {
                  const conn = await window.connectWallet();
                  if (conn && conn.contract) {
                    contract = conn.contract;
                  }
                } catch (e) {
                  console.log('Error getting contract from connectWallet:', e);
                }
              }
              
              if (!contract) {
                console.log('‚ùå Contract not available from any source');
                return false;
              }
              
              // Get current user info
              let myAddress = null;
              let myUser = null;
              try {
                // Try multiple methods to get current user address
                if (window.currentUserAddress) {
                  myAddress = window.currentUserAddress;
                } else if (contract.signer) {
                  myAddress = await contract.signer.getAddress();
                } else if (window.ethereum && window.ethereum.selectedAddress) {
                  myAddress = window.ethereum.selectedAddress;
                } else if (window.contractConfig && window.contractConfig.address) {
                  myAddress = window.contractConfig.address;
                }
                
                if (myAddress) {
                  myUser = await contract.users(myAddress);
                  window.currentUserAddress = myAddress;
                }
              } catch (e) {
                console.log('Error getting current user:', e);
                return false;
              }
              
              // If we still don't have an address, return false
              if (!myAddress) {
                console.log('‚ùå Could not determine current user address');
                return false;
              }
              
              // If target is the same as current user, it's always allowed
              if (myAddress && targetAddress && targetAddress.toLowerCase() === myAddress.toLowerCase()) {
                console.log(`‚úÖ Can register for self (${addressType})`);
                return true;
              }
              
              // For inactive users, allow registration for any active upper/upper
              // User is active if num exists and is non-zero
              const isMyUserActive = isUserActive(myUser);
              if (!isMyUserActive) {
                console.log(`‚ÑπÔ∏è Current user is not active. Checking if ${addressType} is active...`);
                
                // Check if target address is active
                try {
                  const targetUser = await contract.users(targetAddress);
                  // User is active if num exists and is non-zero
                  const isTargetActive = isUserActive(targetUser);
                  if (isTargetActive) {
                    console.log(`‚úÖ Target ${addressType} is active. Allowing registration.`);
                    return true;
                  } else {
                    console.log(`‚ùå Target ${addressType} is not active.`);
                    return false;
                  }
                } catch (error) {
                  console.log(`‚ùå Error checking target ${addressType}:`, error);
                  return false;
                }
              }
              
              // For active users, check if target is in their downline or is themselves
              const targetUser = await contract.users(targetAddress);
              // User is active if num exists and is non-zero
              const isTargetActive = isUserActive(targetUser);
              if (!isTargetActive) {
                console.log(`‚ùå Target ${addressType} is not active`);
                return false;
              }
              
              const myUserNumber = Number(getUserNumValue(myUser));
              const targetUserNumber = Number(getUserNumValue(targetUser));
              
              // Check if target is in current user's downline (subtree) or is the same user
              if (isIndexInUserSubtree(targetUserNumber, myUserNumber) || targetUserNumber === myUserNumber) {
                console.log(`‚úÖ Can register for ${addressType} (in downline or self)`);
                return true;
              }
              
              console.log(`‚ùå Cannot register for ${addressType} (not in downline)`);
              return false;
              
            } catch (error) {
              console.error(`‚ùå Error checking registration permission:`, error);
              return false;
            }
          }

          // Helper function to get contract instance
          async function getContractInstance() {
            try {
              // Try multiple sources
              if (window.contractConfig && window.contractConfig.contract) {
                console.log('‚úÖ Using contract from contractConfig');
                return window.contractConfig.contract;
              }
              
              if (typeof window.connectWallet === 'function') {
                const conn = await window.connectWallet();
                if (conn && conn.contract) {
                  console.log('‚úÖ Using contract from connectWallet');
                  return conn.contract;
                }
              }
              
              console.log('‚ùå No contract available');
              return null;
            } catch (error) {
              console.error('‚ùå Error getting contract:', error);
              return null;
            }
          }

    // Helper function to convert index/number to address
    async function numToAddress(contract, num) {
      try {
        // Try numToAddress first (new contract)
        if (typeof contract.numToAddress === 'function') {
          const address = await contract.numToAddress(BigInt(num));
          if (address && address !== '0x0000000000000000000000000000000000000000') {
            return address;
          }
        }
      } catch (e) {
        console.log('numToAddress failed, trying indexToAddress:', e.message);
      }
      
      try {
        // Try indexToAddress (old contract)
        if (typeof contract.indexToAddress === 'function') {
          const address = await contract.indexToAddress(BigInt(num));
          if (address && address !== '0x0000000000000000000000000000000000000000') {
            return address;
          }
        }
      } catch (e) {
        console.log('indexToAddress also failed:', e.message);
      }
      
      return null;
    }

    // Function to validate upper and upper relationship
    async function validateupperUpperRelationship(contract, upper, upperParam) {
      console.log(`üîç Validating upper-upper relationship: upper=${upper}, upper=${upperParam}`);
      
      // If upper and upper are the same, it's valid
      if (upper.toLowerCase() === upperParam.toLowerCase()) {
        console.log(`‚úÖ upper and upper are the same - valid`);
        return;
      }
      
      try {
        // Get upper user data
        const upperUser = await contract.users(upper);
        // User is active if num exists and is non-zero
        const isUpperActive = isUserActive(upperUser);
        if (!isUpperActive) {
          throw new Error('upper is not active or does not exist');
        }
        
        // Get upper user data  
        const upperU = await contract.users(upperParam);
        // User is active if num exists and is non-zero
        const isUpperActive2 = isUserActive(upperU);
        if (!isUpperActive2) {
          throw new Error('Upper address is not active or does not exist');
        }
        
        const upperUserNumber = Number(getUserNumValue(upperUser));
        const upperUserNumber2 = Number(getUserNumValue(upperU));
        
        console.log(`üîç upper user number: ${upperUserNumber}, Upper user number: ${upperUserNumber2}`);
        
        // Check if upper is in upper's subtree
        if (isIndexInUserSubtree(upperUserNumber, upperUserNumber2)) {
          console.log(`‚úÖ Upper address is in upper's subtree - valid`);
          return;
        } else {
          throw new Error('Upper address must be either the same as upper or a descendant of upper in the tree structure');
        }
        
      } catch (error) {
        console.error(`‚ùå Validation error:`, error);
        throw error;
      }
    }
      

      
          // Avatar selection
    document.querySelectorAll('.avatar-choice').forEach(el => {
      el.onclick = function() {
        document.querySelectorAll('.avatar-choice').forEach(e2 => e2.classList.remove('selected'));
        this.classList.add('selected');
        selectedAvatar = this.getAttribute('data-avatar');
      };
    });

     // Change registration type based on selected tab
     let currentRegistrationType = 'normal';
     
     
     
     // Function to update registration cost
     async function updateRegistrationCost() {
       // Normal mode: use safe regPrice function
       try {
         if (window.contractConfig && window.contractConfig.contract) {
           const contract = window.contractConfig.contract;
           const regPrice = await (window.safeGetRegPrice ? window.safeGetRegPrice(contract) : null);
           if (regPrice) {
             const regPriceNum = Number(ethers.formatUnits(regPrice, 18));
             document.getElementById('register-cost').textContent = `${regPriceNum.toFixed(2)} IAM`;
           } else {
             document.getElementById('register-cost').textContent = 'RegPrice not available';
           }
         } else {
           document.getElementById('register-cost').textContent = 'Contract not available';
         }
       } catch (e) {
         document.getElementById('register-cost').textContent = 'Error loading regPrice';
       }
     }



         // Initialize information (simplified without wallet connection)
    async function loadRegisterInfo() {
      const status = document.getElementById('status-message');
      status.textContent = '';
      
      // Enable form elements
      const registerInfoElement = document.getElementById('register-info');
      if (registerInfoElement) {
        registerInfoElement.style.display = '';
      }
      document.getElementById('register-btn').disabled = false;
      document.querySelectorAll('input').forEach(i=>i.disabled=false);
      
      // Show registration suggestion
      const suggestionDiv = document.getElementById('register-suggestion');
      if (suggestionDiv) {
        suggestionDiv.style.display = '';
        suggestionDiv.textContent = 'Please fill in the registration form below.';
      }
      
      // Clear all fields for manual input
      const upperDisplay = document.getElementById('upper-address-display');
      const upperInput = document.getElementById('upper-address');
      const newUserInputElement = document.getElementById('new-user-address');
      
      if (referrerAddressDisplay) {
        referrerAddressDisplay.value = '';
        referrerAddressDisplay.placeholder = 'Enter referrer wallet address';
      }
      if (upperInput) {
        upperInput.value = '';
        upperInput.placeholder = 'Enter upper wallet address';
      }
      if (newUserInputElement) {
        newUserInputElement.value = '';
        newUserInputElement.placeholder = 'Enter new user wallet address';
      }
      
      // Don't call updateAddressDisplay here as it triggers events and causes loops
      // The inputs are already cleared above, no need to update display
      
      // Set default values for balance displays
      const maticBalanceElement = document.getElementById('matic-balance');
      if (maticBalanceElement) {
        maticBalanceElement.textContent = 'N/A';
      }
      
      const IAMBalanceElement = document.getElementById('IAM-balance');
      if (IAMBalanceElement) {
        IAMBalanceElement.textContent = 'N/A';
      }
    }
         window.addEventListener('DOMContentLoaded', loadRegisterInfo);
     

         

    // --- Manual index application with button ---
    // Event listeners are now set up in the main DOMContentLoaded function

    // Function to apply index to address field
    async function applyIndexToAddress(indexInput, addressInput, type) {
      const value = indexInput.value.trim();
      console.log(`üîç Applying ${type} user number: ${value}`);
      
      if (!value) {
        showTempMessage(`Please enter a valid ${type} user number`, 'error');
        return;
      }
      
      try {
        // Ensure wallet connection and contract instance
        let contract = null;
        try {
          if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            contract = conn && conn.contract ? conn.contract : (window.contractConfig && window.contractConfig.contract);
          } else {
            contract = window.contractConfig && window.contractConfig.contract;
          }
        } catch(_) {}
        if (!contract) {
          showTempMessage('Wallet not connected. Please connect wallet first.', 'error');
          return;
        }
        
        // Extract numeric index
        let index = value;
        if (value.startsWith('IAM')) {
          index = value.substring(3);
        }
        index = index.replace(/[^0-9]/g, '');
        
        if (!index || index.length > 8) {
          showTempMessage(`Invalid ${type} user number format`, 'error');
          return;
        }
        
        // Get address from user number with error handling
        let address;
        try {
          // Only use indexToAddress (old contract)
          if (!contract || typeof contract.indexToAddress !== 'function') {
            throw new Error('Contract not connected or indexToAddress not available');
          }
          
          address = await contract.indexToAddress(BigInt(index));
          console.log(`üìç Using indexToAddress for index ${index}:`, address);
          
          // Check if address is valid
          if (!address || address === '0x0000000000000000000000000000000000000000') {
            throw new Error('User number does not exist');
          }
          
          console.log(`‚úÖ Found ${type} address for number ${index}:`, address);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Error getting address for user number ${index}:`, error.message);
          showTempMessage(`${type} user number ${index} does not exist in the contract`, 'error');
          return;
        }
        
        // Set the address (store full address, display truncated)
        addressInput.value = address;
        addressInput.setAttribute('data-full-address', address);
        addressInput.style.backgroundColor = '#232946';
        addressInput.style.color = '#fff';
        
        // Update display with truncated address
        updateAddressDisplay(addressInput);
        
        // For upper, also update the display field
        if (type === 'upper') {
          addressInput.value = address;
          addressInput.setAttribute('data-full-address', address);
          updateAddressDisplay(addressInput);
          
          // Keep the index input value (don't clear it)
          // upperIndexInput.value stays as entered by user
        }
        
        showTempMessage(`${type} address set successfully`, 'success');
        console.log(`‚úÖ ${type} address set: ${address}`);
        
        // If this is upper address, validate against upper and show placement info
        if (type === 'upper') {
          await validateUpperAgainstupper();
        }
        
      } catch (error) {
        console.error(`Error applying ${type} index:`, error);
        showTempMessage(`Error applying ${type} index: ${error.message}`, 'error');
      }
    }
     

         // Address field event listeners are now set up in setupEventListeners function
     
    // Function to truncate address for display
    function truncateAddress(address) {
      if (!address || address.length < 10) return address;
      return address.substring(0, 6) + '...' + address.substring(address.length - 4);
    }
    
    // Function to update address display with truncation
    function updateAddressDisplay(addressInput) {
      if (!addressInput) return;
      
      // Prevent infinite loop by temporarily removing event listeners
      const fullAddress = addressInput.getAttribute('data-full-address') || addressInput.value;
      if (fullAddress && fullAddress.length > 10) {
        // Set value without triggering input events
        const oldValue = addressInput.value;
        addressInput.value = truncateAddress(fullAddress);
        // Only update if different to avoid unnecessary re-renders
        if (addressInput.value === oldValue && addressInput.value !== truncateAddress(fullAddress)) {
          addressInput.value = truncateAddress(fullAddress);
        }
      }
    }
    
    // Function to check address validity
    async function checkAddressValidity(addressInput, type) {
      const address = addressInput.value.trim();
      if (!/^0x[a-fA-F0-9]{40}$/.test(address)) return;
      
      try {
        // Ensure wallet connection and contract instance
        let contract = null;
        try {
          if (typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            contract = conn && conn.contract ? conn.contract : (window.contractConfig && window.contractConfig.contract);
          } else {
            contract = window.contractConfig && window.contractConfig.contract;
          }
        } catch(_) {}
        if (!contract) {
          showTempMessage('Wallet not connected. Please connect wallet first.', 'error');
          return;
        }
        
        // Check if address is active
        const user = await contract.users(address);
        // User is active if num exists and is non-zero
        const isUserActive2 = isUserActive(user);
        if (!isUserActive2) {
          showTempMessage(`${type} address is not active`, 'error');
          return;
        }
        
        showTempMessage(`${type} address is valid`, 'success');
      } catch (e) {
        showTempMessage(`Error checking ${type} address: ${e.message}`, 'error');
      }
    }
    
    // Function to validate upper address against referrer in real-time
    async function validateUpperAgainstReferrer() {
      const statusEl = document.getElementById('upper-validation-status');
      const placementEl = document.getElementById('placement-info');
      if (!statusEl || !placementEl) return;
      
      const referrer = referrerDisplay.getAttribute('data-full-address') || referrerDisplay.value.trim();
      const upper = upperInput.getAttribute('data-full-address') || upperInput.value.trim();
      
      if (!upper || upper === 'root' || !/^0x[a-fA-F0-9]{40}$/.test(upper)) {
        return;
      }
      
      try {
        const capacityCheck = await checkUpperCapacity(upper);
        
        // Show capacity status in upper field placeholder or nearby element
        if (capacityCheck.hasCapacity) {
          upperInput.style.borderColor = capacityCheck.message.includes('‚ö†Ô∏è') ? '#ff4444' : '#00ff88';
          upperInput.title = capacityCheck.message;
        } else {
          upperInput.style.borderColor = '#ff4444';
          upperInput.title = capacityCheck.message;
          showTempMessage(capacityCheck.message, 'error');
        }
      } catch (error) {
        console.error('Error in real-time capacity check:', error);
      }
    }

    // Function to validate upper address against upper in real-time
    async function validateUpperAgainstupper() {
      const statusEl = document.getElementById('upper-validation-status');
      const placementEl = document.getElementById('placement-info');
      if (!statusEl) return;
      
      const referrer = referrerAddressDisplay.getAttribute('data-full-address') || referrerAddressDisplay.value.trim();
      const upperForValidation = upperInput.getAttribute('data-full-address') || upperInput.value.trim();
      
      if (!referrer || referrer === 'root') {
        statusEl.style.display = 'none';
        if (placementEl) placementEl.style.display = 'none';
        return;
      }
      if (!/^0x[a-fA-F0-9]{40}$/.test(referrer)) {
        statusEl.style.display = 'none';
        if (placementEl) placementEl.style.display = 'none';
        return;
      }
      
      try {
        if (!window.contractConfig || !window.contractConfig.contract) return;
        const contract = window.contractConfig.contract;
        
        if (currentRegistrationType === 'normal') {
          // Simple validation: check if upper is valid address
          if (!upperForValidation || upperForValidation === 'root' || !/^0x[a-fA-F0-9]{40}$/.test(upperForValidation)) {
            statusEl.style.display = 'none';
            if (placementEl) placementEl.style.display = 'none';
            return;
          }
          
          // Check if current user can register for this upper address
          const canRegisterForUpper = await canUserRegisterForAddress(upper, 'upper');
          if (!canRegisterForUpper) {
            statusEl.className = 'register-form-status error';
            statusEl.textContent = '‚ùå You can only register for yourself or your downlines';
            statusEl.style.display = '';
            if (placementEl) placementEl.style.display = 'none';
            showTempMessage('You can only register for yourself or your downlines. This upper address is not in your downline.', 'error');
            return;
          }
          
          await validateReferrerUpperRelationship(contract, referrer, upper);
          statusEl.className = 'register-form-status success';
          statusEl.textContent = '‚úÖ Upper address is valid for this referrer';
          statusEl.style.display = '';
          
          // Show placement information
          await showPlacementInfo(contract, upper);
          
          showTempMessage('Upper address is valid for this referrer', 'success');
        } else if (currentRegistrationType === 'free') {
          // Reserve registration: show placement info based on upper (connected wallet)
          statusEl.style.display = 'none';
          await showReservePlacementInfo(contract, upper);
          showTempMessage('Reserve placement calculated based on connected wallet', 'success');
        }
      } catch (error) {
        statusEl.className = 'register-form-status error';
        statusEl.textContent = '‚ùå ' + error.message;
        statusEl.style.display = '';
        if (placementEl) placementEl.style.display = 'none';
        showTempMessage(error.message, 'error');
      }
    }
    
    // Function to show placement info for reserve registration (registerFree algorithm)
    async function showReservePlacementInfo(contract, upperAddress) {
      const placementEl = document.getElementById('placement-info');
      if (!placementEl) return;
      
      try {
        // Get upper user data (connected wallet)
        const upperUser = await contract.users(upperAddress);
        if (!upperUser || !(upperUser.index && BigInt(upperUser.index) > 0n)) {
          placementEl.style.display = 'none';
          return;
        }
        
        let parentIndex = Number(upperUser.index);
        let parentAddr = upperAddress;
        let found = false;
        let isLeft = false;
        let path = [parentIndex]; // Track the path taken
        
        // Simulate the exact registerFree algorithm
        while (!found) {
          const leftAddress = await contract.getLeftAddress(parentIndex);
          const rightAddress = await contract.getRightAddress(parentIndex);
          
          if (leftAddress === '0x0000000000000000000000000000000000000000') {
            // Left position is available
            isLeft = true;
            found = true;
            path.push(parentIndex * 2);
          } else if (rightAddress === '0x0000000000000000000000000000000000000000') {
            // Right position is available
            isLeft = false;
            found = true;
            path.push(parentIndex * 2 + 1);
          } else {
            // Both positions are occupied, need to find the path with fewer points
            try {
              const leftChildIndex = parentIndex * 2;
              const rightChildIndex = parentIndex * 2 + 1;
              
              const leftChildAddress = await contract.indexToAddress(leftChildIndex);
              const rightChildAddress = await contract.indexToAddress(rightChildIndex);
              
              if (leftChildAddress === '0x0000000000000000000000000000000000000000' || 
                  rightChildAddress === '0x0000000000000000000000000000000000000000') {
                // One of the children doesn't exist, this shouldn't happen
                throw new Error('Invalid tree structure');
              }
              
              const leftUser = await contract.users(leftChildAddress);
              const rightUser = await contract.users(rightChildAddress);
              
              const leftCount = Number(leftUser.leftPoints) + Number(leftUser.rightPoints);
              const rightCount = Number(rightUser.leftPoints) + Number(rightUser.rightPoints);
              
              if (leftCount <= rightCount) {
                parentIndex = leftChildIndex;
                parentAddr = leftChildAddress;
                path.push(leftChildIndex);
              } else {
                parentIndex = rightChildIndex;
                parentAddr = rightChildAddress;
                path.push(rightChildIndex);
              }
            } catch (error) {
              console.error('Error in tree traversal:', error);
              placementEl.className = 'register-form-status error';
              placementEl.textContent = '‚ùå Error calculating placement position';
              placementEl.style.display = '';
              return;
            }
          }
        }
        
        const userIndex = isLeft ? parentIndex * 2 : parentIndex * 2 + 1;
        const position = isLeft ? 'LEFT' : 'RIGHT';
        
        // Show placement information for reserve (exact registerFree algorithm)
        placementEl.className = 'register-form-status info';
        placementEl.innerHTML = `
          <div style="margin-bottom: 2px;">üìç Reserve user will be placed as <strong>${position}</strong> child</div>
          <div style="font-size: 0.65rem; opacity: 0.8; margin-bottom: 2px;">Final Index: <strong>${userIndex}</strong></div>
          <div style="font-size: 0.6rem; opacity: 0.7; margin-bottom: 2px;">Parent: ${parentAddr.substring(0, 6)}...${parentAddr.substring(38)} (Index: ${parentIndex})</div>
          <div style="font-size: 0.6rem; opacity: 0.7;">Path: ${path.slice(0, -1).join(' ‚Üí ')} ‚Üí <strong>${userIndex}</strong></div>
          <div style="font-size: 0.6rem; opacity: 0.6; margin-top: 2px; color: #ff6b6b;">‚ö†Ô∏è Reserve: User will be inactive (binaryPointCap = 0)</div>
        `;
        placementEl.style.display = '';
        
      } catch (error) {
        console.error('Error getting reserve placement info:', error);
        placementEl.className = 'register-form-status error';
        placementEl.textContent = '‚ùå Error calculating placement position';
        placementEl.style.display = '';
      }
    }
    
    // Function to show where new user will be placed (using smart contract algorithm)
    async function showPlacementInfo(contract, upperAddress) {
      const placementEl = document.getElementById('placement-info');
      if (!placementEl) return;
      
      try {
        // Get upper user data
        const upperUser = await contract.users(upperAddress);
        if (!upperUser || !(upperUser.index && BigInt(upperUser.index) > 0n)) {
          placementEl.style.display = 'none';
          return;
        }
        
        let parentIndex = Number(upperUser.index);
        let found = false;
        let isLeft = false;
        let path = [parentIndex]; // Track the path taken
        
        // Simulate the smart contract algorithm
        while (!found) {
          const leftAddress = await contract.getLeftAddress(parentIndex);
          const rightAddress = await contract.getRightAddress(parentIndex);
          
          if (leftAddress === '0x0000000000000000000000000000000000000000') {
            // Left position is available
            isLeft = true;
            found = true;
            path.push(parentIndex * 2);
          } else if (rightAddress === '0x0000000000000000000000000000000000000000') {
            // Right position is available
            isLeft = false;
            found = true;
            path.push(parentIndex * 2 + 1);
          } else {
            // Both positions are occupied, need to find the path with fewer points
            try {
              const leftChildIndex = parentIndex * 2;
              const rightChildIndex = parentIndex * 2 + 1;
              
              const leftChildAddress = await contract.indexToAddress(leftChildIndex);
              const rightChildAddress = await contract.indexToAddress(rightChildIndex);
              
              if (leftChildAddress === '0x0000000000000000000000000000000000000000' || 
                  rightChildAddress === '0x0000000000000000000000000000000000000000') {
                // One of the children doesn't exist, this shouldn't happen
                throw new Error('Invalid tree structure');
              }
              
              const leftUser = await contract.users(leftChildAddress);
              const rightUser = await contract.users(rightChildAddress);
              
              const leftCount = Number(leftUser.leftPoints) + Number(leftUser.rightPoints);
              const rightCount = Number(rightUser.leftPoints) + Number(rightUser.rightPoints);
              
              if (leftCount <= rightCount) {
                parentIndex = leftChildIndex;
                path.push(leftChildIndex);
              } else {
                parentIndex = rightChildIndex;
                path.push(rightChildIndex);
              }
            } catch (error) {
              console.error('Error in tree traversal:', error);
              placementEl.className = 'register-form-status error';
              placementEl.textContent = '‚ùå Error calculating placement position';
              placementEl.style.display = '';
              return;
            }
          }
        }
        
        const finalIndex = isLeft ? parentIndex * 2 : parentIndex * 2 + 1;
        const position = isLeft ? 'LEFT' : 'RIGHT';
        
        // Show placement information
        placementEl.className = 'register-form-status info';
        placementEl.innerHTML = `
          <div style="margin-bottom: 2px;">üìç New user will be placed as <strong>${position}</strong> child</div>
          <div style="font-size: 0.65rem; opacity: 0.8; margin-bottom: 2px;">Final Index: <strong>${finalIndex}</strong></div>
          <div style="font-size: 0.6rem; opacity: 0.7;">Path: ${path.slice(0, -1).join(' ‚Üí ')} ‚Üí <strong>${finalIndex}</strong></div>
        `;
        placementEl.style.display = '';
        
      } catch (error) {
        console.error('Error getting placement info:', error);
        placementEl.className = 'register-form-status error';
        placementEl.textContent = '‚ùå Error calculating placement position';
        placementEl.style.display = '';
      }
    }
     

     

     
            // Event listeners for newUserInput are now set up in setupEventListeners function
       
             // Function to check new user address
        async function checkNewUserAddress() {
        const address = newUserInput.value.trim();
        const status = document.getElementById('status-message');
        
                 // ÿß⁄Øÿ± ÿ¢ÿØÿ±ÿ≥ ÿÆÿßŸÑ€å ÿßÿ≥ÿ™ÿå Ÿæ€åÿßŸÖ ÿ±ÿß Ÿæÿß⁄© ⁄©ŸÜ
         if (!address) {
           status.textContent = '';
           return;
         }
         
         // ÿ®ÿ±ÿ±ÿ≥€å ŸÅÿ±ŸÖÿ™ ÿ¢ÿØÿ±ÿ≥
         if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
           status.style.color = '#d32f2f';
           status.textContent = 'The entered address is not valid. Please enter a correct address.';
           return;
         }
        
        try {
          // Function disabled - requires wallet connection
          status.style.color = '#d32f2f';
          status.textContent = 'This function requires wallet connection.';
          return;
          
          // ÿØÿ±€åÿßŸÅÿ™ ÿ¢ÿØÿ±ÿ≥ ⁄©ÿßÿ±ÿ®ÿ± ÿ¨ÿßÿ±€å
          let myAddress = null;
          try {
            if (window.currentUserAddress) {
              myAddress = window.currentUserAddress;
            } else {
              myAddress = contract.signer ? await contract.signer.getAddress() : null;
              if (myAddress) {
                window.currentUserAddress = myAddress;
              }
            }
          } catch (e) {
            console.log(`ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ¢ÿØÿ±ÿ≥ ⁄©ÿßÿ±ÿ®ÿ± ÿ¨ÿßÿ±€å:`, e);
          }
          
                     // ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ¢€åÿß ÿß€åŸÜ ÿ¢ÿØÿ±ÿ≥ ŸÇÿ®ŸÑÿßŸã ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿ¥ÿØŸá ÿßÿ≥ÿ™
           const user = await contract.users(address);
           // User is active if num exists and is non-zero
           const isUserRegistered = isUserActive(user);
           if (isUserRegistered) {
             status.style.color = '#d32f2f';
             status.textContent = 'This address is already registered.';
             return;
           }
           
           // ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ÿ¢€åÿß ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å ÿÆŸàÿØÿ¥ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ŸÖ€å‚Äå⁄©ŸÜÿØ
           if (address.toLowerCase() === myAddress.toLowerCase()) {
             status.style.color = '#388e3c';
             status.textContent = 'You can register for yourself.';
           } else {
             // ÿß⁄Øÿ± ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ŸÜÿ¥ÿØŸáÿå Ÿæ€åÿßŸÖ ŸÖŸàŸÅŸÇ€åÿ™
             status.style.color = '#388e3c';
             status.textContent = 'New user address is valid and can be registered.';
           }
          
                     // ŸÜŸÖÿß€åÿ¥ ÿ¥ŸÖÿßÿ±Ÿá ⁄©ÿßÿ±ÿ®ÿ± ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ÿß€åŸÜ ÿ¢ÿØÿ±ÿ≥ (ÿß⁄Øÿ± Ÿàÿ¨ŸàÿØ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ)
           try {
             // ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ÿ¥ŸÖÿßÿ±Ÿá‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàÿ¨ŸàÿØ ÿ®ÿ±ÿß€å €åÿßŸÅÿ™ŸÜ ÿß€åŸÜ ÿ¢ÿØÿ±ÿ≥
             let foundUserNumber = null;
             for (let i = 1; i <= 1000; i++) { // ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± 1000 ÿ¥ŸÖÿßÿ±Ÿá ⁄©ÿßÿ±ÿ®ÿ± ÿßŸàŸÑ
               try {
                 // Try numToAddress (new contract)
                 const addrAtNumber = await contract.numToAddress(i);
                 if (addrAtNumber.toLowerCase() === address.toLowerCase()) {
                   foundUserNumber = i;
                   break;
                 }
               } catch (e) {
                 // ÿß⁄Øÿ± ÿ¥ŸÖÿßÿ±Ÿá ⁄©ÿßÿ±ÿ®ÿ± Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØÿå ÿßÿØÿßŸÖŸá ÿ®ÿØŸá
                 continue;
               }
             }
             
             if (foundUserNumber) {
               status.textContent += ` (User Number: ${foundUserNumber})`;
             }
                      } catch (e) {
             // ÿß⁄Øÿ± ÿÆÿ∑ÿß ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ÿß€åŸÜÿØ⁄©ÿ≥ ÿØÿßÿ¥ÿ™€åŸÖÿå ŸÜÿßÿØ€åÿØŸá ÿ®⁄Ø€åÿ±
           }
         } catch (e) {
           showTempMessage('Error checking address: ' + (e.message || e), 'error');
         }
       }
       
       // Function to calculate placement for new user when both upper and new user are provided
       async function calculatePlacementForNewUser() {
         const newUserAddress = newUserInput.value.trim();
         const referrerAddress = referrerAddressDisplay.getAttribute('data-full-address') || referrerAddressDisplay.value.trim();
         
         // Only calculate if both addresses are valid and different
         if (!newUserAddress || !referrerAddress || 
             !/^0x[a-fA-F0-9]{40}$/.test(newUserAddress) || 
             !/^0x[a-fA-F0-9]{40}$/.test(referrerAddress) ||
             newUserAddress.toLowerCase() === referrerAddress.toLowerCase()) {
           return;
         }
         
         try {
           if (!window.contractConfig || !window.contractConfig.contract) return;
           const contract = window.contractConfig.contract;
           
           // Get current user info
           let myAddress = null;
           let myUser = null;
           try {
             if (window.currentUserAddress) {
               myAddress = window.currentUserAddress;
               myUser = await contract.users(myAddress);
             } else {
               myAddress = contract.signer ? await contract.signer.getAddress() : null;
               if (myAddress) {
                 myUser = await contract.users(myAddress);
                 window.currentUserAddress = myAddress;
               }
             }
           } catch (e) {
             console.log('Error getting current user:', e);
             return;
           }
           
          // Only show placement if current user is active
          // User is active if num exists and is non-zero
          const isMyUserActive = isUserActive(myUser);
          if (!isMyUserActive) {
            return;
          }
           
           
         } catch (error) {
           console.error('Error calculating placement for new user:', error);
         }
       }
      
                            
                            
                            // Register new user (based on selected type)
    console.log('üîß Setting up register button onclick handler...');
    const registerBtnElement = document.getElementById('register-btn');
    console.log('üîç Register button element:', registerBtnElement);
    
    // Remove any existing event listeners
    registerBtnElement.replaceWith(registerBtnElement.cloneNode(true));
    const newRegisterBtn = document.getElementById('register-btn');
    console.log('üîç New button element:', newRegisterBtn);
    
    newRegisterBtn.addEventListener('click', async function(e) {
      e.preventDefault();
      e.stopPropagation();
      console.log('üöÄ Register button clicked!');
      const status = document.getElementById('status-message');
      const registerBtn = this;
      
      // Disable button and show loading state
      console.log('üîÑ Disabling button...');
      registerBtn.disabled = true;
      registerBtn.style.opacity = '0.6';
      registerBtn.innerHTML = '‚è≥ Registering...';
      status.style.color = '#1976d2';
      status.textContent = 'Validating information...';
      
      try {
        console.log('‚úÖ Starting registration process...');
        // Ensure wallet connection and get contract instance
        let contract = null, signerAddress = null;
        try {
          // First, try to use existing contract from window.contractConfig
          if (window.contractConfig && window.contractConfig.contract) {
            contract = window.contractConfig.contract;
            // Try to get signer address
            if (window.contractConfig.signer) {
              try {
                signerAddress = await window.contractConfig.signer.getAddress();
              } catch(_) {}
            }
          }
          
          // Only call connectWallet if we don't have a contract yet
          if (!contract && typeof window.connectWallet === 'function') {
            const conn = await window.connectWallet();
            if (conn && conn.contract) {
              contract = conn.contract;
              signerAddress = conn.address || (conn.signer ? await conn.signer.getAddress() : null);
            }
          }
        } catch(_) {}
        if (!contract) {
          status.style.color = '#ff6b6b';
          status.textContent = 'Registration requires wallet connection. Please connect your wallet first.';
          registerBtn.disabled = false;
          registerBtn.style.opacity = '1';
          registerBtn.innerHTML = 'Register';
          return;
        }

        // Get full addresses for registration (not truncated display)
        console.log('üîç Getting registration parameters...');
        const parentUpper = referrerAddressDisplay.getAttribute('data-full-address') || referrerAddressDisplay.value.trim();
        const upperReferrer = upperInput.getAttribute('data-full-address') || upperInput.value.trim();
        const newUser = newUserInput.value.trim();
        
        console.log('üìã Registration parameters:', { parentUpper, upperReferrer, newUser });
        
        // Validate inputs
        console.log('üîç Validating inputs...');
        if (!/^0x[a-fA-F0-9]{40}$/.test(parentUpper)) {
          console.error('‚ùå Invalid parentUpper address');
          throw new Error('Invalid upper address. Please enter a valid address.');
        }
        console.log('‚úÖ Parent address is valid');
        if (!/^0x[a-fA-F0-9]{40}$/.test(newUser)) throw new Error('Invalid new wallet address. Please enter a valid address.');
        
        // Validate upper address if provided
        if (!upperReferrer || upperReferrer === 'root') {
          console.log('‚ö†Ô∏è Upper not provided, will use parent as upper');
        } else if (!/^0x[a-fA-F0-9]{40}$/.test(upperReferrer)) {
          throw new Error('Invalid upper address.');
        }
        // Get current user address for balance checking
        let myAddress = null;
        try {
          if (contract.signer) {
            myAddress = await contract.signer.getAddress();
          } else if (window.ethereum && window.ethereum.selectedAddress) {
            myAddress = window.ethereum.selectedAddress;
          }
          console.log('üîç Current user address:', myAddress);
        } catch (e) {
          console.error('Error getting user address:', e);
          throw new Error('Unable to get your wallet address. Please connect your wallet.');
        }
        
        if (!myAddress) {
          throw new Error('Unable to get your wallet address. Please connect your wallet.');
        }
        
        // ========== ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å 1: ÿ®ÿ±ÿ±ÿ≥€å ÿß€åŸÜ⁄©Ÿá ŸàÿßŸÑÿØ ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™ ==========
        status.textContent = 'Checking parent address...';
        console.log('üîç Validating parent address: ' + parentUpper);
        
            const parentUser = await contract.users(parentUpper);
        
        // Check if parent has valid num (non-zero means active)
        const isParentActive = isUserActive(parentUser);
        if (!isParentActive) {
          throw new Error('Parent address is not active or does not exist.');
        }
        console.log('‚úÖ Parent is active');
        
        // ========== ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å 2: Validate and determine the upper (direct parent) ==========
        console.log('üîç Validating upper and determining final upper...');
        
        if (upperReferrer && upperReferrer !== 'root' && /^0x[a-fA-F0-9]{40}$/.test(upperReferrer)) {
          try {
            console.log('üîç Fetching upper user data...');
            const upperUserData = await contract.users(upperReferrer);
            console.log('‚úÖ Upper user data retrieved');
            
            // User is active if num exists and is non-zero
            const isUpperActive = isUserActive(upperUserData);
            console.log('üîç Upper active status:', isUpperActive);
            
            if (!isUpperActive) {
              console.log('‚ö†Ô∏è Upper is not active, will use referrer as upper');
              upperReferrer = parentUpper; // Use referrer as upper if provided upper is invalid
            } else {
              console.log('‚úÖ Upper is active, checking if in referrer\'s downline...');
              
              // Check if upper is in referrer's downline using contract function
              // isInDownline(ancestor, descendant) - check if upper is descendant of referrer
              try {
                const isInReferrerDownline = await contract.isInDownline(parentUpper, upperReferrer);
                console.log('üîç isInDownline result:', isInReferrerDownline, 'ancestor (referrer):', parentUpper, 'descendant (upper):', upperReferrer);
                
                if (!isInReferrerDownline) {
                  console.log('‚ö†Ô∏è Upper is not in referrer\'s downline, will use referrer as upper');
                  upperReferrer = parentUpper; // Use referrer as upper
                } else {
                  console.log('‚úÖ Upper is in referrer\'s downline');
                }
              } catch (error) {
                console.error('‚ùå Error checking downline:', error);
                console.log('‚ö†Ô∏è Could not validate downline relationship, using referrer as upper');
                upperReferrer = parentUpper;
              }
            }
          } catch (error) {
            console.error('‚ùå Error fetching upper user data:', error);
            console.log('‚ö†Ô∏è Upper address error, will use referrer as upper');
            upperReferrer = parentUpper;
          }
        } else {
          console.log('‚ÑπÔ∏è No upper provided, will use referrer as upper');
          upperReferrer = parentUpper;
        }
        
        console.log('‚úÖ Final upper (direct parent):', upperReferrer);
        
        // Check capacity of the final upper
        console.log('üîç Checking capacity of upper:', upperReferrer);
        status.textContent = 'Checking upper capacity...';
        const capacityCheck = await checkUpperCapacity(upperReferrer);
        console.log('üìä Capacity check result:', capacityCheck);
        if (!capacityCheck.hasCapacity) {
          throw new Error(capacityCheck.message);
        }
        console.log('‚úÖ Upper has capacity:', capacityCheck.message);
        
        // ========== ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å 3: ŸÖŸÇÿØÿßÿ± ⁄©ÿßŸÅ€å IAM ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ ==========
        console.log('üìä Checking IAM balance...');
        status.textContent = 'Checking IAM balance...';
        const userBalance = await contract.balanceOf(myAddress);
        let requiredAmount;
         
                   // Always use regPrice from contract
                   status.textContent = 'Getting registration price...';
                   try {
                     const regPrice = await (window.safeGetRegPrice ? window.safeGetRegPrice(contract) : null);
                     if (regPrice) {
                       requiredAmount = regPrice;
                     } else {
                       throw new Error('RegPrice not available');
                     }
                   } catch (e) {
                     console.log('Error getting regPrice:', e);
                     throw new Error('Unable to get registration price');
                   }
         
         if (userBalance < requiredAmount) {
           const requiredFormatted = Number(ethers.formatEther(requiredAmount)).toFixed(2);
           const currentFormatted = Number(ethers.formatEther(userBalance)).toFixed(2);
           throw new Error(`Insufficient IAM balance. Required: ${requiredFormatted} IAM, Current: ${currentFormatted} IAM`);
         }
         
                  showTempMessage('Sending registration request to network... Please wait for transaction confirmation.', 'info');
          localStorage.setItem('avatar_' + newUser, selectedAvatar);
          
                   // Simplified registration logic for new contract
        let tx;
        // Use registerAndActivate with the validated values
        status.textContent = 'Sending transaction...';
        registerBtn.innerHTML = '‚è≥ Sending Transaction...';
        
        // Use upperReferrer as the upper (direct parent)
        // upperReferrer is already validated and set to parentUpper if invalid
        console.log('üì§ Final registration parameters:', {
          referrer: parentUpper,
          upper: upperReferrer,
          newUser: newUser
        });
        console.log('üìù Explaining:');
        console.log('  - referrer:', parentUpper, '= Referrer (promoter, can be multiple levels up or same as upper)');
        console.log('  - upper:', upperReferrer, '= Upper (direct parent where new user will be placed)');
        console.log('  - newUser:', newUser, '= New user to register');
        
        // Send transaction (single attempt, no retry)
        console.log('üöÄ Calling registerAndActivate(referrer, upper, newUser)...');
        status.textContent = 'Sending transaction...';
        
        try {
          tx = await contract.registerAndActivate(parentUpper, upperReferrer, newUser);
          console.log('‚úÖ Transaction sent successfully, tx hash:', tx.hash);
        } catch (txError) {
          console.error('‚ùå Transaction failed:', txError);
          throw txError;
        }
          
         showTempMessage('Waiting for network transaction confirmation...', 'info');
         status.textContent = 'Waiting for confirmation...';
         registerBtn.innerHTML = '‚è≥ Confirming...';
          await tx.wait();
        showMessageBox('Registration completed successfully! Welcome to IAM family.', 'success');
        setTimeout(loadRegisterInfo, 1500);
      } catch (e) {
        let errorMsg = e && (e.reason || (e.revert && e.revert.args && e.revert.args[0]) || e.message || e);
        if (typeof errorMsg !== 'string') errorMsg = JSON.stringify(errorMsg);
        if (/already registered|Already registered/i.test(errorMsg)) {
          showTempMessage('This address is already registered.', 'error');
        } else if (/403|Non-200 status code|rate limit/i.test(errorMsg)) {
          showTempMessage('‚ö†Ô∏è Network error (403): Rate limit exceeded. Please wait a moment and try again.', 'error');
        } else if (/not active|inactive/i.test(errorMsg)) {
          showTempMessage('Selected upper is not active. Please enter an active upper.', 'error');
                   } else if (/invalid upper|upper/i.test(errorMsg)) {
           showTempMessage('Invalid upper address or does not exist.', 'error');
                   } else if (/insufficient|balance/i.test(errorMsg)) {
              // ÿß⁄Øÿ± ÿÆÿ∑ÿß€å ⁄©ŸÖÿ®ŸàÿØ ŸÖŸàÿ¨ŸàÿØ€å ÿßÿ≤ smart contract ÿ¢ŸÖÿØŸáÿå ŸáŸÖÿßŸÜ Ÿæ€åÿßŸÖ ÿ±Ÿà ŸÜÿ¥ŸàŸÜ ÿ®ÿØŸá
             if (errorMsg.includes('IAM balance insufficient')) {
             showMessageBox(errorMsg, 'error');
           } else {
             showTempMessage('Your IAM balance is insufficient for registration.', 'error');
           }
                   } else if (/403|Non-200 status code/i.test(errorMsg)) {
          showMessageBox('‚ö†Ô∏è Network error (403): Too many requests. Please wait a moment and try again, or check your internet connection.', 'error');
        } else if (/user rejected|reject/i.test(errorMsg)) {
          showTempMessage('Registration process was cancelled by you.', 'error');
        } else if (/execution reverted/i.test(errorMsg)) {
          const match = errorMsg.match(/reverted: "([^"]+)"/);
          if (match && match[1]) {
            showTempMessage('Error: ' + match[1], 'error');
          } else {
             showTempMessage('Transaction was reverted by contract. Please check inputs.', 'error');
          }
        } else {
          showMessageBox('‚ùå Registration error: ' + (errorMsg.length > 120 ? errorMsg.slice(0,120)+'...' : errorMsg), 'error');
        }
      } finally {
        // Restore button state
        registerBtn.disabled = false;
        registerBtn.style.opacity = '1';
        registerBtn.innerHTML = 'Register';
      }
    });

     

    // Index input event listeners are now set up in setupEventListeners function
  </script>
  
  
</body>
</html> 